;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Cairo Surface
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Jeremie Lasalle Ratelle.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2008
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;    Guillaume Cartier
;;;    Vladimir Sedach <vsedach@gmail.com>
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(module protected jazz.graphic.Surface jazz


(import (jazz.geometry)
        (jazz.graphic)
        (jazz.graphic.image)
        (jazz.io)
        (jazz.library)
        (jazz.platform.cairo)
        (jazz.platform.pango))


;; clipper -> clip rectangle used by the view painting algorithm


(class Surface extends Object
  
  
  (slot surface                                                       getter generate)
  (slot context)
  (slot pango-layout)
  (slot clipper            <Rect>       initialize (new Rect 0 0 0 0) getter generate)
  (slot font                            initialize #f)
  (slot line-width                      initialize 1)
  (slot landscape?         <bool>       initialize #f)
  (slot landscape-rotation <symbol+>    initialize #f)
  (slot landscape-page     <Dimension+> initialize #f)

  
  (method override (initialize surface . rest)
    (nextmethod)
    (set! surface~self surface)
    (set! context~self (cairo_create surface))
    (set! pango-layout~self (pango_cairo_create_layout context~self))
    (destroy-mandatory))


  (method override (destroy)
    (g_object_unref pango-layout)
    (set! pango-layout #f)
    (when surface
      (cairo_surface_destroy surface)
      (set! surface #f))
    (destroy-context)
    (nextmethod))


  (method protected (destroy-context)
    (when context
      (cairo_destroy context)
      (set! context #f)))

  
  ;;;
  ;;;; Clipping and transformation matrix
  ;;;

  
  (method public (get-logical-clipper) <Rect>
    (let ((clipper (get-clipper)))
      (receive (left top) (cairo_device_to_user context (get-left~ clipper) (get-top~ clipper))
        (receive (right bottom) (cairo_device_to_user context (get-right~ clipper) (get-bottom~ clipper))
          (new Rect left top right bottom)))))

  
  (method public (with-clipper rect proc)
    (let ((old-clipper clipper))
      (unwind-protect
       (begin
         (set! clipper rect)
         (cairo_save context)
         (rectangle-path rect)
         (cairo_clip context)
         (proc))
       (cairo_restore context)
       (set! clipper old-clipper))))  
  
  
  ;; lh lv : position of the drawing relative to the player
  (method public (with-transform lh lv width height proc)
    (unwind-protect
     (begin
       (cairo_save context)
       (cairo_identity_matrix context)
       (with-clipper (new Rect lh lv (+ lh width) (+ lv height))
         (lambda ()
           (cairo_translate context (cast <fl> lh) (cast <fl> lv))
           (proc))))
     (cairo_restore context)))
           
   
  ;;;
  ;;;; Text
  ;;;


  (definition (get-font-description font)
    (pango-font-description (get-font-name~ font) (get-point-size~ font) (get-italic?~ font) (get-bold?~ font)))

  
  (method protected (update-font font) ;; lazy font setting
    (unless (eq? font font~self)
      (set! font~self font)
      (let ((font-description (get-font-description font)))
        (pango-layout-set-font pango-layout font-description)
        (pango_font_description_free font-description))))
  

  (define extents-cache (make-table weak-keys: #t))
  (method public (get-text-extent text <string> font (from 0) (to -1))
    (or (table-ref extents-cache (cons font~self text) #f) ;; this ignores from, to; probably will show up as bug in tabbed text drawing
        (begin (update-font font)
               (pango-set-text pango-layout text from to)
               (let ((extents (pango-get-extents pango-layout)))
                 (table-set! extents-cache (cons font~self text) extents)
                 extents))))


  (define font-height-cache (make-table test: eq?))
  (method public (get-font-height font)
    (or (table-ref font-height-cache font #f)
        (let* ((font-description (get-font-description font))
               (px-height (pango-font-height pango-layout font-description)))
          (pango_font_description_free font-description)
          (table-set! font-height-cache font px-height)
          px-height)))
    
  
  (method public (draw-text h <fx> v <fx> str <string> font color (from 0) (to -1))
    (unless (string=? str "")
      (update-font font)
      (set-color color)
      (pango-set-text pango-layout str from to)
      (move-to h v)
      (pango_cairo_show_layout context~self pango-layout)))


  ;;;
  ;;;; Region
  ;;;
  
  
  (method public (fill-region region <Region> color)
    (loop (for rect in (get-rectangles~ region))
          (do (fill-rect rect color))))
  
  
  (method public (gradient-fill rect <Rect> stops (direction: direction 'horizontal))
    (define (create-linear-pattern sh sv eh ev)
      (cairo_pattern_create_linear (cast <fl> sh) (cast <fl> sv) (cast <fl> eh) (cast <fl> ev)))
    
    (let* ((left (get-left~ rect))
           (top (get-top~ rect))
           (right (get-right~ rect))
           (bottom (get-bottom~ rect))
           (pattern
            (case direction
              ((horizontal)
               (create-linear-pattern left (fxfloor/ (- bottom top) 2) right (fxfloor/ (- bottom top) 2)))
              ((vertical)
               (create-linear-pattern (fxfloor/ (- right left) 2) top (fxfloor/ (- right left) 2) bottom)))))
      (for-each (lambda (stop)
                  (bind (offset color) stop
                    (let ((r (/ (get-red~ color) 255))
                          (g (/ (get-green~ color) 255))
                          (b (/ (get-blue~ color) 255))
                          (a (get-alpha~ color)))
                      (if (not a)
                          (cairo_pattern_add_color_stop_rgb pattern (exact->inexact offset) (exact->inexact r) (exact->inexact g) (exact->inexact b))
                          (cairo_pattern_add_color_stop_rgba pattern (exact->inexact offset) (exact->inexact r) (exact->inexact g) (exact->inexact b) (exact->inexact a))))))
                stops)
      (rectangle-path rect)
      (cairo_set_source context pattern)
      (fill)
      (cairo_pattern_destroy pattern)))
  
   
  (method public (ellipse rect <Rect> stroke-color fill-color)
    (let* ((left (get-left~ rect))
           (top (get-top~ rect))
           (w1/2 (fl/ (- (get-right~ rect) left) 2.0))
           (h1/2 (fl/ (- (get-bottom~ rect) top) 2.0)))
      (cairo_save context)
      (cairo_translate context (+ left w1/2) (+ top h1/2))
      (cairo_scale context w1/2 h1/2)
      (cairo_arc context 0.0 0.0 1.0 0.0 (* 2 PI))
      (cairo_restore context))
    (when stroke-color
      (set-color stroke-color)
      (cairo_stroke_preserve context))
    (when fill-color
      (set-color fill-color)
      (fill)))

  
  (method public (draw-image handle x y)
    (cairo_set_source_surface context handle (cast <fl> x) (cast <fl> y))
    (cairo_paint context))
  
  
  (method public (fill-background rect background)
    (typecase background
      ((Color) (fill-rect rect background))
      ((Gradient) (fill-gradient rect background))
      ((Texture) (fill-texture rect background))
      ((List) (for-each (lambda (background)
                          (fill-background rect background))
                        background))
      (else (error "Unable to fill background with {s}" background))))
  
  
  (method public (fill-gradient rect gradient)
    (let ((parts (get-parts~ gradient)))
      (let ((stops (if (every? (lambda (part)
                                 (is? part Color))
                               parts)
                       (let ((stop 0.0)
                             (incr (fl/ 1 (- (length parts) 1))))
                         (map (lambda (color)
                                (prog1 (list stop color)
                                  (increase! stop incr)))
                              parts))
                     parts))
            (direction (get-kind~ gradient)))
        (gradient-fill rect stops direction: direction))))
  
  
  (method public (fill-texture rect texture)
    (define (texture-image)
      (let ((content (get-content~ texture)))
        (typecase content
          ((Image-Resource) (new Image resource: content))
          ((File) (and (exists?~ content) (new Image moniker: content))))))
    
    (define (draw-positioned image)
      (let ((pos (get-attribute~ texture 'position not-found: {Point 0 0}))
            (size (get-attribute~ texture 'size)))
        (define (draw image)
          (draw~ image self #f (get-h~ pos) (get-v~ pos)))
        
        (if (not size)
            (draw image)
          (with ((resized (new Image handle: (resize-image (get-handle~ image) (get-width~ size) (get-height~ size)))))
            (draw resized)))))
    
    (define (draw-centered image)
      (let ((pos (center (image-size~ image) (rect-size rect))))
        (draw~ image self #f (get-h~ pos) (get-v~ pos))))
    
    (define (draw-filled image)
      (with ((resized (new Image handle: (resize-image (get-handle~ image) (rect-width rect) (rect-height rect)))))
        (draw~ resized self #f 0 0)))
    
    (define (draw-tiled image)
      (let ((handle (get-handle~ image)))
        (cairo_set_source_surface context handle 0 0)
        (cairo_pattern_set_extend (cairo_get_source context) CAIRO_EXTEND_REPEAT)
        (cairo_rectangle context (cast <fl> (get-left~ rect)) (cast <fl> (get-top~ rect)) (cast <fl> (rect-width rect)) (cast <fl> (rect-height rect)))
        (cairo_fill context)))
    
    (let ((mode (get-mode~ texture)))
      (with ((image (texture-image)))
        (if (not image)
            (fill-rect rect {Color Red})
          (case mode
            ((position) (draw-positioned image))
            ((center) (draw-centered image))
            ((fill) (draw-filled image))
            ((tile) (draw-tiled image))
            (else (error "Unknown texture mode: {s}" mode)))))))
  
  
  ;;;
  ;;;; Surface
  ;;;
  
  
  (method public (blit-surface source <Surface> source-x source-y (dest-rect #f))
    (if dest-rect
        (begin
          (cairo_set_source_surface context (get-surface~ source)
                                    (cast <fl> (- (get-left~ dest-rect) source-x))
                                    (cast <fl> (- (get-top~ dest-rect) source-y)))
          (rectangle-path dest-rect)
          (fill))
        (begin
          (cairo_set_source_surface context (get-surface~ source) (cast <fl> source-x) (cast <fl> source-y))
          (cairo_paint context))))
  
  
  ;;;
  ;;;; Rectangles
  ;;;
  

  (method public (rectangle-path rect <Rect>)
    (rectangle-path$fl$ (rect->rect$fl$ rect)))

  
  (method protected (rectangle-path$fl$ rect <Rect$fl$>)
    (cairo_rectangle context
                     (get-left~ rect) (get-top~ rect)
                     (- (get-right~ rect) (get-left~ rect)) (- (get-bottom~ rect) (get-top~ rect))))
  

  (method public (fill-rect rect <Rect> color <Color>)
    (set-color color)
    (rectangle-path rect)
    (fill))

  
  (method public (frame-rect rect <Rect> color (line-width 1))
    (set-line-width line-width)
    (set-color color)
    (rectangle-path$fl$
      (new Rect$fl$ (+ (get-left~ rect) 0.5) (+ (get-top~ rect) 0.5) (- (get-right~ rect) 0.5) (- (get-bottom~ rect) 0.5)))
    (stroke))
  
  
  ;;;
  ;;;; Primitives
  ;;;


  (method inline (normalize-pt x) ;; cairo-specific, see http://cairographics.org/FAQ/#sharp_lines
    (unless (even? line-width)
      (+ x (if (< x 0) -0.5 0.5))))
  
  
  (method public (arc hc vc radius angle1 angle2)
    (cairo_arc context (cast <fl> hc) (cast <fl> vc) (cast <fl> radius) (cast <fl> angle1) (cast <fl> angle2)))
  
  
  (method public (move-to h v)
    (cairo_move_to context (normalize-pt h) (normalize-pt v)))
  
  
  (method public (line-to h v)
    (cairo_line_to context (normalize-pt h) (normalize-pt v)))
  
  
  (method public (line h v dest-h dest-v)
    (move-to h v)
    (line-to dest-h dest-v)
    (stroke))
  
  
  (method public (pixel-to h v)
    (set-line-width 1)
    (move-to h v)
    (line-to (+ h 1) v)
    (stroke))
  
  
  (method public (set-line-width w <fl>)
    (set! line-width w)
    (cairo_set_line_width context w))
  
  
  (method public (stroke)
    (cairo_stroke context))
  
  
  (method public (fill)
    (cairo_fill context))


  (method public (bucket-fill-surface color) ;; for debugging
    (set-color color)
    (cairo_paint context))
  
  
  (method public (set-color color <Color>)
    (let ((r (fl/ (get-red~ color) 255.0))
          (g (fl/ (get-green~ color) 255.0))
          (b (fl/ (get-blue~ color) 255.0))
          (a (get-alpha~ color)))
      (if a
          (cairo_set_source_rgba context r g b a)
          (cairo_set_source_rgb context r g b))))
  
  
  (method public (export-to-png file)
    (cairo_surface_write_to_png surface (parse~ file)))

  
  (method public (set-style style)
    (case style
      ((solid) (cairo_set_solid context))
      ((alternate) (cairo_set_alternate context))
      (else (error "Unknown style: {s}" style))))

  
  ;;;
  ;;;; Printing
  ;;;


  (method public (with-landscape rotation <symbol> page <Dimension> proc <procedure>)
    (let ((preserved landscape?))
      (unwind-protect
          (begin
            (set! landscape? #t)
            (set! landscape-rotation rotation)
            (set! landscape-page page)
            (proc))
        (set! landscape? preserved))))


  (proclaim (not warn optimizations))))
