"r4rstest"
 ({Lisp-File-Entry {File Jazz "lib" "contrib.r4rstest" "src" "r4rstest.jazz"} 1224106767
    {Lisp-Entry "r4rstest" #f 47 9 47 17 ("test-numeric-predicates" "test-bignum" "test-inexact-printing" "test-inexact" "have-bignums?" "have-inexacts?" "report-errs" "close-output-port" "check-test-file" "load-test-obj" "write-test-obj" "write-char" "test-file" "call-with-output-file" "close-input-port" "errs" "read" "cur-section" "read-char" "peek-char" "this-file" "call-with-input-file" "current-output-port" "output-port?" "current-input-port" "input-port?" "list-length" "19" "245" "37" "54" "exit" "v" "'for-each" "cadr" "h" "75" "sqt" "compose" "30" "17" "apply" "call-with-current-continuation" "'hi" "hi" "vector-set" "'vector-set" "21" "vector-ref" "vector-length" "vector" "vector?" "string-ci>=?" "string-ci<=?" "string-ci>?" "string-ci<?" "string-ci=?" "string>=?" "string<=?" "string>?" "string<?" "string-append" "substring" "string-ref" "string-length" "string" "string?" "char-upcase" "char->integer" "integer->char" "char-lower-case?" "char-upper-case?" "char-whitespace?" "char-numeric?" "char-alphabetic?" "char-ci>=?" "char-ci<=?" "char-ci>?" "char-ci<?" "char-ci=?" "char>=?" "char<=?" "char>?" "char<?" "char=?" "char?" "'string->number" "16" "number->string" "string->number" "test-string->number" "str" "lcm" "288" "-36" "32" "gcd" "-9" "-238" "238" "divtest" "-86400" "86400" "-13" "remainder" "modulo" "-35" "quotient" "-7" "'3" "330" "min" "-24" "max" "38" "positive?" "-100" "<=" "-4" ">=" "-2424" "-6246" "22" "-3" "-8" "-255" "-256" "255" "256" "expt" "inexact?" "exact?" "integer?" "rational?" "real?" "complex?" "number?" "JollyWog" "'JollyWog" "bitBlt" "'bitBlt" "'string->symbol" "mississippi" "'mississippi" "mISSISSIppi" "'mISSISSIppi" "'string-set!" "string-set!" "string->symbol" "Martin" "'Martin" "flying-fish" "'flying-fish" "string-standard-case" "standard-case" "'standard-case" "char-downcase" "char-standard-case" "A" "'A" "symbol->string" "string=?" "symbol?" "13" "11" "assv" "assoc" "'d" "assq" "100" "memv" "102" "101" "member" "list-ref" "reverse" "append" "length" "'list?" "'set-cdr!" "set-cdr!" "list?" "dot" "'dot" "equal?" "test-eq?-eqv?-agreement" "eq?" "'g" "both" "'both" "'f" "gen-counter" "p" "10000" "'10000" "eqv?" "baz" "retfoo" "77" "bar" "procedure?" "arg" "internal-define" "'internal-define" "99" "first" "add3" "56" "tprint" "'tprint" "abs" "map" "',name" ",name" "name" "quasiquote" "'quasiquote" "-1" "cons" "negative?" "neg" "nonneg" "numbers" "loop" "-2" "-5" "foo" "null?" "sum" "cdr" "25" "vector-set!" "make-vector" "vec" "do" "'do" "begin" "'begin" "34" "88" "odd?" "zero?" "n" "even?" "letrec" "'letrec" "let*" "'let*" "70" "35" "let" "'let" "'b" "memq" "or" "'or" "'c" "g" "'and" "semivowel" "'semivowel" "w" "vowel" "'vowel" "u" "o" "e" "d" "consonant" "'consonant" "9" "prime" "'prime" "case" "'case" "composite" "'composite" "else" "equal" "'equal" "less" "'less" "<" "'cond" "greater" "'greater" "'set!" "define" "'define" "-" "'1" "no" "'no" ">" "'if" "yes" "'yes" "z" "5" "6" "add4" "10" "7" "reverse-subtract" "8" "*" "if" "12" "''a" "'a" "'quote" "quote" "nil" "'nil" "t" "-3252" "c" "b" "a" "#" "'#" "car" "'car" "record-error" "9739" "list" "test" "not" "=" "and" "cond" "f" "j" "y" "0" "disjoint-type-functions" "newline" "write" "+" "set!" "i" "make-string" "display" "x" "lambda" "for-each" "4" "3" "1" "2" "SECTION" "jazz")
      {Lisp-Entry "cur-section" #f 49 8 49 19 ()}
      {Lisp-Entry "errs" #f 49 32 49 36 ()}
      {Lisp-Entry "SECTION" #f 50 8 50 15 ("cur-section" "set!" "newline" "write" "display" "args" "lambda")}
      {Lisp-Entry "record-error" #f 53 8 53 20 ("cur-section" "list" "cons" "errs" "set!" "e" "lambda")}
      {Lisp-Entry "test" #f 55 8 55 12 ("car" "apply" "procedure?" "if" "else" "list" "record-error" "equal?" "not" "cond" "newline" "res" "display" "cons" "write" "args" "fun" "expect" "lambda")}
      {Lisp-Entry "report-errs" #f 70 9 70 20 ("write" "l" "lambda" "for-each" "begin" "display" "errs" "null?" "if" "newline")}
      {Lisp-Entry "disjoint-type-functions" #f 86 8 86 31 ("vector?" "symbol?" "string?" "procedure?" "pair?" "number?" "null?" "char?" "boolean?" "list")}
      {Lisp-Entry "type-examples" #f 88 8 88 21 ("c" "b" "a" "#" "'#" "'test" "record-error" "test" "9739" "list")}
      {Lisp-Entry "i" #f 91 8 91 9 ("1")}
      {Lisp-Entry "type-matrix" #f 97 8 97 19 ("type-examples" "newline" "write" "disjoint-type-functions" "f" "t" "let" "x" "lambda" "map")}
      {Lisp-Entry "j" #f 106 8 106 9 ("0")}
      {Lisp-Entry "reverse-subtract" #f 128 8 128 24 ("-" "y" "x" "lambda")}
      {Lisp-Entry "add4" #f 131 8 131 12 ("+" "y" "lambda" "4" "x" "let")}
      {Lisp-Entry "x" #f 142 8 142 9 ("2")}
      {Lisp-Entry "x" #f 180 8 180 9 ("34")}
      {Lisp-Entry "s" #f 194 9 194 10 ("s" "set!" "let" "if" "x")}
      {Lisp-Entry "x" #f 196 8 196 9 ("0")}
      {Lisp-Entry "sqt" #f 235 9 235 12 ("-" "*" ">" "1" "+" "0" "i" "do" "x")}
      {Lisp-Entry "tprint" #f 250 9 250 15 ("x")}
      {Lisp-Entry "add3" #f 252 8 252 12 ("3" "+" "x" "lambda")}
      {Lisp-Entry "first" #f 254 8 254 13 ("car")}
      {Lisp-Entry "foo" #f 256 8 256 11 ("9" "lambda")}
      {Lisp-Entry "foo" #f 258 8 258 11 ("foo")}
      {Lisp-Entry "foo" #f 260 8 260 11 ("1" "+" "lambda" "foo" "let")}
      {Lisp-Entry "x" #f 290 8 290 9 ("34")}
      {Lisp-Entry "foo" #f 291 9 291 12 ("x")
        {Lisp-Entry "x" #f 291 22 291 23 ("5")}}
      {Lisp-Entry "foo" #f 294 8 294 11 ("5" "x" "define" "lambda")}
      {Lisp-Entry "foo" #f 297 9 297 12 ("x")}
      {Lisp-Entry "gen-counter" #f 334 8 334 19 ("1" "+" "set!" "0" "n" "let" "lambda")}
      {Lisp-Entry "test-eq?-eqv?-agreement" #f 352 8 352 31 ("newline" "write" "display" "test-eq?-eqv?-agreement" "'test-eq?-eqv?-agreement" "list" "record-error" "else" "eqv?" "eq?" "cond" "obj2" "obj1" "lambda")}
      {Lisp-Entry "x" #f 385 8 385 9 ("c" "'c" "b" "'b" "a" "'a" "list")}
      {Lisp-Entry "y" #f 386 8 386 9 ("x")}
      {Lisp-Entry "e" #f 440 8 440 9 ()}
      {Lisp-Entry "char-standard-case" #f 455 8 455 26 ("char-upcase")}
      {Lisp-Entry "str-copy" #f 463 9 463 17 ("string-ref" "string-set!" "0" "<" "1" "-" "i" "do" "string-length" "make-string" "v" "let" "s")}
      {Lisp-Entry "string-standard-case" #f 468 9 468 29 ("string-ref" "char-standard-case" "string-set!" ">=" "string-length" "sl" "1" "+" "0" "i" "do" "str-copy" "set!" "s")}
      {Lisp-Entry "x" #f 479 8 479 9 ("string")}
      {Lisp-Entry "y" #f 480 8 480 9 ("x" "string->symbol")}
      {Lisp-Entry "divtest" #f 581 9 581 16 ("remainder" "quotient" "*" "+" "=" "n2" "n1")}
      {Lisp-Entry "test-string->number" #f 599 9 599 28 ("else" "number?" "ans" "not" "cond" "str")
        {Lisp-Entry "ans" #f 600 10 600 13 ("str" "string->number")}}
      {Lisp-Entry "test-inexact" #f 613 9 613 21 ("report-errs")}
      {Lisp-Entry "test-inexact-printing" #f 706 9 706 30 ()}
      {Lisp-Entry "test-bignum" #f 789 9 789 20 ("report-errs" "number->string" "8" "zero?" "negative?" "+" "21" "cnt" "*" "pow3" "do" "exact?" "and" "n" "let" "65535" "string->number" "tb" "'remainder" "-86400" "86400" "b2-0" "b3-0" "-2" "-" "1" "-1" "b3-2" "2" "remainder" "-3" "3" "b3-3" "modulo" "0" "test" "7" "5" "6" "SECTION" "display" "newline")
        {Lisp-Entry "tb" #f 790 10 790 12 ("remainder" "quotient" "*" "+" "=" "n2" "n1" "lambda")}
        {Lisp-Entry "b3-3" #f 794 10 794 14 ("string->number")}
        {Lisp-Entry "b3-2" #f 795 10 795 14 ("string->number")}
        {Lisp-Entry "b3-0" #f 796 10 796 14 ("string->number")}
        {Lisp-Entry "b2-0" #f 797 10 797 14 ("string->number")}}
      {Lisp-Entry "test-numeric-predicates" #f 845 9 845 32 ("inexact->exact" "<" "-" "1" "+" "=" "test" "5" "6" "SECTION" "display" "newline" "exact->inexact" "big-inex" "150" "2" "expt" "big-ex" "let*")}
      {Lisp-Entry "f" #f 1004 8 1004 9 ("3" "make-string")}
      {Lisp-Entry "compose" #f 1124 8 1124 15 ("apply" "args" "g" "f" "lambda")}
      {Lisp-Entry "list-length" #f 1142 8 1142 19 ("else" "1" "cdr" "+" "pair?" "0" "null?" "cond" "r" "letrec" "return" "call-with-current-continuation" "obj" "lambda")}
      {Lisp-Entry "next-leaf-generator" #f 1160 9 1160 28 ("ret" "c" "call-with-current-continuation" "for-each" "pair?" "if" "set!" "recur" "x" "lambda" "cont" "return" "letrec" "eot" "obj")}
      {Lisp-Entry "leaf-eq?" #f 1175 9 1175 17 ("else" "eq?" "not" "cond" "lambda" "loop" "letrec" "yf" "next-leaf-generator" "xf" "'eot" "list" "eot" "let*" "y" "x")}
      {Lisp-Entry "test-cont" #f 1184 9 1184 18 ("report-errs" "d" "c" "b" "a" "leaf-eq?" "test" "9" "6" "SECTION" "display" "newline")}
      {Lisp-Entry "test-delay" #f 1194 9 1194 19 ("report-errs" "c" "'force" "10" "5" "x" ">" "if" "set!" "begin" "count" "cdr" "stream" "tail" "car" "head" "0" "cons" "n" "lambda" "next" "a-stream" "letrec" "list" "p" "let" "2" "1" "+" "force" "delay" "'delay" "3" "test" "9" "6" "SECTION" "display" "newline")}
      {Lisp-Entry "this-file" #f 1228 8 1228 17 ("open-input-file")}
      {Lisp-Entry "check-test-file" #f 1238 9 1238 24 ("close-input-port" "write-test-obj" "read-char" "peek-char" "eof-object?" "read" "load-test-obj" "test-file" "lambda" "call-with-input-file" "input-port?" "'input-port?" "test" "name")
        {Lisp-Entry "test-file" #f 1239 10 1239 19 ("name" "open-input-file")}}
      {Lisp-Entry "write-test-obj" #f 1255 8 1255 22 ()}
      {Lisp-Entry "load-test-obj" #f 1257 8 1257 21 ("write-test-obj" "quote" "'quote" "foo" "'foo" "define" "'define" "list")}
      {Lisp-Entry "test-file" #f 1271 8 1271 17 ("open-output-file")}
      {Lisp-Entry "test-sc4" #f 1281 9 1281 17 ("report-errs" "foo" "'load" "write-test-obj" "load" "4" "10" "list->vector" "dididit" "#" "'#" "vector->list" "didah" "dah" "8" "list->string" "string->list" "test" "7" "6" "SECTION" "display" "newline")}}})
