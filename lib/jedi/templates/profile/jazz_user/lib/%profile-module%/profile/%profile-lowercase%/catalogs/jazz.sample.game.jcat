"_game"
 ({Lisp-File-Entry {File Jazz "lib" "jazz.sample.game" "src" "jazz" "sample" "game" "_game.jazz"} 1236190769
    {Lisp-Entry "jazz.sample.game" library #f 38 9 38 25 ("jazz")
      {Lisp-Entry "Player" class #f 49 7 49 13 ("Object")
        {Lisp-Entry "player-kind" method #f 52 29 52 40 ()}
        {Lisp-Entry "human?" method #f 56 29 56 35 ("human" "'human" "player-kind" "eq?")}
        {Lisp-Entry "computer?" method #f 60 29 60 38 ("computer" "'computer" "player-kind" "eq?")}
        {Lisp-Entry "computer-move" method #f 64 29 64 42 ()}
        {Lisp-Entry "move-played" method #f 69 29 69 40 ("token" "move")}}
      {Lisp-Entry "Game" class #f 78 7 78 11 ("initialize" "Object")
        {Lisp-Entry "players" slot #f 82 8 82 15 ()}
        {Lisp-Entry "get-players" accessor #f 82 49 82 57 ()}
        {Lisp-Entry "set-players" accessor #f 82 49 82 57 ()}
        {Lisp-Entry "next-player-rank" slot #f 83 8 83 24 ()}
        {Lisp-Entry "get-next-player-rank" accessor #f 83 49 83 57 ()}
        {Lisp-Entry "set-next-player-rank" accessor #f 83 49 83 57 ()}
        {Lisp-Entry "history-manager" slot #f 86 8 86 23 ()}
        {Lisp-Entry "status" slot #f 89 8 89 14 ()}
        {Lisp-Entry "get-status" accessor #f 89 49 89 57 ()}
        {Lisp-Entry "set-status" accessor #f 89 49 89 57 ()}
        {Lisp-Entry "winner" slot #f 90 8 90 14 ()}
        {Lisp-Entry "get-winner" accessor #f 90 49 90 57 ()}
        {Lisp-Entry "set-winner" accessor #f 90 49 90 57 ()}
        {Lisp-Entry "initialize" method #f 98 11 98 21 ("winner" "play" "'play" "status" "self" "History-Manager" "new" "history-manager" "0" "next-player-rank" "set!" "nextmethod")}
        {Lisp-Entry "register-players" method #f 111 18 111 34 ("list->vector" "players" "set!" "lst")}
        {Lisp-Entry "get-next-player" method #f 115 18 115 33 ("next-player-rank" "players" "vector-ref")}
        {Lisp-Entry "get-second-player" method #f 119 18 119 35 ("1" "next-player-rank" "+" "modulo-players" "players" "vector-ref")}
        {Lisp-Entry "next-player!" method #f 123 21 123 33 ("1" "+" "modulo-players" "next-player-rank" "set!" "get-next-player" "prog1")}
        {Lisp-Entry "modulo-players" method #f 128 11 128 25 ("players" "vector-length" "modulo" "rank")}
        {Lisp-Entry "add-move" method #f 137 21 137 29 ("History-Move" "new" "history-manager" "add-history" "move")}
        {Lisp-Entry "append-forward-history" method #f 141 21 141 43 ("History-Move" "new" "history-manager" "append-forward-history" "move")}
        {Lisp-Entry "get-moves" method #f 145 18 145 27 ("get-forward-moves" "get-backward-moves" "append")}
        {Lisp-Entry "get-backward-moves" method #f 150 18 150 36 ("history-manager" "get-backward-history" "reverse" "get-move" "history-move" "function" "map")}
        {Lisp-Entry "get-forward-moves" method #f 156 18 156 35 ("history-manager" "get-forward-history" "get-move" "history-move" "function" "map")}
        {Lisp-Entry "play" method #f 167 29 167 33 ("move")}
        {Lisp-Entry "unplay" method #f 171 29 171 35 ("move")}
        {Lisp-Entry "play-move" method #f 180 26 180 35 ("move")}
        {Lisp-Entry "inform-players" method #f 184 11 184 25 ("vector-ref" "move-played" "players" "vector-length" "below" "0" "from" "n" "for" "loop" "token" "move")}
        {Lisp-Entry "check-status" method #f 189 29 189 41 ("draw" "'draw" "draw?" "winner" "win" "'win" "status" "set!" "win?" "cond" "token" "move" "player")}
        {Lisp-Entry "win?" method #f 197 29 197 33 ("token" "move")}
        {Lisp-Entry "draw?" method #f 201 29 201 34 ("token" "move")}
        {Lisp-Entry "save" method #f 210 26 210 30 ()}
        {Lisp-Entry "load" method #f 214 26 214 30 ()}
        {Lisp-Entry "inspect" method #f 223 26 223 33 ()}}
      {Lisp-Entry "History-Move" class #f 232 7 232 19 ("History-Item")
        {Lisp-Entry "move" slot #f 235 8 235 12 ()}
        {Lisp-Entry "get-move" accessor #f 235 20 235 28 ()}
        {Lisp-Entry "initialize" method #f 238 11 238 21 ("move~self" "set!" "nextmethod" "move")}
        {Lisp-Entry "print" method #f 243 11 243 16 ("move" "format" "function" "self" "print-unreadable" "readably" "printer")}}}})
"minimax"
 ({Lisp-File-Entry {File Jazz "lib" "jazz.sample.game" "src" "jazz" "sample" "game" "minimax.jazz"} 1248797036
    {Lisp-Entry "jazz.sample.game.minimax" library #f 37 9 37 33 ("jazz")
      {Lisp-Entry "Minimax-Statistics" class #f 51 7 51 25 ("0" "initialize" "Object")
        {Lisp-Entry "last-eval" slot #f 54 8 54 17 ()}
        {Lisp-Entry "get-last-eval" accessor #f 54 60 54 68 ()}
        {Lisp-Entry "set-last-eval" accessor #f 54 60 54 68 ()}
        {Lisp-Entry "last-evaluations" slot #f 55 8 55 24 ()}
        {Lisp-Entry "get-last-evaluations" accessor #f 55 60 55 68 ()}
        {Lisp-Entry "set-last-evaluations" accessor #f 55 60 55 68 ()}
        {Lisp-Entry "last-evaluations-count" slot #f 56 8 56 30 ()}
        {Lisp-Entry "get-last-evaluations-count" accessor #f 56 60 56 68 ()}
        {Lisp-Entry "set-last-evaluations-count" accessor #f 56 60 56 68 ()}
        {Lisp-Entry "last-time" slot #f 57 8 57 17 ()}
        {Lisp-Entry "get-last-time" accessor #f 57 60 57 68 ()}
        {Lisp-Entry "set-last-time" accessor #f 57 60 57 68 ()}
        {Lisp-Entry "increase-last-evaluations-count" method #f 60 11 60 42 ("last-evaluations-count" "increase!")}}
      {Lisp-Entry "Default-Search-Depth" definition #f 69 12 69 32 ("4")}
      {Lisp-Entry "minimax" definition #f 73 20 73 27 ("cast" "normalized-eval" "-1" "10000000" "evaluate-best" "evaluate" "900000" "*" "error" "/=" "when" "position-eval" "new-eval" "delta" "increase-last-evaluations-count" "depth" "min" "cdr" "key:" "sort" "subseq" "car" "map" "+" "nb" "all" "max-candidates" "iterate-moves" "token" "random-element" "reverse" "set-last-evaluations" "set-last-eval" "list" "not" "or" "and" "cond" "cons" "set!" "evaluate-move" "eval" "move" "function" "gather-candidates" "evals" "<" ">" "1" "=" "if" "best-test" "best-eval" "best" "best-move" "define" "Minimax-Statistics" "new" "statistics" "let" "Default-Search-Depth" "search-depth" "search-depth:" "0" "current-eval" "current-eval:" "evaluate-move-delta" "evaluate-position" "unplay" "play" "iterate-candidates" "me")}
      {Lisp-Entry "minimax-interpreted-message" definition #f 160 13 160 40 ("format" "title")}
      {Lisp-Entry "minimax-interpreted?" definition #f 164 20 164 40 ("jazz.sample.game.minimax" "'jazz.sample.game.minimax" "module-uptodate-binary?" "not" "or" "ai-module")}
      {Lisp-Entry "minimax-interpreted-warner" definition #f 169 20 169 46 ("set!" "format" "system-message" "minimax-interpreted?" "not" "and" "when" "lambda" "warned?" "let" "title" "ai-module")}
      {Lisp-Entry "warn-minimax-interpreted" definition #f 177 20 177 44 ("minimax-interpreted-warner" "title" "ai-module")}}})
