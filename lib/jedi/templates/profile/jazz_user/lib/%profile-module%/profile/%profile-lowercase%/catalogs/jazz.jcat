"Core-Project"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "project" "jazz" "Core-Project.jazz"} 1251404157
    {Lisp-Entry "project.jazz.Core-Project" library #f 37 9 37 34 ("Core-Project" "register-autoclass" "jazz")
      {Lisp-Entry "Core-Project" class #f 44 7 44 19 ("project.jazz.Core-Project" "module-name:" "core" "product:" "title:" "Jazz-Project")}}})
"Dialect-Project"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "project" "jazz" "Dialect-Project.jazz"} 1251404157
    {Lisp-Entry "project.jazz.Dialect-Project" library #f 37 9 37 37 ("Dialect-Project" "register-autoclass" "jazz")
      {Lisp-Entry "Dialect-Project" class #f 44 7 44 22 ("project.jazz.Dialect-Project" "module-name:" "jazz" "product:" "title:" "Jazz-Project")}}})
"Jazz-Manifest"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "project" "jazz" "Jazz-Manifest.jazz"} 1252768922
    {Lisp-Entry "project.jazz.Jazz-Manifest" library #f 37 9 37 35 ("Jazz-Manifest" "register-autoclass" "jazz")
      {Lisp-Entry "Jazz-Manifest" class #f 45 7 45 20 ("Test-Project" "Platform-Project" "Jazz-Manifest" "Dialect-Project" "Core-Project" "development" "literals" "c" "Y" "X" "cffi" "b" "autoload" "a" "_test" "_walker" "scheme" "core" "homogeneous" "functional" "parse" "object" "geometry" "format" "exception" "debug" "_language" "name:" "jazz" "source:" "Directory" "directory:" "project.jazz.Test-Project" "project.jazz.Platform-Project" "project.jazz.Dialect-Project" "project.jazz.Core-Project" "tag-module:" "project.jazz.Jazz-Manifest" "module-name:" "Jazz" "File" "documentation:" "include-extensions:" ":jazz" "catalog-extensions:" "catalog?:" "title:" "Project")}}})
"Platform-Project"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "project" "jazz" "Platform-Project.jazz"} 1251404157
    {Lisp-Entry "project.jazz.Platform-Project" library #f 37 9 37 38 ("Platform-Project" "register-autoclass" "jazz")
      {Lisp-Entry "Platform-Project" class #f 44 7 44 23 ("project.jazz.Platform-Project" "module-name:" "jazz.platform" "product:" "title:" "Jazz-Project")}}})
"Test-Project"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "project" "jazz" "Test-Project.jazz"} 1251404157
    {Lisp-Entry "project.jazz.Test-Project" library #f 37 9 37 34 ("Test-Project" "register-autoclass" "jazz")
      {Lisp-Entry "Test-Project" class #f 44 7 44 19 ("project.jazz.Test-Project" "module-name:" "jazz.test" "product:" "title:" "Jazz-Project")}}})
"X"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "test" "X.jazz"} 1237033585
    {Lisp-Entry "jazz.test.X" library #f 0 9 0 20 ("jazz")
      {Lisp-Entry "X" class #f 3 7 3 8 ("Object")
        {Lisp-Entry "foo" method #f 6 19 6 22 ("X.foo" "'X.foo" "terminal")}}}})
"Y"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "test" "Y.jazz"} 1237033585
    {Lisp-Entry "jazz.test.Y" library #f 0 9 0 20 ("jazz")
      {Lisp-Entry "Y" class #f 6 7 6 8 ("Object")
        {Lisp-Entry "foo" method #f 9 11 9 14 ("Y.foo" "'Y.foo" "terminal")}}}})
"_core"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "dialect" "core" "_core.scm"} 1250347032
    {Lisp-Entry "jazz.dialect.core" library #f 37 19 37 36 ("scheme")}})
"_dialect"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "dialect" "_dialect.scm"} 1251542592
    {Lisp-Entry "jazz.dialect" library #f 37 19 37 31 ("scheme")}})
"_jazz"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "_jazz.scm"} 1248708411
    {Lisp-Entry "jazz" library #f 37 9 37 13 ("scheme")}})
"_kernel"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "dialect" "kernel" "_kernel.scm"} 1253311789
    {Lisp-Entry "jazz.dialect.kernel" library #f 38 19 38 38 ("scheme")
      {Lisp-Entry "get-autoload" native #f 46 8 46 25 ()}
      {Lisp-Entry "autoload" native #f 47 8 47 21 ()}
      {Lisp-Entry "autoreload" native #f 48 8 48 23 ()}
      {Lisp-Entry "boolean" native #f 56 8 56 20 ()}
      {Lisp-Entry "box?" native #f 64 8 64 12 ()}
      {Lisp-Entry "box" native #f 65 8 65 11 ()}
      {Lisp-Entry "unbox" native #f 66 8 66 13 ()}
      {Lisp-Entry "set-box!" native #f 67 8 67 16 ()}
      {Lisp-Entry "compile-module" native #f 75 8 75 27 ()}
      {Lisp-Entry "build-module" native #f 76 8 76 25 ()}
      {Lisp-Entry "build-image" native #f 77 8 77 24 ()}
      {Lisp-Entry "for-each-submodule" native #f 78 8 78 31 ()}
      {Lisp-Entry "get-category-name" native #f 86 8 86 30 ()}
      {Lisp-Entry "get-category-descendants" native #f 87 8 87 37 ()}
      {Lisp-Entry "get-class-ascendant" native #f 88 8 88 32 ()}
      {Lisp-Entry "symbolic-char" native #f 96 8 96 26 ()}
      {Lisp-Entry "char-symbol" native #f 97 8 97 24 ()}
      {Lisp-Entry "continuation?" native #f 105 8 105 26 ()}
      {Lisp-Entry "continuation-capture" native #f 106 8 106 33 ()}
      {Lisp-Entry "continuation-graft" native #f 107 8 107 31 ()}
      {Lisp-Entry "continuation-return" native #f 108 8 108 32 ()}
      {Lisp-Entry "run-loop?" native #f 116 8 116 22 ()}
      {Lisp-Entry "terminal" native #f 117 8 117 21 ()}
      {Lisp-Entry "terminal-string" native #f 118 8 118 28 ()}
      {Lisp-Entry "terminal-port" native #f 119 8 119 26 ()}
      {Lisp-Entry "unimplemented" native #f 120 8 120 26 ()}
      {Lisp-Entry "dump-stack" native #f 121 8 121 23 ()}
      {Lisp-Entry "log-object" native #f 122 8 122 23 ()}
      {Lisp-Entry "log-string" native #f 123 8 123 23 ()}
      {Lisp-Entry "log-newline" native #f 124 8 124 24 ()}
      {Lisp-Entry "close-log" native #f 125 8 125 22 ()}
      {Lisp-Entry "inspect-object" native #f 126 8 126 27 ()}
      {Lisp-Entry "generate-proper-tail-calls" native #f 127 8 127 34 ()}
      {Lisp-Entry "?" native #f 139 8 139 9 ()}
      {Lisp-Entry "get-?" native #f 139 19 139 24 ()}
      {Lisp-Entry "set-?" native #f 139 34 139 39 ()}
      {Lisp-Entry "%" native #f 140 8 140 9 ()}
      {Lisp-Entry "get-%" native #f 140 19 140 24 ()}
      {Lisp-Entry "set-%" native #f 140 34 140 39 ()}
      {Lisp-Entry "?a" native #f 143 8 143 10 ()}
      {Lisp-Entry "get-?a" native #f 143 20 143 26 ()}
      {Lisp-Entry "set-?a" native #f 143 36 143 42 ()}
      {Lisp-Entry "?b" native #f 144 8 144 10 ()}
      {Lisp-Entry "get-?b" native #f 144 20 144 26 ()}
      {Lisp-Entry "set-?b" native #f 144 36 144 42 ()}
      {Lisp-Entry "?c" native #f 145 8 145 10 ()}
      {Lisp-Entry "get-?c" native #f 145 20 145 26 ()}
      {Lisp-Entry "set-?c" native #f 145 36 145 42 ()}
      {Lisp-Entry "?d" native #f 146 8 146 10 ()}
      {Lisp-Entry "get-?d" native #f 146 20 146 26 ()}
      {Lisp-Entry "set-?d" native #f 146 36 146 42 ()}
      {Lisp-Entry "?e" native #f 147 8 147 10 ()}
      {Lisp-Entry "get-?e" native #f 147 20 147 26 ()}
      {Lisp-Entry "set-?e" native #f 147 36 147 42 ()}
      {Lisp-Entry "?f" native #f 148 8 148 10 ()}
      {Lisp-Entry "get-?f" native #f 148 20 148 26 ()}
      {Lisp-Entry "set-?f" native #f 148 36 148 42 ()}
      {Lisp-Entry "?g" native #f 149 8 149 10 ()}
      {Lisp-Entry "get-?g" native #f 149 20 149 26 ()}
      {Lisp-Entry "set-?g" native #f 149 36 149 42 ()}
      {Lisp-Entry "?h" native #f 150 8 150 10 ()}
      {Lisp-Entry "get-?h" native #f 150 20 150 26 ()}
      {Lisp-Entry "set-?h" native #f 150 36 150 42 ()}
      {Lisp-Entry "?i" native #f 151 8 151 10 ()}
      {Lisp-Entry "get-?i" native #f 151 20 151 26 ()}
      {Lisp-Entry "set-?i" native #f 151 36 151 42 ()}
      {Lisp-Entry "?j" native #f 152 8 152 10 ()}
      {Lisp-Entry "get-?j" native #f 152 20 152 26 ()}
      {Lisp-Entry "set-?j" native #f 152 36 152 42 ()}
      {Lisp-Entry "?k" native #f 153 8 153 10 ()}
      {Lisp-Entry "get-?k" native #f 153 20 153 26 ()}
      {Lisp-Entry "set-?k" native #f 153 36 153 42 ()}
      {Lisp-Entry "?l" native #f 154 8 154 10 ()}
      {Lisp-Entry "get-?l" native #f 154 20 154 26 ()}
      {Lisp-Entry "set-?l" native #f 154 36 154 42 ()}
      {Lisp-Entry "?m" native #f 155 8 155 10 ()}
      {Lisp-Entry "get-?m" native #f 155 20 155 26 ()}
      {Lisp-Entry "set-?m" native #f 155 36 155 42 ()}
      {Lisp-Entry "?n" native #f 156 8 156 10 ()}
      {Lisp-Entry "get-?n" native #f 156 20 156 26 ()}
      {Lisp-Entry "set-?n" native #f 156 36 156 42 ()}
      {Lisp-Entry "?o" native #f 157 8 157 10 ()}
      {Lisp-Entry "get-?o" native #f 157 20 157 26 ()}
      {Lisp-Entry "set-?o" native #f 157 36 157 42 ()}
      {Lisp-Entry "?p" native #f 158 8 158 10 ()}
      {Lisp-Entry "get-?p" native #f 158 20 158 26 ()}
      {Lisp-Entry "set-?p" native #f 158 36 158 42 ()}
      {Lisp-Entry "?q" native #f 159 8 159 10 ()}
      {Lisp-Entry "get-?q" native #f 159 20 159 26 ()}
      {Lisp-Entry "set-?q" native #f 159 36 159 42 ()}
      {Lisp-Entry "?r" native #f 160 8 160 10 ()}
      {Lisp-Entry "get-?r" native #f 160 20 160 26 ()}
      {Lisp-Entry "set-?r" native #f 160 36 160 42 ()}
      {Lisp-Entry "?s" native #f 161 8 161 10 ()}
      {Lisp-Entry "get-?s" native #f 161 20 161 26 ()}
      {Lisp-Entry "set-?s" native #f 161 36 161 42 ()}
      {Lisp-Entry "?t" native #f 162 8 162 10 ()}
      {Lisp-Entry "get-?t" native #f 162 20 162 26 ()}
      {Lisp-Entry "set-?t" native #f 162 36 162 42 ()}
      {Lisp-Entry "?u" native #f 163 8 163 10 ()}
      {Lisp-Entry "get-?u" native #f 163 20 163 26 ()}
      {Lisp-Entry "set-?u" native #f 163 36 163 42 ()}
      {Lisp-Entry "?v" native #f 164 8 164 10 ()}
      {Lisp-Entry "get-?v" native #f 164 20 164 26 ()}
      {Lisp-Entry "set-?v" native #f 164 36 164 42 ()}
      {Lisp-Entry "?w" native #f 165 8 165 10 ()}
      {Lisp-Entry "get-?w" native #f 165 20 165 26 ()}
      {Lisp-Entry "set-?w" native #f 165 36 165 42 ()}
      {Lisp-Entry "?x" native #f 166 8 166 10 ()}
      {Lisp-Entry "get-?x" native #f 166 20 166 26 ()}
      {Lisp-Entry "set-?x" native #f 166 36 166 42 ()}
      {Lisp-Entry "?y" native #f 167 8 167 10 ()}
      {Lisp-Entry "get-?y" native #f 167 20 167 26 ()}
      {Lisp-Entry "set-?y" native #f 167 36 167 42 ()}
      {Lisp-Entry "?z" native #f 168 8 168 10 ()}
      {Lisp-Entry "get-?z" native #f 168 20 168 26 ()}
      {Lisp-Entry "set-?z" native #f 168 36 168 42 ()}
      {Lisp-Entry "%a" native #f 171 8 171 10 ()}
      {Lisp-Entry "get-%a" native #f 171 20 171 26 ()}
      {Lisp-Entry "set-%a" native #f 171 36 171 42 ()}
      {Lisp-Entry "%b" native #f 172 8 172 10 ()}
      {Lisp-Entry "get-%b" native #f 172 20 172 26 ()}
      {Lisp-Entry "set-%b" native #f 172 36 172 42 ()}
      {Lisp-Entry "%c" native #f 173 8 173 10 ()}
      {Lisp-Entry "get-%c" native #f 173 20 173 26 ()}
      {Lisp-Entry "set-%c" native #f 173 36 173 42 ()}
      {Lisp-Entry "%d" native #f 174 8 174 10 ()}
      {Lisp-Entry "get-%d" native #f 174 20 174 26 ()}
      {Lisp-Entry "set-%d" native #f 174 36 174 42 ()}
      {Lisp-Entry "%e" native #f 175 8 175 10 ()}
      {Lisp-Entry "get-%e" native #f 175 20 175 26 ()}
      {Lisp-Entry "set-%e" native #f 175 36 175 42 ()}
      {Lisp-Entry "%f" native #f 176 8 176 10 ()}
      {Lisp-Entry "get-%f" native #f 176 20 176 26 ()}
      {Lisp-Entry "set-%f" native #f 176 36 176 42 ()}
      {Lisp-Entry "%g" native #f 177 8 177 10 ()}
      {Lisp-Entry "get-%g" native #f 177 20 177 26 ()}
      {Lisp-Entry "set-%g" native #f 177 36 177 42 ()}
      {Lisp-Entry "%h" native #f 178 8 178 10 ()}
      {Lisp-Entry "get-%h" native #f 178 20 178 26 ()}
      {Lisp-Entry "set-%h" native #f 178 36 178 42 ()}
      {Lisp-Entry "%i" native #f 179 8 179 10 ()}
      {Lisp-Entry "get-%i" native #f 179 20 179 26 ()}
      {Lisp-Entry "set-%i" native #f 179 36 179 42 ()}
      {Lisp-Entry "%j" native #f 180 8 180 10 ()}
      {Lisp-Entry "get-%j" native #f 180 20 180 26 ()}
      {Lisp-Entry "set-%j" native #f 180 36 180 42 ()}
      {Lisp-Entry "%k" native #f 181 8 181 10 ()}
      {Lisp-Entry "get-%k" native #f 181 20 181 26 ()}
      {Lisp-Entry "set-%k" native #f 181 36 181 42 ()}
      {Lisp-Entry "%l" native #f 182 8 182 10 ()}
      {Lisp-Entry "get-%l" native #f 182 20 182 26 ()}
      {Lisp-Entry "set-%l" native #f 182 36 182 42 ()}
      {Lisp-Entry "%m" native #f 183 8 183 10 ()}
      {Lisp-Entry "get-%m" native #f 183 20 183 26 ()}
      {Lisp-Entry "set-%m" native #f 183 36 183 42 ()}
      {Lisp-Entry "%n" native #f 184 8 184 10 ()}
      {Lisp-Entry "get-%n" native #f 184 20 184 26 ()}
      {Lisp-Entry "set-%n" native #f 184 36 184 42 ()}
      {Lisp-Entry "%o" native #f 185 8 185 10 ()}
      {Lisp-Entry "get-%o" native #f 185 20 185 26 ()}
      {Lisp-Entry "set-%o" native #f 185 36 185 42 ()}
      {Lisp-Entry "%p" native #f 186 8 186 10 ()}
      {Lisp-Entry "get-%p" native #f 186 20 186 26 ()}
      {Lisp-Entry "set-%p" native #f 186 36 186 42 ()}
      {Lisp-Entry "%q" native #f 187 8 187 10 ()}
      {Lisp-Entry "get-%q" native #f 187 20 187 26 ()}
      {Lisp-Entry "set-%q" native #f 187 36 187 42 ()}
      {Lisp-Entry "%r" native #f 188 8 188 10 ()}
      {Lisp-Entry "get-%r" native #f 188 20 188 26 ()}
      {Lisp-Entry "set-%r" native #f 188 36 188 42 ()}
      {Lisp-Entry "%s" native #f 189 8 189 10 ()}
      {Lisp-Entry "get-%s" native #f 189 20 189 26 ()}
      {Lisp-Entry "set-%s" native #f 189 36 189 42 ()}
      {Lisp-Entry "%t" native #f 190 8 190 10 ()}
      {Lisp-Entry "get-%t" native #f 190 20 190 26 ()}
      {Lisp-Entry "set-%t" native #f 190 36 190 42 ()}
      {Lisp-Entry "%u" native #f 191 8 191 10 ()}
      {Lisp-Entry "get-%u" native #f 191 20 191 26 ()}
      {Lisp-Entry "set-%u" native #f 191 36 191 42 ()}
      {Lisp-Entry "%v" native #f 192 8 192 10 ()}
      {Lisp-Entry "get-%v" native #f 192 20 192 26 ()}
      {Lisp-Entry "set-%v" native #f 192 36 192 42 ()}
      {Lisp-Entry "%w" native #f 193 8 193 10 ()}
      {Lisp-Entry "get-%w" native #f 193 20 193 26 ()}
      {Lisp-Entry "set-%w" native #f 193 36 193 42 ()}
      {Lisp-Entry "%x" native #f 194 8 194 10 ()}
      {Lisp-Entry "get-%x" native #f 194 20 194 26 ()}
      {Lisp-Entry "set-%x" native #f 194 36 194 42 ()}
      {Lisp-Entry "%y" native #f 195 8 195 10 ()}
      {Lisp-Entry "get-%y" native #f 195 20 195 26 ()}
      {Lisp-Entry "set-%y" native #f 195 36 195 42 ()}
      {Lisp-Entry "%z" native #f 196 8 196 10 ()}
      {Lisp-Entry "get-%z" native #f 196 20 196 26 ()}
      {Lisp-Entry "set-%z" native #f 196 36 196 42 ()}
      {Lisp-Entry "open-digest" native #f 204 8 204 19 ()}
      {Lisp-Entry "close-digest" native #f 205 8 205 20 ()}
      {Lisp-Entry "digest-update-subu8vector" native #f 206 8 206 33 ()}
      {Lisp-Entry "digest-string" native #f 207 8 207 21 ()}
      {Lisp-Entry "digest-substring" native #f 208 8 208 24 ()}
      {Lisp-Entry "digest-u8vector" native #f 209 8 209 23 ()}
      {Lisp-Entry "digest-subu8vector" native #f 210 8 210 26 ()}
      {Lisp-Entry "digest-file" native #f 211 8 211 19 ()}
      {Lisp-Entry "enumerator?" native #f 219 8 219 24 ()}
      {Lisp-Entry "enumerator->symbol" native #f 220 8 220 31 ()}
      {Lisp-Entry "exception-reason" native #f 228 8 228 29 ()}
      {Lisp-Entry "exception-detail" native #f 229 8 229 29 ()}
      {Lisp-Entry "display-exception" native #f 230 8 230 30 ()}
      {Lisp-Entry "display-continuation-backtrace" native #f 231 8 231 43 ()}
      {Lisp-Entry "get-exception-hook" native #f 232 8 232 31 ()}
      {Lisp-Entry "set-exception-hook" native #f 233 8 233 31 ()}
      {Lisp-Entry "invoke-exception-hook" native #f 234 8 234 34 ()}
      {Lisp-Entry "system-exception-hook" native #f 235 8 235 34 ()}
      {Lisp-Entry "current-exception-handler" native #f 236 8 236 38 ()}
      {Lisp-Entry "with-exception-handler" native #f 237 8 237 35 ()}
      {Lisp-Entry "with-exception-catcher" native #f 238 8 238 35 ()}
      {Lisp-Entry "with-exception-filter" native #f 239 8 239 34 ()}
      {Lisp-Entry "with-exception-propagater" native #f 240 8 240 38 ()}
      {Lisp-Entry "dump-exception" native #f 241 8 241 27 ()}
      {Lisp-Entry "raise" native #f 242 8 242 18 ()}
      {Lisp-Entry "field?" native #f 250 8 250 19 ()}
      {Lisp-Entry "field-name" native #f 251 8 251 23 ()}
      {Lisp-Entry "find-field" native #f 252 8 252 23 ()}
      {Lisp-Entry "fixnum?" native #f 260 8 260 15 ()}
      {Lisp-Entry "flonum?" native #f 261 8 261 15 ()}
      {Lisp-Entry "fixnum->flonum" native #f 262 8 262 27 ()}
      {Lisp-Entry "flonum->fixnum" native #f 263 8 263 27 ()}
      {Lisp-Entry "fx+" native #f 264 8 264 11 ()}
      {Lisp-Entry "fx-" native #f 265 8 265 11 ()}
      {Lisp-Entry "fx*" native #f 266 8 266 11 ()}
      {Lisp-Entry "+infinity" native #f 267 8 267 22 ()}
      {Lisp-Entry "-infinity" native #f 268 8 268 22 ()}
      {Lisp-Entry "undocumented" native #f 278 8 278 20 ("##fl+")}
      {Lisp-Entry "undocumented" native #f 279 8 279 20 ("##fl-")}
      {Lisp-Entry "undocumented" native #f 280 8 280 20 ("##fl*")}
      {Lisp-Entry "undocumented" native #f 281 8 281 20 ("##fl/")}
      {Lisp-Entry "foreign?" native #f 289 8 289 21 ()}
      {Lisp-Entry "foreign-address" native #f 290 8 290 28 ()}
      {Lisp-Entry "foreign-release!" native #f 291 8 291 29 ()}
      {Lisp-Entry "foreign-released?" native #f 292 8 292 30 ()}
      {Lisp-Entry "foreign-tags" native #f 293 8 293 25 ()}
      {Lisp-Entry "still-obj-refcount-dec!" native #f 295 8 295 36 ()}
      {Lisp-Entry "still-obj-refcount-inc!" native #f 296 8 296 36 ()}
      {Lisp-Entry "compile-file" native #f 304 8 304 20 ()}
      {Lisp-Entry "datum-parsing-exception?" native #f 305 8 305 32 ()}
      {Lisp-Entry "s8vector" native #f 314 8 314 16 ()}
      {Lisp-Entry "make-s8vector" native #f 315 8 315 21 ()}
      {Lisp-Entry "s8vector-length" native #f 316 8 316 23 ()}
      {Lisp-Entry "s8vector-ref" native #f 317 8 317 20 ()}
      {Lisp-Entry "s8vector-set!" native #f 318 8 318 21 ()}
      {Lisp-Entry "s8vector?" native #f 319 8 319 17 ()}
      {Lisp-Entry "s8vector->list" native #f 320 8 320 22 ()}
      {Lisp-Entry "list->s8vector" native #f 321 8 321 22 ()}
      {Lisp-Entry "u8vector" native #f 324 8 324 16 ()}
      {Lisp-Entry "make-u8vector" native #f 325 8 325 21 ()}
      {Lisp-Entry "u8vector-length" native #f 326 8 326 23 ()}
      {Lisp-Entry "u8vector-ref" native #f 327 8 327 20 ()}
      {Lisp-Entry "u8vector-set!" native #f 328 8 328 21 ()}
      {Lisp-Entry "u8vector?" native #f 329 8 329 17 ()}
      {Lisp-Entry "u8vector->list" native #f 330 8 330 22 ()}
      {Lisp-Entry "list->u8vector" native #f 331 8 331 22 ()}
      {Lisp-Entry "u8vector->object" native #f 332 8 332 24 ()}
      {Lisp-Entry "object->u8vector" native #f 333 8 333 24 ()}
      {Lisp-Entry "s16vector" native #f 336 8 336 17 ()}
      {Lisp-Entry "make-s16vector" native #f 337 8 337 22 ()}
      {Lisp-Entry "s16vector-length" native #f 338 8 338 24 ()}
      {Lisp-Entry "s16vector-ref" native #f 339 8 339 21 ()}
      {Lisp-Entry "s16vector-set!" native #f 340 8 340 22 ()}
      {Lisp-Entry "s16vector?" native #f 341 8 341 18 ()}
      {Lisp-Entry "s16vector->list" native #f 342 8 342 23 ()}
      {Lisp-Entry "list->s16vector" native #f 343 8 343 23 ()}
      {Lisp-Entry "u16vector" native #f 346 8 346 17 ()}
      {Lisp-Entry "make-u16vector" native #f 347 8 347 22 ()}
      {Lisp-Entry "u16vector-length" native #f 348 8 348 24 ()}
      {Lisp-Entry "u16vector-ref" native #f 349 8 349 21 ()}
      {Lisp-Entry "u16vector-set!" native #f 350 8 350 22 ()}
      {Lisp-Entry "u16vector?" native #f 351 8 351 18 ()}
      {Lisp-Entry "u16vector->list" native #f 352 8 352 23 ()}
      {Lisp-Entry "list->u16vector" native #f 353 8 353 23 ()}
      {Lisp-Entry "s32vector" native #f 356 8 356 17 ()}
      {Lisp-Entry "make-s32vector" native #f 357 8 357 22 ()}
      {Lisp-Entry "s32vector-length" native #f 358 8 358 24 ()}
      {Lisp-Entry "s32vector-ref" native #f 359 8 359 21 ()}
      {Lisp-Entry "s32vector-set!" native #f 360 8 360 22 ()}
      {Lisp-Entry "s32vector?" native #f 361 8 361 18 ()}
      {Lisp-Entry "s32vector->list" native #f 362 8 362 23 ()}
      {Lisp-Entry "list->s32vector" native #f 363 8 363 23 ()}
      {Lisp-Entry "u32vector" native #f 366 8 366 17 ()}
      {Lisp-Entry "make-u32vector" native #f 367 8 367 22 ()}
      {Lisp-Entry "u32vector-length" native #f 368 8 368 24 ()}
      {Lisp-Entry "u32vector-ref" native #f 369 8 369 21 ()}
      {Lisp-Entry "u32vector-set!" native #f 370 8 370 22 ()}
      {Lisp-Entry "u32vector?" native #f 371 8 371 18 ()}
      {Lisp-Entry "u32vector->list" native #f 372 8 372 23 ()}
      {Lisp-Entry "list->u32vector" native #f 373 8 373 23 ()}
      {Lisp-Entry "s64vector" native #f 376 8 376 17 ()}
      {Lisp-Entry "make-s64vector" native #f 377 8 377 22 ()}
      {Lisp-Entry "s64vector-length" native #f 378 8 378 24 ()}
      {Lisp-Entry "s64vector-ref" native #f 379 8 379 21 ()}
      {Lisp-Entry "s64vector-set!" native #f 380 8 380 22 ()}
      {Lisp-Entry "s64vector?" native #f 381 8 381 18 ()}
      {Lisp-Entry "s64vector->list" native #f 382 8 382 23 ()}
      {Lisp-Entry "list->s64vector" native #f 383 8 383 23 ()}
      {Lisp-Entry "u64vector" native #f 386 8 386 17 ()}
      {Lisp-Entry "make-u64vector" native #f 387 8 387 22 ()}
      {Lisp-Entry "u64vector-length" native #f 388 8 388 24 ()}
      {Lisp-Entry "u64vector-ref" native #f 389 8 389 21 ()}
      {Lisp-Entry "u64vector-set!" native #f 390 8 390 22 ()}
      {Lisp-Entry "u64vector?" native #f 391 8 391 18 ()}
      {Lisp-Entry "u64vector->list" native #f 392 8 392 23 ()}
      {Lisp-Entry "list->u64vector" native #f 393 8 393 23 ()}
      {Lisp-Entry "f32vector" native #f 396 8 396 17 ()}
      {Lisp-Entry "make-f32vector" native #f 397 8 397 22 ()}
      {Lisp-Entry "f32vector-length" native #f 398 8 398 24 ()}
      {Lisp-Entry "f32vector-ref" native #f 399 8 399 21 ()}
      {Lisp-Entry "f32vector-set!" native #f 400 8 400 22 ()}
      {Lisp-Entry "f32vector?" native #f 401 8 401 18 ()}
      {Lisp-Entry "f32vector->list" native #f 402 8 402 23 ()}
      {Lisp-Entry "list->f32vector" native #f 403 8 403 23 ()}
      {Lisp-Entry "f64vector" native #f 406 8 406 17 ()}
      {Lisp-Entry "make-f64vector" native #f 407 8 407 22 ()}
      {Lisp-Entry "f64vector-length" native #f 408 8 408 24 ()}
      {Lisp-Entry "f64vector-ref" native #f 409 8 409 21 ()}
      {Lisp-Entry "f64vector-set!" native #f 410 8 410 22 ()}
      {Lisp-Entry "f64vector?" native #f 411 8 411 18 ()}
      {Lisp-Entry "f64vector->list" native #f 412 8 412 23 ()}
      {Lisp-Entry "list->f64vector" native #f 413 8 413 23 ()}
      {Lisp-Entry "command-line" native #f 421 8 421 20 ()}
      {Lisp-Entry "user-name" native #f 422 8 422 17 ()}
      {Lisp-Entry "composite-name?" native #f 430 8 430 28 ()}
      {Lisp-Entry "compose-name" native #f 431 8 431 25 ()}
      {Lisp-Entry "identifier-module" native #f 432 8 432 30 ()}
      {Lisp-Entry "identifier-name" native #f 433 8 433 28 ()}
      {Lisp-Entry "split-identifier" native #f 434 8 434 29 ()}
      {Lisp-Entry "split-composite" native #f 435 8 435 28 ()}
      {Lisp-Entry "bitwise-not" native #f 451 8 451 19 ()}
      {Lisp-Entry "bitwise-and" native #f 452 8 452 19 ()}
      {Lisp-Entry "bitwise-ior" native #f 453 8 453 19 ()}
      {Lisp-Entry "bitwise-xor" native #f 454 8 454 19 ()}
      {Lisp-Entry "arithmetic-shift" native #f 455 8 455 24 ()}
      {Lisp-Entry "bit-set?" native #f 456 8 456 16 ()}
      {Lisp-Entry "extract-bit-field" native #f 457 8 457 25 ()}
      {Lisp-Entry "build-feedback" native #f 465 8 465 27 ()}
      {Lisp-Entry "boot-directory" native #f 466 8 466 27 ()}
      {Lisp-Entry "kernel-system" native #f 467 8 467 26 ()}
      {Lisp-Entry "kernel-platform" native #f 468 8 468 28 ()}
      {Lisp-Entry "kernel-windowing" native #f 469 8 469 29 ()}
      {Lisp-Entry "kernel-safety" native #f 470 8 470 26 ()}
      {Lisp-Entry "kernel-optimize?" native #f 471 8 471 29 ()}
      {Lisp-Entry "kernel-debug-environments?" native #f 472 8 472 39 ()}
      {Lisp-Entry "kernel-debug-location?" native #f 473 8 473 35 ()}
      {Lisp-Entry "kernel-debug-source?" native #f 474 8 474 33 ()}
      {Lisp-Entry "kernel-destination" native #f 475 8 475 31 ()}
      {Lisp-Entry "kernel-built" native #f 476 8 476 25 ()}
      {Lisp-Entry "kernel-install" native #f 477 8 477 27 ()}
      {Lisp-Entry "kernel-source" native #f 478 8 478 26 ()}
      {Lisp-Entry "kernel-version" native #f 479 8 479 27 ()}
      {Lisp-Entry "get-source-version-number" native #f 480 8 480 38 ()}
      {Lisp-Entry "jazz-product" native #f 481 8 481 25 ()}
      {Lisp-Entry "jazz-profile" native #f 482 8 482 25 ()}
      {Lisp-Entry "use-debugger?" native #f 483 8 483 26 ()}
      {Lisp-Entry "get-repositories" native #f 484 8 484 29 ()}
      {Lisp-Entry "install-repository" native #f 485 8 485 31 ()}
      {Lisp-Entry "uninstall-repository" native #f 486 8 486 33 ()}
      {Lisp-Entry "find-repository" native #f 487 8 487 28 ()}
      {Lisp-Entry "find-package" native #f 488 8 488 25 ()}
      {Lisp-Entry "repository?" native #f 489 8 489 24 ()}
      {Lisp-Entry "repository-name" native #f 490 8 490 28 ()}
      {Lisp-Entry "repository-directory" native #f 491 8 491 33 ()}
      {Lisp-Entry "repository-library-root" native #f 492 8 492 36 ()}
      {Lisp-Entry "repository-library-directory" native #f 493 8 493 41 ()}
      {Lisp-Entry "repository-binary?" native #f 494 8 494 31 ()}
      {Lisp-Entry "repository-packages" native #f 495 8 495 32 ()}
      {Lisp-Entry "repository-find-package" native #f 496 8 496 36 ()}
      {Lisp-Entry "repository-install-packages" native #f 497 8 497 40 ()}
      {Lisp-Entry "repository-add-package" native #f 498 8 498 35 ()}
      {Lisp-Entry "repository-remove-package" native #f 499 8 499 38 ()}
      {Lisp-Entry "package?" native #f 500 8 500 21 ()}
      {Lisp-Entry "package-repository" native #f 501 8 501 31 ()}
      {Lisp-Entry "package-name" native #f 502 8 502 25 ()}
      {Lisp-Entry "package-root" native #f 503 8 503 25 ()}
      {Lisp-Entry "package-directory" native #f 504 8 504 30 ()}
      {Lisp-Entry "package-products" native #f 505 8 505 29 ()}
      {Lisp-Entry "package-project" native #f 506 8 506 28 ()}
      {Lisp-Entry "split-version" native #f 507 8 507 26 ()}
      {Lisp-Entry "present-version" native #f 508 8 508 28 ()}
      {Lisp-Entry "load-package" native #f 509 8 509 25 ()}
      {Lisp-Entry "register-product" native #f 510 8 510 29 ()}
      {Lisp-Entry "register-product-run" native #f 511 8 511 33 ()}
      {Lisp-Entry "product-descriptor-name" native #f 512 8 512 36 ()}
      {Lisp-Entry "product-descriptor-module" native #f 513 8 513 38 ()}
      {Lisp-Entry "product-descriptor-title" native #f 514 8 514 37 ()}
      {Lisp-Entry "product-descriptor-icon" native #f 515 8 515 36 ()}
      {Lisp-Entry "product-descriptor-run" native #f 516 8 516 35 ()}
      {Lisp-Entry "product-descriptor-update" native #f 517 8 517 38 ()}
      {Lisp-Entry "product-descriptor-build" native #f 518 8 518 37 ()}
      {Lisp-Entry "product-descriptor-dependencies" native #f 519 8 519 44 ()}
      {Lisp-Entry "run-product-descriptor" native #f 520 8 520 35 ()}
      {Lisp-Entry "update-product-descriptor" native #f 521 8 521 38 ()}
      {Lisp-Entry "build-product-descriptor" native #f 522 8 522 37 ()}
      {Lisp-Entry "current-process-name" native #f 523 8 523 33 ()}
      {Lisp-Entry "current-process-name-set!" native #f 524 8 524 38 ()}
      {Lisp-Entry "current-process-title" native #f 525 8 525 34 ()}
      {Lisp-Entry "current-process-title-set!" native #f 526 8 526 39 ()}
      {Lisp-Entry "current-process-icon" native #f 527 8 527 33 ()}
      {Lisp-Entry "current-process-icon-set!" native #f 528 8 528 38 ()}
      {Lisp-Entry "current-process-version" native #f 529 8 529 36 ()}
      {Lisp-Entry "current-process-version-set!" native #f 530 8 530 41 ()}
      {Lisp-Entry "current-process-present" native #f 531 8 531 36 ()}
      {Lisp-Entry "destination-directory" native #f 532 8 532 34 ()}
      {Lisp-Entry "executable-extension" native #f 533 8 533 33 ()}
      {Lisp-Entry "run-product" native #f 534 8 534 24 ()}
      {Lisp-Entry "update-product" native #f 535 8 535 27 ()}
      {Lisp-Entry "build-product" native #f 536 8 536 26 ()}
      {Lisp-Entry "descendant-module?" native #f 537 8 537 31 ()}
      {Lisp-Entry "find-pathname-module" native #f 538 8 538 33 ()}
      {Lisp-Entry "find-module-src" native #f 539 8 539 28 ()}
      {Lisp-Entry "gather-profiles" native #f 540 8 540 28 ()}
      {Lisp-Entry "make-profile" native #f 541 8 541 25 ()}
      {Lisp-Entry "profile-name" native #f 542 8 542 25 ()}
      {Lisp-Entry "profile-title" native #f 543 8 543 26 ()}
      {Lisp-Entry "profile-module" native #f 544 8 544 27 ()}
      {Lisp-Entry "module-autoload" native #f 545 8 545 28 ()}
      {Lisp-Entry "get-environment" native #f 546 8 546 28 ()}
      {Lisp-Entry "get-environment-module" native #f 547 8 547 35 ()}
      {Lisp-Entry "module-loaded?" native #f 548 8 548 27 ()}
      {Lisp-Entry "module-uptodate-binary?" native #f 549 8 549 36 ()}
      {Lisp-Entry "load-module" native #f 550 8 550 24 ()}
      {Lisp-Entry "reload-module" native #f 551 8 551 26 ()}
      {Lisp-Entry "get-load-mutex" native #f 552 8 552 27 ()}
      {Lisp-Entry "get-load-stack" native #f 553 8 553 27 ()}
      {Lisp-Entry "get-library" native #f 554 8 554 24 ()}
      {Lisp-Entry "require-library" native #f 555 8 555 28 ()}
      {Lisp-Entry "library-get" native #f 556 8 556 24 ()}
      {Lisp-Entry "library-ref" native #f 557 8 557 24 ()}
      {Lisp-Entry "walk-for" native #f 558 8 558 21 ()}
      {Lisp-Entry "register-service" native #f 559 8 559 29 ()}
      {Lisp-Entry "get-service" native #f 560 8 560 24 ()}
      {Lisp-Entry "require-service" native #f 561 8 561 28 ()}
      {Lisp-Entry "global-variable?" native #f 562 8 562 29 ()}
      {Lisp-Entry "global-value" native #f 563 8 563 25 ()}
      {Lisp-Entry "main" native #f 564 8 564 12 ()}
      {Lisp-Entry "keyword?" native #f 572 8 572 21 ()}
      {Lisp-Entry "string->keyword" native #f 573 8 573 28 ()}
      {Lisp-Entry "keyword->string" native #f 574 8 574 28 ()}
      {Lisp-Entry "not-null?" native #f 582 8 582 22 ()}
      {Lisp-Entry "listify" native #f 583 8 583 20 ()}
      {Lisp-Entry "list-copy" native #f 584 8 584 22 ()}
      {Lisp-Entry "last-pair" native #f 585 8 585 22 ()}
      {Lisp-Entry "proper-list" native #f 586 8 586 24 ()}
      {Lisp-Entry "gc" native #f 594 8 594 15 ()}
      {Lisp-Entry "process-memory" native #f 595 8 595 27 ()}
      {Lisp-Entry "symbols-memory" native #f 596 8 596 27 ()}
      {Lisp-Entry "classes-statistics" native #f 597 8 597 31 ()}
      {Lisp-Entry "class-instances-count" native #f 598 8 598 34 ()}
      {Lisp-Entry "class-instances-size" native #f 599 8 599 33 ()}
      {Lisp-Entry "instances-statistics" native #f 600 8 600 33 ()}
      {Lisp-Entry "vector-size" native #f 601 8 601 24 ()}
      {Lisp-Entry "f64vector-size" native #f 602 8 602 27 ()}
      {Lisp-Entry "list-size" native #f 603 8 603 22 ()}
      {Lisp-Entry "table-size" native #f 604 8 604 23 ()}
      {Lisp-Entry "open-tcp-client" native #f 612 8 612 28 ()}
      {Lisp-Entry "open-tcp-server" native #f 613 8 613 28 ()}
      {Lisp-Entry "tcp-server-socket-info" native #f 614 8 614 35 ()}
      {Lisp-Entry "call-with-tcp-client" native #f 615 8 615 33 ()}
      {Lisp-Entry "new" native #f 623 8 623 16 ()}
      {Lisp-Entry "class-of" native #f 624 8 624 21 ()}
      {Lisp-Entry "object?" native #f 625 8 625 20 ()}
      {Lisp-Entry "type?" native #f 626 8 626 18 ()}
      {Lisp-Entry "category?" native #f 627 8 627 22 ()}
      {Lisp-Entry "interface?" native #f 628 8 628 23 ()}
      {Lisp-Entry "method?" native #f 629 8 629 20 ()}
      {Lisp-Entry "is?" native #f 630 8 630 16 ()}
      {Lisp-Entry "subtype?" native #f 631 8 631 21 ()}
      {Lisp-Entry "subcategory?" native #f 632 8 632 25 ()}
      {Lisp-Entry "subclass?" native #f 633 8 633 22 ()}
      {Lisp-Entry "make-parameter" native #f 641 8 641 22 ()}
      {Lisp-Entry "pathname-type" native #f 649 8 649 26 ()}
      {Lisp-Entry "pathname-expand" native #f 650 8 650 28 ()}
      {Lisp-Entry "pathname-normalize" native #f 651 8 651 31 ()}
      {Lisp-Entry "file-exists?" native #f 652 8 652 25 ()}
      {Lisp-Entry "file-delete" native #f 653 8 653 24 ()}
      {Lisp-Entry "file-copy" native #f 654 8 654 22 ()}
      {Lisp-Entry "file-modification-time" native #f 655 8 655 35 ()}
      {Lisp-Entry "file-rename" native #f 656 8 656 24 ()}
      {Lisp-Entry "current-directory" native #f 657 8 657 30 ()}
      {Lisp-Entry "current-directory-set!" native #f 658 8 658 35 ()}
      {Lisp-Entry "with-current-directory" native #f 659 8 659 35 ()}
      {Lisp-Entry "directory-create" native #f 660 8 660 29 ()}
      {Lisp-Entry "directory-content" native #f 661 8 661 30 ()}
      {Lisp-Entry "directory-delete" native #f 662 8 662 29 ()}
      {Lisp-Entry "open-string-pipe" native #f 670 8 670 24 ()}
      {Lisp-Entry "port?" native #f 678 8 678 13 ()}
      {Lisp-Entry "close-port" native #f 679 8 679 23 ()}
      {Lisp-Entry "input-port-timeout-set!" native #f 680 8 680 36 ()}
      {Lisp-Entry "output-port-timeout-set!" native #f 681 8 681 37 ()}
      {Lisp-Entry "open-event-queue" native #f 682 8 682 24 ()}
      {Lisp-Entry "eof-object" native #f 683 8 683 23 ()}
      {Lisp-Entry "open-input-string" native #f 684 8 684 25 ()}
      {Lisp-Entry "open-output-string" native #f 685 8 685 26 ()}
      {Lisp-Entry "get-output-string" native #f 686 8 686 25 ()}
      {Lisp-Entry "call-with-input-string" native #f 687 8 687 30 ()}
      {Lisp-Entry "with-input-from-string" native #f 688 8 688 30 ()}
      {Lisp-Entry "call-with-output-string" native #f 689 8 689 31 ()}
      {Lisp-Entry "read-substring" native #f 690 8 690 22 ()}
      {Lisp-Entry "open-vector" native #f 691 8 691 19 ()}
      {Lisp-Entry "call-with-input-u8vector" native #f 692 8 692 32 ()}
      {Lisp-Entry "open-output-u8vector" native #f 693 8 693 28 ()}
      {Lisp-Entry "get-output-u8vector" native #f 694 8 694 27 ()}
      {Lisp-Entry "read-u8" native #f 695 8 695 20 ()}
      {Lisp-Entry "write-u8" native #f 696 8 696 21 ()}
      {Lisp-Entry "read-subu8vector" native #f 697 8 697 29 ()}
      {Lisp-Entry "write-subu8vector" native #f 698 8 698 30 ()}
      {Lisp-Entry "read-line" native #f 699 8 699 22 ()}
      {Lisp-Entry "read-proper-line" native #f 700 8 700 29 ()}
      {Lisp-Entry "read-all" native #f 701 8 701 21 ()}
      {Lisp-Entry "print" native #f 702 8 702 18 ()}
      {Lisp-Entry "pretty-print" native #f 703 8 703 25 ()}
      {Lisp-Entry "read-source-all" native #f 704 8 704 28 ()}
      {Lisp-Entry "read-source-first" native #f 705 8 705 30 ()}
      {Lisp-Entry "force-output" native #f 706 8 706 20 ()}
      {Lisp-Entry "current-error-port" native #f 707 8 707 26 ()}
      {Lisp-Entry "with-output-to-port" native #f 708 8 708 27 ()}
      {Lisp-Entry "write-u8" native #f 709 8 709 16 ()}
      {Lisp-Entry "property-getter" native #f 717 8 717 28 ()}
      {Lisp-Entry "property-setter" native #f 718 8 718 28 ()}
      {Lisp-Entry "new-queue" native #f 726 8 726 22 ()}
      {Lisp-Entry "enqueue" native #f 727 8 727 20 ()}
      {Lisp-Entry "enqueue-list" native #f 728 8 728 25 ()}
      {Lisp-Entry "queue-list" native #f 729 8 729 23 ()}
      {Lisp-Entry "reset-queue" native #f 730 8 730 24 ()}
      {Lisp-Entry "random-integer" native #f 738 8 738 27 ()}
      {Lisp-Entry "random-real" native #f 739 8 739 24 ()}
      {Lisp-Entry "random-source-randomize!" native #f 740 8 740 37 ()}
      {Lisp-Entry "random-source-pseudo-randomize!" native #f 741 8 741 44 ()}
      {Lisp-Entry "default-random-source" native #f 742 8 742 34 ()}
      {Lisp-Entry "with-readtable" native #f 750 8 750 27 ()}
      {Lisp-Entry "scheme-readtable" native #f 751 8 751 29 ()}
      {Lisp-Entry "jazz-readtable" native #f 752 8 752 27 ()}
      {Lisp-Entry "with-jazz-readtable" native #f 753 8 753 32 ()}
      {Lisp-Entry "current-repl-context" native #f 761 8 761 33 ()}
      {Lisp-Entry "repl-context-level" native #f 762 8 762 31 ()}
      {Lisp-Entry "repl-context-depth" native #f 763 8 763 31 ()}
      {Lisp-Entry "repl-context-cont" native #f 764 8 764 30 ()}
      {Lisp-Entry "repl-context-initial-cont" native #f 765 8 765 38 ()}
      {Lisp-Entry "repl-context-prev-level" native #f 766 8 766 36 ()}
      {Lisp-Entry "repl-context-prev-depth" native #f 767 8 767 36 ()}
      {Lisp-Entry "with-repl-context" native #f 768 8 768 30 ()}
      {Lisp-Entry "inspect-repl-context" native #f 769 8 769 33 ()}
      {Lisp-Entry "repl" native #f 770 8 770 17 ()}
      {Lisp-Entry "eval-within-no-winding" native #f 771 8 771 35 ()}
      {Lisp-Entry "repl-result-history-add" native #f 772 8 772 36 ()}
      {Lisp-Entry "repl-result-history-ref" native #f 773 8 773 31 ()}
      {Lisp-Entry "resource-pathname" native #f 781 8 781 30 ()}
      {Lisp-Entry "get-object-slot" native #f 789 8 789 28 ()}
      {Lisp-Entry "set-object-slot" native #f 790 8 790 28 ()}
      {Lisp-Entry "dispatch" native #f 791 8 791 21 ()}
      {Lisp-Entry "find-dispatch" native #f 792 8 792 26 ()}
      {Lisp-Entry "call-into-abstract" native #f 793 8 793 31 ()}
      {Lisp-Entry "get-core-classes" native #f 794 8 794 29 ()}
      {Lisp-Entry "object->serial" native #f 802 8 802 27 ()}
      {Lisp-Entry "serial->object" native #f 803 8 803 27 ()}
      {Lisp-Entry "object->serial-number" native #f 806 8 806 29 ()}
      {Lisp-Entry "serial-number->object" native #f 807 8 807 29 ()}
      {Lisp-Entry "shell-command" native #f 815 8 815 21 ()}
      {Lisp-Entry "slot?" native #f 823 8 823 18 ()}
      {Lisp-Entry "slot-value" native #f 824 8 824 23 ()}
      {Lisp-Entry "set-slot-value" native #f 825 8 825 27 ()}
      {Lisp-Entry "socket-info-address" native #f 833 8 833 32 ()}
      {Lisp-Entry "socket-info-port-number" native #f 834 8 834 36 ()}
      {Lisp-Entry "get-procedure-name" native #f 842 8 842 31 ()}
      {Lisp-Entry "get-continuation-stack" native #f 843 8 843 35 ()}
      {Lisp-Entry "get-continuation-name" native #f 844 8 844 34 ()}
      {Lisp-Entry "get-continuation-dynamic-environment" native #f 845 8 845 49 ()}
      {Lisp-Entry "get-continuation-lexical-environment" native #f 846 8 846 49 ()}
      {Lisp-Entry "get-continuation-location" native #f 847 8 847 38 ()}
      {Lisp-Entry "interpreted-continuation?" native #f 848 8 848 38 ()}
      {Lisp-Entry "join-strings" native #f 856 8 856 25 ()}
      {Lisp-Entry "kind?" native #f 864 8 864 18 ()}
      {Lisp-Entry "kind-id" native #f 865 8 865 20 ()}
      {Lisp-Entry "kind-name" native #f 866 8 866 22 ()}
      {Lisp-Entry "kind-flags" native #f 867 8 867 23 ()}
      {Lisp-Entry "kind-super" native #f 868 8 868 23 ()}
      {Lisp-Entry "kind-length" native #f 869 8 869 24 ()}
      {Lisp-Entry "kind-fields" native #f 870 8 870 24 ()}
      {Lisp-Entry "structure?" native #f 871 8 871 23 ()}
      {Lisp-Entry "structure-kind" native #f 872 8 872 27 ()}
      {Lisp-Entry "structure-ref" native #f 873 8 873 26 ()}
      {Lisp-Entry "structure-set!" native #f 874 8 874 27 ()}
      {Lisp-Entry "make-foo" native #f 875 8 875 16 ()}
      {Lisp-Entry "make-bar" native #f 876 8 876 16 ()}
      {Lisp-Entry "generate-symbol" native #f 884 8 884 28 ()}
      {Lisp-Entry "with-uniqueness" native #f 885 8 885 28 ()}
      {Lisp-Entry "source?" native #f 893 8 893 20 ()}
      {Lisp-Entry "source-code" native #f 894 8 894 24 ()}
      {Lisp-Entry "source-locat" native #f 895 8 895 25 ()}
      {Lisp-Entry "desourcify" native #f 896 8 896 23 ()}
      {Lisp-Entry "desourcify-all" native #f 897 8 897 27 ()}
      {Lisp-Entry "sourcify" native #f 898 8 898 21 ()}
      {Lisp-Entry "sourcify-if" native #f 899 8 899 24 ()}
      {Lisp-Entry "present-source" native #f 900 8 900 27 ()}
      {Lisp-Entry "locat-container" native #f 901 8 901 28 ()}
      {Lisp-Entry "locat-position" native #f 902 8 902 27 ()}
      {Lisp-Entry "locat->file/line/col" native #f 903 8 903 33 ()}
      {Lisp-Entry "container->path" native #f 904 8 904 28 ()}
      {Lisp-Entry "position->filepos" native #f 905 8 905 30 ()}
      {Lisp-Entry "filepos-line" native #f 906 8 906 25 ()}
      {Lisp-Entry "filepos-col" native #f 907 8 907 24 ()}
      {Lisp-Entry "switch?" native #f 915 8 915 20 ()}
      {Lisp-Entry "switch-name" native #f 916 8 916 24 ()}
      {Lisp-Entry "command-argument" native #f 917 8 917 29 ()}
      {Lisp-Entry "open-process" native #f 918 8 918 25 ()}
      {Lisp-Entry "process-status" native #f 919 8 919 27 ()}
      {Lisp-Entry "exit" native #f 920 8 920 17 ()}
      {Lisp-Entry "table?" native #f 928 8 928 14 ()}
      {Lisp-Entry "make-table" native #f 929 8 929 18 ()}
      {Lisp-Entry "table-ref" native #f 930 8 930 17 ()}
      {Lisp-Entry "table-set!" native #f 931 8 931 18 ()}
      {Lisp-Entry "table->list" native #f 932 8 932 19 ()}
      {Lisp-Entry "list->table" native #f 933 8 933 19 ()}
      {Lisp-Entry "table-clear" native #f 934 8 934 24 ()}
      {Lisp-Entry "table-length" native #f 935 8 935 25 ()}
      {Lisp-Entry "iterate-table" native #f 936 8 936 26 ()}
      {Lisp-Entry "map-table" native #f 937 8 937 22 ()}
      {Lisp-Entry "table-entries" native #f 938 8 938 26 ()}
      {Lisp-Entry "eq-hash" native #f 939 8 939 20 ()}
      {Lisp-Entry "eqv-hash" native #f 940 8 940 21 ()}
      {Lisp-Entry "equal-hash" native #f 941 8 941 23 ()}
      {Lisp-Entry "set-terminal-title" native #f 949 8 949 31 ()}
      {Lisp-Entry "bring-terminal-to-front" native #f 950 8 950 36 ()}
      {Lisp-Entry "clear-terminal" native #f 951 8 951 27 ()}
      {Lisp-Entry "current-thread" native #f 959 8 959 27 ()}
      {Lisp-Entry "thread?" native #f 960 8 960 20 ()}
      {Lisp-Entry "make-thread" native #f 961 8 961 24 ()}
      {Lisp-Entry "make-root-thread" native #f 962 8 962 29 ()}
      {Lisp-Entry "thread-name" native #f 963 8 963 24 ()}
      {Lisp-Entry "thread-specific" native #f 964 8 964 28 ()}
      {Lisp-Entry "thread-specific-set!" native #f 965 8 965 33 ()}
      {Lisp-Entry "thread-base-priority" native #f 966 8 966 33 ()}
      {Lisp-Entry "thread-base-priority-set!" native #f 967 8 967 38 ()}
      {Lisp-Entry "thread-priority-boost" native #f 968 8 968 34 ()}
      {Lisp-Entry "thread-priority-boost-set!" native #f 969 8 969 39 ()}
      {Lisp-Entry "thread-start!" native #f 970 8 970 26 ()}
      {Lisp-Entry "thread-yield!" native #f 971 8 971 26 ()}
      {Lisp-Entry "thread-sleep!" native #f 972 8 972 26 ()}
      {Lisp-Entry "thread-terminate!" native #f 973 8 973 30 ()}
      {Lisp-Entry "thread-join!" native #f 974 8 974 25 ()}
      {Lisp-Entry "thread-send" native #f 975 8 975 24 ()}
      {Lisp-Entry "thread-receive" native #f 976 8 976 27 ()}
      {Lisp-Entry "thread-interrupt!" native #f 977 8 977 30 ()}
      {Lisp-Entry "thread-thread-group" native #f 978 8 978 32 ()}
      {Lisp-Entry "thread-group->thread-group-list" native #f 979 8 979 44 ()}
      {Lisp-Entry "thread-group->thread-group-vector" native #f 980 8 980 46 ()}
      {Lisp-Entry "thread-group->thread-list" native #f 981 8 981 38 ()}
      {Lisp-Entry "thread-group->thread-vector" native #f 982 8 982 40 ()}
      {Lisp-Entry "thread-state" native #f 983 8 983 25 ()}
      {Lisp-Entry "thread-state-abnormally-terminated-reason" native #f 984 8 984 54 ()}
      {Lisp-Entry "thread-state-abnormally-terminated?" native #f 985 8 985 48 ()}
      {Lisp-Entry "thread-state-active-timeout" native #f 986 8 986 40 ()}
      {Lisp-Entry "thread-state-active-waiting-for" native #f 987 8 987 44 ()}
      {Lisp-Entry "thread-state-active?" native #f 988 8 988 33 ()}
      {Lisp-Entry "thread-state-initialized?" native #f 989 8 989 38 ()}
      {Lisp-Entry "thread-state-normally-terminated-result" native #f 990 8 990 52 ()}
      {Lisp-Entry "thread-state-normally-terminated?" native #f 991 8 991 46 ()}
      {Lisp-Entry "thread-state-uninitialized?" native #f 992 8 992 40 ()}
      {Lisp-Entry "pristine-thread-continuation" native #f 993 8 993 41 ()}
      {Lisp-Entry "mutex?" native #f 994 8 994 19 ()}
      {Lisp-Entry "make-mutex" native #f 995 8 995 23 ()}
      {Lisp-Entry "mutex-name" native #f 996 8 996 23 ()}
      {Lisp-Entry "mutex-specific" native #f 997 8 997 27 ()}
      {Lisp-Entry "mutex-specific-set!" native #f 998 8 998 32 ()}
      {Lisp-Entry "mutex-state" native #f 999 8 999 24 ()}
      {Lisp-Entry "mutex-lock!" native #f 1000 8 1000 24 ()}
      {Lisp-Entry "mutex-unlock!" native #f 1001 8 1001 26 ()}
      {Lisp-Entry "mutex-wait" native #f 1002 8 1002 23 ()}
      {Lisp-Entry "mutex-owner" native #f 1003 8 1003 24 ()}
      {Lisp-Entry "condition?" native #f 1004 8 1004 23 ()}
      {Lisp-Entry "make-condition" native #f 1005 8 1005 27 ()}
      {Lisp-Entry "condition-name" native #f 1006 8 1006 27 ()}
      {Lisp-Entry "condition-specific" native #f 1007 8 1007 31 ()}
      {Lisp-Entry "condition-specific-set!" native #f 1008 8 1008 36 ()}
      {Lisp-Entry "condition-signal!" native #f 1009 8 1009 30 ()}
      {Lisp-Entry "condition-broadcast!" native #f 1010 8 1010 33 ()}
      {Lisp-Entry "current-systime" native #f 1018 8 1018 28 ()}
      {Lisp-Entry "systime?" native #f 1019 8 1019 21 ()}
      {Lisp-Entry "systime->seconds" native #f 1020 8 1020 29 ()}
      {Lisp-Entry "seconds->systime" native #f 1021 8 1021 29 ()}
      {Lisp-Entry "process-times" native #f 1022 8 1022 26 ()}
      {Lisp-Entry "cpu-time" native #f 1023 8 1023 21 ()}
      {Lisp-Entry "real-time" native #f 1024 8 1024 22 ()}
      {Lisp-Entry "unspecified" native #f 1032 8 1032 24 ()}
      {Lisp-Entry "unspecified?" native #f 1033 8 1033 25 ()}
      {Lisp-Entry "specified?" native #f 1034 8 1034 23 ()}
      {Lisp-Entry "vector-copy" native #f 1042 8 1042 24 ()}
      {Lisp-Entry "analysis-mode?" native #f 1050 8 1050 27 ()}
      {Lisp-Entry "autoload-references" native #f 1051 8 1051 32 ()}
      {Lisp-Entry "new-walk-context" native #f 1052 8 1052 29 ()}
      {Lisp-Entry "specifier?" native #f 1053 8 1053 23 ()}
      {Lisp-Entry "binding-specifier" native #f 1054 8 1054 30 ()}
      {Lisp-Entry "parse-specifier" native #f 1055 8 1055 28 ()}
      {Lisp-Entry "requested-module-name" native #f 1056 8 1056 34 ()}
      {Lisp-Entry "requested-module-resource" native #f 1057 8 1057 38 ()}
      {Lisp-Entry "get-private-lookup" native #f 1058 8 1058 31 ()}
      {Lisp-Entry "get-public-lookup" native #f 1059 8 1059 30 ()}
      {Lisp-Entry "get-protected-lookup" native #f 1060 8 1060 33 ()}
      {Lisp-Entry "get-catalog" native #f 1061 8 1061 24 ()}
      {Lisp-Entry "get-catalog-entry" native #f 1062 8 1062 30 ()}
      {Lisp-Entry "release-catalog-entries" native #f 1063 8 1063 36 ()}
      {Lisp-Entry "outline-feedback" native #f 1064 8 1064 29 ()}
      {Lisp-Entry "outline-module" native #f 1065 8 1065 27 ()}
      {Lisp-Entry "walk-module" native #f 1066 8 1066 24 ()}
      {Lisp-Entry "expand-module" native #f 1067 8 1067 26 ()}}})
"_language"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "dialect" "language" "_language.jazz"} 1250720196
    {Lisp-Entry "jazz.dialect.language" library #f 37 19 37 40 ("jazz.dialect")}})
"_performance"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "test" "performance" "_performance.scm"} 1237033585
    {Lisp-Entry "test.performance" module #f 0 8 0 24 ()}})
"_syntax"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "dialect" "syntax" "_syntax.scm"} 1248708411
    {Lisp-Entry "jazz.dialect.syntax" library #f 37 19 37 38 ("scheme")}})
"_test"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "test" "_test.jazz"} 1253212945
    {Lisp-Entry "jazz.test" library #f 37 9 37 18 ("'a" "5" "set-element!" "10" "axis-grow" "0" "Axis" "new" "axis" "3" "2" "Point" "b" "a" "debug" "table-values" "apply" "remove-duplicates" "table-keys" "done" "'done" "walking" "'walking" "terminal" "if" "feedback:" "Jazz" "'Jazz" "find-repository" "list" "repositories:" "iterate-modules" "get-symbol" "table-add" "Unresolved-Error" "is?" "when" "problem" "for-each" "get-errors" "get-warnings" "append" "problems" "exc" "Walk-Problems" "catch" "module-name" "walk" "define" "eq?" "test:" "make-table" "unresolved" "let" "cons" "jazz.sample.library" "'jazz.sample.library" "walk-module" "fold-declaration" "pp" "port" "function" "call-with-output-file" "jazz")
      {Lisp-Entry "Y" class #f 328 7 328 8 ("X")
        {Lisp-Entry "f" method #f 331 16 331 17 ("2")}}
      {Lisp-Entry "Y~Class207" class #f 337 9 337 19 ("X" ":class")
        {Lisp-Entry "f" method #f 340 13 340 14 ("2")}}
      {Lisp-Entry "Y" class #f 344 9 344 10 ("X" "Y~Class207")}
      {Lisp-Entry "f" definition #f 441 13 441 14 ("=" "not" "if" "c")}
      {Lisp-Entry "f" definition #f 502 13 502 14 ("+" "0" "n" "iter" "let")}
      {Lisp-Entry "TC" class #f 509 7 509 9 ("3" "1" "initialize" "Object")
        {Lisp-Entry "row" slot #f 512 8 512 11 ()}
        {Lisp-Entry "col" slot #f 513 8 513 11 ()}
        {Lisp-Entry "f" method #f 516 11 516 12 ("col" "0" "subseq!" "row" "when")}
        {Lisp-Entry "g" method #f 521 11 521 12 ("col" "0" "subseq!")}}
      {Lisp-Entry "f" definition #f 526 13 526 14 ("g" "TC" "new" "f" "class-of" "list")}}})
"_walker"
 ({Lisp-File-Entry {File jazz "src" "jazz" "dialect" "walker" "_walker.jazz"} 1248708411
    {Lisp-Entry "jazz.dialect.walker" library #f 37 19 37 38 ("jazz.dialect")}})
"a"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "test" "a.jazz"} 1250272407
    {Lisp-Entry "jazz.test.a" library #f 0 9 0 20 ("jazz")}}
  {Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "test" "performance" "a.scm"} 1237033585
    {Lisp-Entry "test.performance.a" module #f 0 8 0 26 ()
      {Lisp-Entry "f-separate" define #f 8 9 8 19 ("1" "%%fx-" "g-separate" "0" "%%fx=" "if" "n" "s")}}})
"attributes"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "dialect" "syntax" "attributes.scm"} 1248797037
    {Lisp-Entry "jazz.dialect.syntax.attributes" library #f 37 19 37 49 ("scheme")
      {Lisp-Entry "private" native #f 43 8 43 15 ("jazz.getf")}
      {Lisp-Entry "private" native #f 44 8 44 15 ("jazz.system-format")}
      {Lisp-Entry "attributes" macro #f 84 15 84 25 ("set-property" ",setter" ",getter" "public" "setter" "system-format" "string->symbol" "getter" "let*" "set!" "'set!" ",value" "set-value" "nextmethod" "else" "list" "case" ",property" "get-value" ",init" ",name" "slot" "eq?" "if" "not-found:" "initialize" "'initialize" "getf" "init" "rest" "specifier" "parse-specifier" "name" "lambda" "append" "map" "node-properties" "method" "begin" "value" "generate-symbol" "property" "cdr" "properties" "car" "inherited" "let" "symbol->string" "string->keyword" "symbol" "symbol->keyword" "cons" "unspecified" "define" "form")}}})
"autoload"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "test" "autoload.jazz"} 1237033585
    {Lisp-Entry "jazz.test.autoload" library #f 0 9 0 27 ("jazz")}})
"b"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "test" "b.jazz"} 1250272407
    {Lisp-Entry "jazz.test.b" library #f 0 9 0 20 ("jazz")
      {Lisp-Entry "Version" class #f 3 7 3 14 ("Object")}}}
  {Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "test" "performance" "b.scm"} 1237033585
    {Lisp-Entry "test.performance.b" module #f 0 8 0 26 ()
      {Lisp-Entry "g-separate" define #f 8 9 8 19 ("1" "%%fx-" "f-separate" "0" "%%fx=" "if" "n" "s")}}})
"bind"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "dialect" "syntax" "bind.scm"} 1248708411
    {Lisp-Entry "jazz.dialect.syntax.bind" library #f 38 19 38 43 ("scheme")
      {Lisp-Entry "bind" macro #f 56 16 56 20 ("expand-bind-car" "begin" "tree-value" "lambda" "with-uniqueness" "sourcify-if" "cdr" "body" "cddr" "car" "tree" "source-code" "cadr" "desourcify" "bindings" "let" "form-src")}
      {Lisp-Entry "expand-bind-car" define #f 68 9 68 24 ("expand-bind-car" ",car-symbol" "generate-symbol" "car-symbol" "pair?" "expand-bind-cdr" ",tree" ",specifier" ",car-binding" "if" "binding-specifier" "specifier" "symbol?" "cond" "cdr" "cdr-binding" "car" "car-binding" "let" "body" "tree" "bindings")}
      {Lisp-Entry "expand-bind-cdr" define #f 85 9 85 24 ("expand-bind-car" ",cdr-symbol" "generate-symbol" "cdr-symbol" "pair?" ",@body" ",tree" "cdr" ",cdr-binding" "let" "symbol?" "null?" "cond" "body" "tree" "cdr-binding")}}})
"bind-keywords"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "dialect" "syntax" "bind-keywords.scm"} 1248708411
    {Lisp-Entry "jazz.dialect.syntax.bind-keywords" library #f 38 19 38 52 ("scheme")
      {Lisp-Entry "private" native #f 44 8 44 15 ("jazz.last-tail")}
      {Lisp-Entry "bind-keywords" macro #f 57 16 57 29 ("error" "not-null?" ",@body" "unbox-list" "symbol?" "proper-list" ",default" "symbol->string" "string->keyword" "find-keyword" ",specifier" ",variable" "caddr" "if" "default" "binding-specifier" "specifier" "variable" "binding" "lambda" "map" "let*" ",rest" "box-list" ",box" "sourcify-if" "last-tail" "oth" "new-queue" "bnd" "generate-symbol" "box" "cdr" "body" "cddr" "car" "rest" "cadr" "source-code" "bindings" "let" "form-src")}}})
"bind-optionals"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "dialect" "syntax" "bind-optionals.scm"} 1248708411
    {Lisp-Entry "jazz.dialect.syntax.bind-optionals" library #f 38 19 38 53 ("scheme")
      {Lisp-Entry "bind-optionals" macro #f 61 16 61 30 (",@body" "error" "not-null?" "proper-list" ",value" ",specifier" ",variable" "set!" ",prog" ",default" "null?" "value" "caddr" "if" "default" "binding-specifier" "specifier" "variable" "binding" "lambda" "map" "let*" ",rest" ",scan" "sourcify-if" "prog" "generate-symbol" "scan" "cdr" "body" "cddr" "car" "rest" "cadr" "source-code" "bindings" "let" "form-src")}}})
"c"
 ({Lisp-File-Entry {File jazz "src" "jazz" "test" "c.jazz"} 1250272407
    {Lisp-Entry "jazz.test.c" library #f 0 9 0 20 ("jazz")}})
"cffi"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "test" "cffi.jazz"} 1237033585
    {Lisp-Entry "jazz.test.cffi" library #f 37 9 37 23 ("#<<end-of-c-declare\nstatic int func2(mult* m, int n)\n{\n    return (*m)(n);\n}\nend-of-c-declare\n" "#<<end-of-c-declare\ntypedef int (mult)(int);\n\nstatic int multiply(int n)\n{\n    return n * n;\n}\n\nstatic mult* func1()\n{\n    return &multiply;\n}\nend-of-c-declare\n" "#<<end-of-c-declare\nstruct S1_\n{\n    int x;\n    int y;\n};\n\ntypedef struct S1_ S1;\n\nstatic int struct1a(S1 s1)\n{\n    return s1.x + s1.y;\n}\n\n//static int struct1b(S1& s1)\n//{\n//    return s1.x + s1.y;\n//}\n\nstatic int struct1c(S1* s1)\n{\n    return s1->x + s1->y;\n}\n\nstatic void tst()\n{\n    S1 s;\n    \n    struct1a(s);\n    struct1c(&s);\n}\nend-of-c-declare\n" "#<<end-of-c-declare\nstatic int scalar3(___SCMOBJ obj)\n{\n    return (int) obj;\n}\nend-of-c-declare\n" "#<<end-of-c-declare\nstatic int scalar2(int n)\n{\n    return n + n;\n}\nend-of-c-declare\n" "#<<end-of-c-declare\nstatic void scalar1(int n)\n{\n}\nend-of-c-declare\n" "#<<end-of-c-declare\nN = 2;\nend-of-c-declare\n" "#<<end-of-c-declare\nstatic int N;\nend-of-c-declare\n" "jazz")
      {Lisp-Entry "init1" definition #f 71 12 71 17 ("int" "c-function")}
      {Lisp-Entry "void" c-type #f 80 8 80 12 ("void" "native")}
      {Lisp-Entry "bool" c-type #f 81 8 81 12 ("bool" "native")}
      {Lisp-Entry "char" c-type #f 82 8 82 12 ("char" "native")}
      {Lisp-Entry "wchar_t" c-type #f 83 8 83 15 ("wchar_t" "native")}
      {Lisp-Entry "int" c-type #f 84 8 84 11 ("int" "native")}
      {Lisp-Entry "double" c-type #f 85 8 85 14 ("double" "native")}
      {Lisp-Entry "scheme-object" c-type #f 86 8 86 21 ("scheme-object" "native")}
      {Lisp-Entry "object" c-type #f 87 8 87 14 ("scheme-object")}
      {Lisp-Entry "scalar1" definition #f 98 12 98 19 ("void" "int" "c-function")}
      {Lisp-Entry "scalar2" definition #f 111 12 111 19 ("int" "c-function")}
      {Lisp-Entry "scalar3" definition #f 124 12 124 19 ("int" "object" "c-function")}
      {Lisp-Entry "ca" definition #f 186 12 186 14 ("2")}
      {Lisp-Entry "cb" definition #f 187 12 187 14 ("3")}
      {Lisp-Entry "e" c-enumeration #f 195 15 195 16 ("4" "ec" "2" "eb" "1" "ea")}
      {Lisp-Entry "S1" c-type #f 243 8 243 10 ("struct")}
      {Lisp-Entry "make-S1" definition #f 246 12 246 19 ("S1" "c-function")}
      {Lisp-Entry "struct1a" definition #f 251 12 251 20 ("int" "S1" "c-function")}
      {Lisp-Entry "struct1c" definition #f 257 12 257 20 ("int" "S1" "pointer" "c-function")}
      {Lisp-Entry "cast-S2->S2*" definition #f 268 12 268 24 ("error" "S2*" "object" "c-function" "S2" "'S2" "foreign-tags" "car" "eq?" "if" "s2" "function")}
      {Lisp-Entry "mult*" c-type #f 305 8 305 13 ("int" "function" "pointer")}
      {Lisp-Entry "func1" definition #f 324 12 324 17 ("mult*" "c-function")}}})
"classes"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "dialect" "classes.scm"} 1252768922
    {Lisp-Entry "jazz.dialect.classes" module #f 37 18 37 38 ()
      {Lisp-Entry "jazz.Definition-Declaration" define-class #f 45 19 45 46 ("%%set-definition-declaration-value" "%%get-definition-declaration-value" "value" "%%set-definition-declaration-signature" "%%get-definition-declaration-signature" "signature" "%%get-definition-declaration-expansion" "expansion" "jazz.allocate-definition-declaration" "jazz.Object-Class" "source" "locator" "parent" "toplevel" "attributes" "compatibility" "access" "hits" "type" "name" "jazz.Declaration")}
      {Lisp-Entry "jazz.Specialize" define-class #f 56 19 56 34 ("jazz.allocate-specialize" "jazz.Object-Class" "source" "type" "jazz.Expression")}
      {Lisp-Entry "jazz.Generic-Declaration" define-class #f 65 19 65 43 ("%%set-generic-declaration-body" "%%get-generic-declaration-body" "body" "%%set-generic-declaration-signature" "%%get-generic-declaration-signature" "signature" "%%get-generic-declaration-dispatch-types" "dispatch-types" "jazz.allocate-generic-declaration" "jazz.Object-Class" "source" "locator" "parent" "toplevel" "attributes" "compatibility" "access" "hits" "type" "name" "jazz.Declaration")}
      {Lisp-Entry "jazz.Specific-Declaration" define-class #f 76 19 76 44 ("%%get-specific-declaration-root?" "root?" "%%set-specific-declaration-body" "%%get-specific-declaration-body" "body" "%%get-specific-declaration-signature" "signature" "%%get-specific-declaration-generic" "generic" "jazz.allocate-specific-declaration" "jazz.Object-Class" "source" "locator" "parent" "toplevel" "attributes" "compatibility" "access" "hits" "type" "name" "jazz.Declaration")}
      {Lisp-Entry "jazz.Category-Declaration" define-class #f 88 19 88 44 ("%%get-category-declaration-metaclass" "metaclass" "%%get-category-declaration-implementor" "implementor" "jazz.Object-Class" "body" "children" "lookups" "source" "locator" "parent" "toplevel" "attributes" "compatibility" "access" "hits" "type" "name" "jazz.Namespace-Declaration")}
      {Lisp-Entry "jazz.Class-Declaration" define-class #f 98 19 98 41 ("%%get-class-declaration-interfaces" "interfaces" "%%get-class-declaration-ascendant-base" "ascendant-base" "%%get-class-declaration-ascendant-relation" "ascendant-relation" "%%get-class-declaration-ascendant" "ascendant" "jazz.allocate-class-declaration" "jazz.Object-Class" "metaclass" "implementor" "body" "children" "lookups" "source" "locator" "parent" "toplevel" "attributes" "compatibility" "access" "hits" "type" "name" "jazz.Category-Declaration")}
      {Lisp-Entry "jazz.Interface-Declaration" define-class #f 110 19 110 45 ("%%get-interface-declaration-ascendants" "ascendants" "jazz.allocate-interface-declaration" "jazz.Object-Class" "metaclass" "implementor" "body" "children" "lookups" "source" "locator" "parent" "toplevel" "attributes" "compatibility" "access" "hits" "type" "name" "jazz.Category-Declaration")}
      {Lisp-Entry "jazz.Field-Declaration" define-class #f 119 19 119 41 ("jazz.Object-Class" "source" "locator" "parent" "toplevel" "attributes" "compatibility" "access" "hits" "type" "name" "jazz.Declaration")}
      {Lisp-Entry "jazz.Slot-Declaration" define-class #f 128 19 128 40 ("%%get-slot-declaration-setter-name" "setter-name" "%%get-slot-declaration-getter-name" "getter-name" "%%set-slot-declaration-initialize" "%%get-slot-declaration-initialize" "initialize" "jazz.allocate-slot-declaration" "jazz.Object-Class" "source" "locator" "parent" "toplevel" "attributes" "compatibility" "access" "hits" "type" "name" "jazz.Field-Declaration")}
      {Lisp-Entry "jazz.Property-Declaration" define-class #f 139 19 139 44 ("%%set-property-declaration-setter" "%%get-property-declaration-setter" "setter" "%%set-property-declaration-getter" "%%get-property-declaration-getter" "getter" "jazz.allocate-property-declaration" "jazz.Object-Class" "setter-name" "getter-name" "initialize" "source" "locator" "parent" "toplevel" "attributes" "compatibility" "access" "hits" "type" "name" "jazz.Slot-Declaration")}
      {Lisp-Entry "jazz.Method-Declaration" define-class #f 149 19 149 42 ("%%set-method-declaration-body" "%%get-method-declaration-body" "body" "%%set-method-declaration-signature" "%%get-method-declaration-signature" "signature" "%%get-method-declaration-synchronized" "synchronized" "%%get-method-declaration-remote" "remote" "%%get-method-declaration-expansion" "expansion" "%%get-method-declaration-abstraction" "abstraction" "%%get-method-declaration-propagation" "propagation" "%%get-method-declaration-root" "root" "jazz.allocate-method-declaration" "jazz.Object-Class" "source" "locator" "parent" "toplevel" "attributes" "compatibility" "access" "hits" "type" "name" "jazz.Field-Declaration")}
      {Lisp-Entry "jazz.With-Self" define-class #f 165 19 165 33 ("%%get-with-self-body" "body" "jazz.allocate-with-self" "jazz.Object-Class" "source" "type" "jazz.Expression")}
      {Lisp-Entry "jazz.With-Dynamic-Self" define-class #f 174 19 174 41 ("%%get-with-dynamic-self-body" "body" "%%get-with-dynamic-self-code" "code" "jazz.allocate-with-dynamic-self" "jazz.Object-Class" "source" "type" "jazz.Expression")}
      {Lisp-Entry "jazz.Cast" define-class #f 184 19 184 28 ("%%get-cast-expression" "expression" "jazz.allocate-cast" "jazz.Object-Class" "source" "type" "jazz.Expression")}
      {Lisp-Entry "jazz.Construct" define-class #f 193 19 193 33 ("%%get-construct-values" "values" "%%get-construct-class" "class" "jazz.allocate-construct" "jazz.Object-Class" "source" "type" "jazz.Expression")}
      {Lisp-Entry "jazz.Dispatch" define-class #f 203 19 203 32 ("%%get-dispatch-arguments" "arguments" "%%get-dispatch-name" "name" "jazz.allocate-dispatch" "jazz.Object-Class" "source" "type" "jazz.Expression")}
      {Lisp-Entry "jazz.Jazz-Dialect" define-class #f 213 19 213 36 ("jazz.allocate-jazz-dialect" "jazz.Object-Class" "jazz.Dialect")}
      {Lisp-Entry "jazz.Jazz-Walker" define-class #f 222 19 222 35 ("jazz.allocate-jazz-walker" "jazz.Object-Class" "errors" "warnings" "jazz.Scheme-Walker")}}})
"common"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "test" "performance" "common.scm"} 1237033585
    {Lisp-Entry "test.performance.common" module #f 0 8 0 31 ("W" "Z" "X" "jazz.encapsulate-class")
      {Lisp-Entry "ff" define #f 11 9 11 11 ("1" "%%fx-" "ff" "%%pair?" "begin" "0" "%%fx>" "if" "n")}
      {Lisp-Entry "gg" define #f 24 9 24 11 ("1" "%%fx-" "gg" "%%pair?" "begin" "0" "%%fx>" "if" "n")}
      {Lisp-Entry "f-module-block/standard/not-safe" define #f 42 9 42 41 ("1" "%%fx-" "g-module-block/standard/not-safe" "0" "%%fx=" "if" "n" "s")}
      {Lisp-Entry "g-module-block/standard/not-safe" define #f 48 9 48 41 ("1" "%%fx-" "f-module-block/standard/not-safe" "0" "%%fx=" "if" "n" "s")}
      {Lisp-Entry "f-module-block/runtime/safe" define #f 66 9 66 36 ("1" "%%fx-" "g-module-block/runtime/safe" "0" "%%fx=" "if" "n" "s")}
      {Lisp-Entry "g-module-block/runtime/safe" define #f 72 9 72 36 ("1" "%%fx-" "f-module-block/runtime/safe" "0" "%%fx=" "if" "n" "s")}
      {Lisp-Entry "f-module-separate/runtime/safe" define #f 90 9 90 39 ("1" "%%fx-" "g-module-separate/runtime/safe" "0" "%%fx=" "if" "n" "s")}
      {Lisp-Entry "g-module-separate/runtime/safe" define #f 96 9 96 39 ("1" "%%fx-" "f-module-separate/runtime/safe" "0" "%%fx=" "if" "n" "s")}
      {Lisp-Entry "f-module-block/runtime/notsafe" define #f 114 9 114 39 ("1" "%%fx-" "g-module-block/runtime/notsafe" "0" "%%fx=" "if" "n" "s")}
      {Lisp-Entry "g-module-block/runtime/notsafe" define #f 120 9 120 39 ("1" "%%fx-" "f-module-block/runtime/notsafe" "0" "%%fx=" "if" "n" "s")}
      {Lisp-Entry "f-module" define #f 137 9 137 17 ("1" "%%fx-" "g-module" "0" "%%fx=" "if" "n" "s")}
      {Lisp-Entry "g-module" define #f 143 9 143 17 ("1" "%%fx-" "f-module" "0" "%%fx=" "if" "n" "s")}
      {Lisp-Entry "X" define-class #f 160 19 160 20 ("allocate-x" "jazz.Object-Class" "jazz.Object")}
      {Lisp-Entry "X" define-class #f 163 27 163 28 ()}
      {Lisp-Entry "new-x" define #f 168 9 168 14 ("X" "allocate-x")}
      {Lisp-Entry "f-generic" define-generic/specific ("X") 172 22 172 31 ("n")}
      {Lisp-Entry "f-generic" define-generic/specific ("X") 174 23 174 32 ("1" "%%fx-" "x" "g-generic" "0" "%%fx=" "if" "n")}
      {Lisp-Entry "g-generic" define-generic/specific ("X") 180 22 180 31 ("n")}
      {Lisp-Entry "g-generic" define-generic/specific ("X") 182 23 182 32 ("1" "%%fx-" "x" "f-generic" "0" "%%fx=" "if" "n")}
      {Lisp-Entry "Z" define-class #f 193 27 193 28 ()}
      {Lisp-Entry "f-vtable" define-generic/specific ("Z~virtual-runtime") 196 30 196 38 ("n")}
      {Lisp-Entry "g-vtable" define-generic/specific ("Z~virtual-runtime") 197 30 197 38 ("n")}
      {Lisp-Entry "new-z" define #f 200 9 200 14 ("Z" "allocate-z")}
      {Lisp-Entry "f-vtable" define-generic/specific ("Z") 204 21 204 29 ("1" "%%fx-" "z" "g-vtable" "0" "%%fx=" "if" "n")}
      {Lisp-Entry "g-vtable" define-generic/specific ("Z") 210 21 210 29 ("1" "%%fx-" "z" "f-vtable" "0" "%%fx=" "if" "n")}
      {Lisp-Entry "W" define-class #f 219 27 219 28 ()}
      {Lisp-Entry "f-vtable" define-generic/specific ("W") 222 21 222 29 ("n")}
      {Lisp-Entry "h" define-generic/specific ("W~virtual-runtime") 226 30 226 31 ()}
      {Lisp-Entry "h" define-generic/specific ("W") 229 21 229 22 ()}}})
"continuation"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "dialect" "core" "continuation.scm"} 1238328026
    {Lisp-Entry "jazz.dialect.core.continuation" module #f 37 18 37 48 ()
      {Lisp-Entry "jazz.continuation?" define #f 42 13 42 31 ("%%continuation?" "obj")}
      {Lisp-Entry "jazz.continuation-capture" define #f 46 13 46 38 ("%%continuation-capture" "proc")}
      {Lisp-Entry "jazz.continuation-graft" define #f 50 13 50 36 ("%%continuation-graft" "proc" "cont")}
      {Lisp-Entry "jazz.continuation-return" define #f 54 12 54 36 ("continuation-return")}}})
"core"
 ({Lisp-File-Entry {File jazz "src" "jazz" "dialect" "walker" "core.jazz"} 1252768922
    {Lisp-Entry "jazz.dialect.walker.core" library #f 37 19 37 43 ("jazz.dialect")
      {Lisp-Entry "Walk-Binding" class #f 52 7 52 19 ("Type")}
      {Lisp-Entry "walk-binding-lookup" native #f 55 15 55 39 ()}
      {Lisp-Entry "walk-binding-referenced" native #f 56 15 56 43 ()}
      {Lisp-Entry "emit-binding-reference" native #f 57 15 57 42 ()}
      {Lisp-Entry "walk-binding-validate-call" native #f 58 15 58 46 ()}
      {Lisp-Entry "emit-binding-call" native #f 59 15 59 37 ()}
      {Lisp-Entry "emit-inlined-binding-call" native #f 60 15 60 45 ()}
      {Lisp-Entry "walk-binding-validate-assignment" native #f 61 15 61 52 ()}
      {Lisp-Entry "walk-binding-assignable?" native #f 62 15 62 44 ()}
      {Lisp-Entry "emit-binding-assignment" native #f 63 15 63 43 ()}
      {Lisp-Entry "walk-binding-walkable?" native #f 64 15 64 42 ()}
      {Lisp-Entry "walk-binding-walk-form" native #f 65 15 65 42 ()}
      {Lisp-Entry "walk-binding-expandable?" native #f 66 15 66 44 ()}
      {Lisp-Entry "walk-binding-expand-form" native #f 67 15 67 44 ()}
      {Lisp-Entry "Lexical-Binding" class #f 75 7 75 22 ("Walk-Binding")
        {Lisp-Entry "name" slot #f 78 8 78 12 ()}
        {Lisp-Entry "get-name" accessor #f 78 20 78 28 ()}
        {Lisp-Entry "type" slot #f 79 8 79 12 ()}
        {Lisp-Entry "get-type" accessor #f 79 20 79 28 ()}
        {Lisp-Entry "hits" slot #f 80 8 80 12 ()}
        {Lisp-Entry "get-hits" accessor #f 80 23 80 31 ()}
        {Lisp-Entry "set-hits" accessor #f 80 23 80 31 ()}
        {Lisp-Entry "print" method #f 83 11 83 16 ("get-name" "format" "function" "self" "print-unreadable" "detail" "output")}}
      {Lisp-Entry "resolve-binding" native #f 89 15 89 35 ()}
      {Lisp-Entry "Declaration" class #f 97 7 97 18 ("Lexical-Binding")
        {Lisp-Entry "access" slot #f 100 8 100 14 ()}
        {Lisp-Entry "get-access" accessor #f 100 29 100 37 ()}
        {Lisp-Entry "compatibility" slot #f 101 8 101 21 ()}
        {Lisp-Entry "get-compatibility" accessor #f 101 29 101 37 ()}
        {Lisp-Entry "attributes" slot #f 102 8 102 18 ()}
        {Lisp-Entry "get-attributes" accessor #f 102 29 102 37 ()}
        {Lisp-Entry "toplevel" slot #f 103 8 103 16 ()}
        {Lisp-Entry "get-toplevel" accessor #f 103 29 103 37 ()}
        {Lisp-Entry "parent" slot #f 104 8 104 14 ()}
        {Lisp-Entry "get-parent" accessor #f 104 29 104 37 ()}
        {Lisp-Entry "locator" slot #f 105 8 105 15 ()}
        {Lisp-Entry "get-locator" accessor #f 105 29 105 37 ()}
        {Lisp-Entry "source" slot #f 106 8 106 14 ()}
        {Lisp-Entry "get-source" accessor #f 106 29 106 37 ()}}
      {Lisp-Entry "lookup-declaration" native #f 109 15 109 38 ()}
      {Lisp-Entry "update-declaration" native #f 110 15 110 38 ()}
      {Lisp-Entry "get-declaration-inclusions" native #f 111 15 111 46 ()}
      {Lisp-Entry "emit-declaration" native #f 112 15 112 36 ()}
      {Lisp-Entry "expand-referenced-declaration" native #f 113 15 113 49 ()}
      {Lisp-Entry "fold-statement" native #f 114 15 114 34 ()}
      {Lisp-Entry "fold-declaration" native #f 115 15 115 36 ()}
      {Lisp-Entry "fold-expression" native #f 116 15 116 35 ()}
      {Lisp-Entry "private-access" native #f 117 15 117 34 ()}
      {Lisp-Entry "public-access" native #f 118 15 118 33 ()}
      {Lisp-Entry "protected-access" native #f 119 15 119 36 ()}
      {Lisp-Entry "Declaration-Reference" class #f 127 7 127 28 ("Object")
        {Lisp-Entry "name" slot #f 130 8 130 12 ()}
        {Lisp-Entry "get-name" accessor #f 130 27 130 35 ()}
        {Lisp-Entry "declaration" slot #f 131 8 131 19 ()}
        {Lisp-Entry "get-declaration" accessor #f 131 27 131 35 ()}}
      {Lisp-Entry "resolve-reference" native #f 134 15 134 37 ()}
      {Lisp-Entry "Library-Reference" class #f 142 7 142 24 ("Declaration-Reference")}
      {Lisp-Entry "Export-Reference" class #f 150 7 150 23 ("Declaration-Reference")
        {Lisp-Entry "library-reference" slot #f 153 8 153 25 ()}
        {Lisp-Entry "get-library-reference" accessor #f 153 33 153 41 ()}}
      {Lisp-Entry "Autoload-Reference" class #f 161 7 161 25 ("Export-Reference")}
      {Lisp-Entry "Module-Declaration" class #f 169 7 169 25 ("Declaration")
        {Lisp-Entry "requires" slot #f 172 8 172 16 ()}
        {Lisp-Entry "get-requires" accessor #f 172 24 172 32 ()}}
      {Lisp-Entry "Namespace-Declaration" class #f 180 7 180 28 ("Declaration")
        {Lisp-Entry "lookups" slot #f 183 8 183 15 ()}
        {Lisp-Entry "get-lookups" accessor #f 183 24 183 32 ()}
        {Lisp-Entry "children" slot #f 184 8 184 16 ()}
        {Lisp-Entry "get-children" accessor #f 184 24 184 32 ()}
        {Lisp-Entry "body" slot #f 185 8 185 12 ()}
        {Lisp-Entry "get-body" accessor #f 185 24 185 32 ()}}
      {Lisp-Entry "%%get-access-lookup" native #f 188 15 188 34 ()}
      {Lisp-Entry "Library-Declaration" class #f 196 7 196 26 ("Namespace-Declaration")
        {Lisp-Entry "walker" slot #f 199 8 199 14 ()}
        {Lisp-Entry "get-walker" accessor #f 199 31 199 39 ()}
        {Lisp-Entry "dialect-name" slot #f 200 8 200 20 ()}
        {Lisp-Entry "get-dialect-name" accessor #f 200 31 200 39 ()}
        {Lisp-Entry "dialect-invoice" slot #f 201 8 201 23 ()}
        {Lisp-Entry "get-dialect-invoice" accessor #f 201 31 201 39 ()}
        {Lisp-Entry "requires" slot #f 202 8 202 16 ()}
        {Lisp-Entry "get-requires" accessor #f 202 31 202 39 ()}
        {Lisp-Entry "exports" slot #f 203 8 203 15 ()}
        {Lisp-Entry "get-exports" accessor #f 203 31 203 39 ()}
        {Lisp-Entry "imports" slot #f 204 8 204 15 ()}
        {Lisp-Entry "get-imports" accessor #f 204 31 204 39 ()}
        {Lisp-Entry "proclaims" slot #f 205 8 205 17 ()}
        {Lisp-Entry "get-proclaims" accessor #f 205 31 205 39 ()}
        {Lisp-Entry "literals" slot #f 206 8 206 16 ()}
        {Lisp-Entry "get-literals" accessor #f 206 31 206 39 ()}
        {Lisp-Entry "variables" slot #f 207 8 207 17 ()}
        {Lisp-Entry "get-variables" accessor #f 207 31 207 39 ()}
        {Lisp-Entry "references" slot #f 208 8 208 18 ()}
        {Lisp-Entry "get-references" accessor #f 208 31 208 39 ()}
        {Lisp-Entry "inclusions" slot #f 209 8 209 18 ()}
        {Lisp-Entry "get-inclusions" accessor #f 209 31 209 39 ()}
        {Lisp-Entry "autoloads" slot #f 210 8 210 17 ()}
        {Lisp-Entry "get-autoloads" accessor #f 210 31 210 39 ()}}
      {Lisp-Entry "Library-Invoice" class #f 218 7 218 22 ("Object")
        {Lisp-Entry "name" slot #f 221 8 221 12 ()}
        {Lisp-Entry "get-name" accessor #f 221 23 221 31 ()}
        {Lisp-Entry "library" slot #f 222 8 222 15 ()}
        {Lisp-Entry "get-library" accessor #f 222 23 222 31 ()}
        {Lisp-Entry "phase" slot #f 223 8 223 13 ()}
        {Lisp-Entry "get-phase" accessor #f 223 23 223 31 ()}
        {Lisp-Entry "version" slot #f 224 8 224 15 ()}
        {Lisp-Entry "get-version" accessor #f 224 23 224 31 ()}
        {Lisp-Entry "only" slot #f 225 8 225 12 ()}
        {Lisp-Entry "get-only" accessor #f 225 23 225 31 ()}
        {Lisp-Entry "except" slot #f 226 8 226 14 ()}
        {Lisp-Entry "get-except" accessor #f 226 23 226 31 ()}
        {Lisp-Entry "prefix" slot #f 227 8 227 14 ()}
        {Lisp-Entry "get-prefix" accessor #f 227 23 227 31 ()}
        {Lisp-Entry "rename" slot #f 228 8 228 14 ()}
        {Lisp-Entry "get-rename" accessor #f 228 23 228 31 ()}
        {Lisp-Entry "print" method #f 231 11 231 16 ("name" "format" "function" "self" "print-unreadable" "readably" "printer")}}
      {Lisp-Entry "Export-Invoice" class #f 243 7 243 21 ("Library-Invoice")
        {Lisp-Entry "autoload" slot #f 246 8 246 16 ()}
        {Lisp-Entry "get-autoload" accessor #f 246 24 246 32 ()}}
      {Lisp-Entry "Import-Invoice" class #f 254 7 254 21 ("Library-Invoice")
        {Lisp-Entry "hit?" slot #f 257 8 257 12 ()}
        {Lisp-Entry "get-hit?" accessor #f 257 20 257 28 ()}}
      {Lisp-Entry "Export-Declaration" class #f 265 7 265 25 ("Declaration")
        {Lisp-Entry "symbol" slot #f 268 8 268 14 ()}
        {Lisp-Entry "get-symbol" accessor #f 268 22 268 30 ()}}
      {Lisp-Entry "Export-Syntax-Declaration" class #f 276 7 276 32 ("Declaration")
        {Lisp-Entry "symbol" slot #f 279 8 279 14 ()}
        {Lisp-Entry "get-symbol" accessor #f 279 22 279 30 ()}}
      {Lisp-Entry "Autoload-Declaration" class #f 287 7 287 27 ("Declaration")
        {Lisp-Entry "library" slot #f 290 8 290 15 ()}
        {Lisp-Entry "get-library" accessor #f 290 32 290 40 ()}
        {Lisp-Entry "exported-library" slot #f 291 8 291 24 ()}
        {Lisp-Entry "get-exported-library" accessor #f 291 32 291 40 ()}
        {Lisp-Entry "declaration" slot #f 292 8 292 19 ()}
        {Lisp-Entry "get-declaration" accessor #f 292 32 292 40 ()}}
      {Lisp-Entry "Literal" class #f 300 7 300 14 ("Object")
        {Lisp-Entry "name" slot #f 303 8 303 12 ()}
        {Lisp-Entry "get-name" accessor #f 303 25 303 33 ()}
        {Lisp-Entry "arguments" slot #f 304 8 304 17 ()}
        {Lisp-Entry "get-arguments" accessor #f 304 25 304 33 ()}}
      {Lisp-Entry "Macro-Declaration" class #f 312 7 312 24 ("Declaration")
        {Lisp-Entry "signature" slot #f 315 8 315 17 ()}
        {Lisp-Entry "get-signature" accessor #f 315 25 315 33 ()}
        {Lisp-Entry "body" slot #f 316 8 316 12 ()}
        {Lisp-Entry "get-body" accessor #f 316 25 316 33 ()}}
      {Lisp-Entry "Syntax-Declaration" class #f 324 7 324 25 ("Declaration")
        {Lisp-Entry "signature" slot #f 327 8 327 17 ()}
        {Lisp-Entry "get-signature" accessor #f 327 25 327 33 ()}
        {Lisp-Entry "body" slot #f 328 8 328 12 ()}
        {Lisp-Entry "get-body" accessor #f 328 25 328 33 ()}}
      {Lisp-Entry "Opt-Type" class #f 336 7 336 15 ("Type")
        {Lisp-Entry "type" slot #f 339 8 339 12 ()}
        {Lisp-Entry "get-type" accessor #f 339 20 339 28 ()}}
      {Lisp-Entry "Key-Type" class #f 347 7 347 15 ("Type")
        {Lisp-Entry "key" slot #f 350 8 350 11 ()}
        {Lisp-Entry "get-key" accessor #f 350 20 350 28 ()}
        {Lisp-Entry "type" slot #f 351 8 351 12 ()}
        {Lisp-Entry "get-type" accessor #f 351 20 351 28 ()}}
      {Lisp-Entry "Rest-Type" class #f 359 7 359 16 ("Type")
        {Lisp-Entry "type" slot #f 362 8 362 12 ()}
        {Lisp-Entry "get-type" accessor #f 362 20 362 28 ()}}
      {Lisp-Entry "Function-Type" class #f 370 7 370 20 ("Type")
        {Lisp-Entry "mandatory" slot #f 373 8 373 17 ()}
        {Lisp-Entry "get-mandatory" accessor #f 373 26 373 34 ()}
        {Lisp-Entry "positional" slot #f 374 8 374 18 ()}
        {Lisp-Entry "get-positional" accessor #f 374 26 374 34 ()}
        {Lisp-Entry "optional" slot #f 375 8 375 16 ()}
        {Lisp-Entry "get-optional" accessor #f 375 26 375 34 ()}
        {Lisp-Entry "named" slot #f 376 8 376 13 ()}
        {Lisp-Entry "get-named" accessor #f 376 26 376 34 ()}
        {Lisp-Entry "rest" slot #f 377 8 377 12 ()}
        {Lisp-Entry "get-rest" accessor #f 377 26 377 34 ()}
        {Lisp-Entry "result" slot #f 378 8 378 14 ()}
        {Lisp-Entry "get-result" accessor #f 378 26 378 34 ()}}
      {Lisp-Entry "Category-Type" class #f 386 7 386 20 ("Type")
        {Lisp-Entry "declaration" slot #f 389 8 389 19 ()}
        {Lisp-Entry "get-declaration" accessor #f 389 27 389 35 ()}}
      {Lisp-Entry "Values-Type" class #f 397 7 397 18 ("Type")
        {Lisp-Entry "types" slot #f 400 8 400 13 ()}
        {Lisp-Entry "get-types" accessor #f 400 21 400 29 ()}}
      {Lisp-Entry "Restriction-Type" class #f 408 7 408 23 ("Type")
        {Lisp-Entry "base" slot #f 411 8 411 12 ()}
        {Lisp-Entry "get-base" accessor #f 411 20 411 28 ()}
        {Lisp-Entry "type" slot #f 412 8 412 12 ()}
        {Lisp-Entry "get-type" accessor #f 412 20 412 28 ()}}
      {Lisp-Entry "Complement-Type" class #f 420 7 420 22 ("Type")
        {Lisp-Entry "type" slot #f 423 8 423 12 ()}
        {Lisp-Entry "get-type" accessor #f 423 20 423 28 ()}}
      {Lisp-Entry "Union-Type" class #f 431 7 431 17 ("Type")
        {Lisp-Entry "types" slot #f 434 8 434 13 ()}
        {Lisp-Entry "get-types" accessor #f 434 21 434 29 ()}}
      {Lisp-Entry "Template-Type" class #f 442 7 442 20 ("Type")
        {Lisp-Entry "class" slot #f 445 8 445 13 ()}
        {Lisp-Entry "get-class" accessor #f 445 21 445 29 ()}
        {Lisp-Entry "types" slot #f 446 8 446 13 ()}
        {Lisp-Entry "get-types" accessor #f 446 21 446 29 ()}}
      {Lisp-Entry "Nillable-Type" class #f 454 7 454 20 ("Type")
        {Lisp-Entry "type" slot #f 457 8 457 12 ()}
        {Lisp-Entry "get-type" accessor #f 457 20 457 28 ()}}
      {Lisp-Entry "C-Type-Declaration" class #f 465 7 465 25 ("Declaration")
        {Lisp-Entry "kind" slot #f 468 8 468 12 ()}
        {Lisp-Entry "get-kind" accessor #f 468 29 468 37 ()}
        {Lisp-Entry "expansion" slot #f 469 8 469 17 ()}
        {Lisp-Entry "get-expansion" accessor #f 469 29 469 37 ()}
        {Lisp-Entry "base-type" slot #f 470 8 470 17 ()}
        {Lisp-Entry "get-base-type" accessor #f 470 29 470 37 ()}
        {Lisp-Entry "pointer-types" slot #f 471 8 471 21 ()}
        {Lisp-Entry "get-pointer-types" accessor #f 471 29 471 37 ()}
        {Lisp-Entry "inclusions" slot #f 472 8 472 18 ()}
        {Lisp-Entry "get-inclusions" accessor #f 472 29 472 37 ()}
        {Lisp-Entry "c-to-scheme" slot #f 473 8 473 19 ()}
        {Lisp-Entry "get-c-to-scheme" accessor #f 473 29 473 37 ()}
        {Lisp-Entry "scheme-to-c" slot #f 474 8 474 19 ()}
        {Lisp-Entry "get-scheme-to-c" accessor #f 474 29 474 37 ()}
        {Lisp-Entry "declare" slot #f 475 8 475 15 ()}
        {Lisp-Entry "get-declare" accessor #f 475 29 475 37 ()}}
      {Lisp-Entry "C-Definition-Declaration" class #f 483 7 483 31 ("Declaration")
        {Lisp-Entry "signature" slot #f 486 8 486 17 ()}
        {Lisp-Entry "get-signature" accessor #f 486 31 486 39 ()}
        {Lisp-Entry "parameter-types" slot #f 487 8 487 23 ()}
        {Lisp-Entry "get-parameter-types" accessor #f 487 31 487 39 ()}
        {Lisp-Entry "result-type" slot #f 488 8 488 19 ()}
        {Lisp-Entry "get-result-type" accessor #f 488 31 488 39 ()}
        {Lisp-Entry "c-name" slot #f 489 8 489 14 ()}
        {Lisp-Entry "get-c-name" accessor #f 489 31 489 39 ()}
        {Lisp-Entry "scope" slot #f 490 8 490 13 ()}
        {Lisp-Entry "get-scope" accessor #f 490 31 490 39 ()}
        {Lisp-Entry "body" slot #f 491 8 491 12 ()}
        {Lisp-Entry "get-body" accessor #f 491 31 491 39 ()}}
      {Lisp-Entry "Dialect" class #f 499 7 499 14 ("Object")}
      {Lisp-Entry "Walker" class #f 507 7 507 13 ("Object")
        {Lisp-Entry "warnings" slot #f 510 8 510 16 ()}
        {Lisp-Entry "get-warnings" accessor #f 510 24 510 32 ()}
        {Lisp-Entry "errors" slot #f 511 8 511 14 ()}
        {Lisp-Entry "get-errors" accessor #f 511 24 511 32 ()}}
      {Lisp-Entry "walker-environment" native #f 514 15 514 38 ()}
      {Lisp-Entry "walk-declaration" native #f 515 15 515 36 ()}
      {Lisp-Entry "validate-access" native #f 516 15 516 35 ()}
      {Lisp-Entry "walk-free-reference" native #f 517 15 517 39 ()}
      {Lisp-Entry "walk-symbol-assignment" native #f 518 15 518 42 ()}
      {Lisp-Entry "walk-free-assignment" native #f 519 15 519 40 ()}
      {Lisp-Entry "walk-symbol" native #f 520 15 520 31 ()}
      {Lisp-Entry "walk-form" native #f 521 15 521 29 ()}
      {Lisp-Entry "validate-proclaim" native #f 522 15 522 37 ()}
      {Lisp-Entry "validate-arguments" native #f 523 15 523 38 ()}
      {Lisp-Entry "Walk-Context" class #f 531 7 531 19 ("Object")
        {Lisp-Entry "policy" slot #f 534 8 534 14 ()}
        {Lisp-Entry "get-policy" accessor #f 534 24 534 32 ()}
        {Lisp-Entry "locator" slot #f 535 8 535 15 ()}
        {Lisp-Entry "get-locator" accessor #f 535 24 535 32 ()}
        {Lisp-Entry "pathname" slot #f 536 8 536 16 ()}
        {Lisp-Entry "get-pathname" accessor #f 536 24 536 32 ()}}
      {Lisp-Entry "Walk-Location" class #f 544 15 544 28 ("Object")
        {Lisp-Entry "module-locator" slot #f 547 8 547 22 ()}
        {Lisp-Entry "get-module-locator" accessor #f 547 35 547 43 ()}
        {Lisp-Entry "declaration-locator" slot #f 548 8 548 27 ()}
        {Lisp-Entry "get-declaration-locator" accessor #f 548 35 548 43 ()}
        {Lisp-Entry "locat" slot #f 549 8 549 13 ()}
        {Lisp-Entry "get-locat" accessor #f 549 35 549 43 ()}
        {Lisp-Entry "initialize" method #f 552 11 552 21 ("locat~self" "declaration-locator~self" "module-locator~self" "set!" "nextmethod" "locat" "declaration-locator" "module-locator")}
        {Lisp-Entry "print" method #f 559 11 559 16 ("locat" "declaration-locator" "module-locator" "self" "class-of" "type-name" "identifier-name" "format" "readably" "printer")}}
      {Lisp-Entry "Walk-Problem" class #f 572 15 572 27 ("Error")
        {Lisp-Entry "location" slot #f 575 8 575 16 ()}
        {Lisp-Entry "get-location" accessor #f 575 24 575 32 ()}}
      {Lisp-Entry "Walk-Problems" class #f 583 15 583 28 ("Error")
        {Lisp-Entry "warnings" slot #f 586 8 586 16 ()}
        {Lisp-Entry "get-warnings" accessor #f 586 24 586 32 ()}
        {Lisp-Entry "errors" slot #f 587 8 587 14 ()}
        {Lisp-Entry "get-errors" accessor #f 587 24 587 32 ()}}
      {Lisp-Entry "Walk-Warning" class #f 595 15 595 27 ("Walk-Problem")}
      {Lisp-Entry "Walk-Error" class #f 603 15 603 25 ("Walk-Problem")}
      {Lisp-Entry "Unresolved-Error" class #f 611 15 611 31 ("Walk-Error")
        {Lisp-Entry "symbol" slot #f 614 8 614 14 ()}
        {Lisp-Entry "get-symbol" accessor #f 614 22 614 30 ()}}
      {Lisp-Entry "Walk-Frame" class #f 622 7 622 17 ("Walk-Binding")
        {Lisp-Entry "bindings" slot #f 625 8 625 16 ()}
        {Lisp-Entry "get-bindings" accessor #f 625 24 625 32 ()}}
      {Lisp-Entry "Signature" class #f 633 7 633 16 ("Object")
        {Lisp-Entry "mandatory" slot #f 636 8 636 17 ()}
        {Lisp-Entry "get-mandatory" accessor #f 636 26 636 34 ()}
        {Lisp-Entry "positional" slot #f 637 8 637 18 ()}
        {Lisp-Entry "get-positional" accessor #f 637 26 637 34 ()}
        {Lisp-Entry "optional" slot #f 638 8 638 16 ()}
        {Lisp-Entry "get-optional" accessor #f 638 26 638 34 ()}
        {Lisp-Entry "named" slot #f 639 8 639 13 ()}
        {Lisp-Entry "get-named" accessor #f 639 26 639 34 ()}
        {Lisp-Entry "rest" slot #f 640 8 640 12 ()}
        {Lisp-Entry "get-rest" accessor #f 640 26 640 34 ()}}
      {Lisp-Entry "Symbol-Binding" class #f 648 7 648 21 ("Lexical-Binding")}
      {Lisp-Entry "Variable" class #f 656 7 656 15 ("Symbol-Binding")
        {Lisp-Entry "reference-count" slot #f 659 8 659 23 ()}
        {Lisp-Entry "get-reference-count" accessor #f 659 31 659 39 ()}}
      {Lisp-Entry "NextMethod-Variable" class #f 667 7 667 26 ("Variable")}
      {Lisp-Entry "Parameter" class #f 675 7 675 16 ("Variable")}
      {Lisp-Entry "Dynamic-Parameter" class #f 683 7 683 24 ("Parameter")
        {Lisp-Entry "class" slot #f 686 8 686 13 ()}
        {Lisp-Entry "get-class" accessor #f 686 21 686 29 ()}}
      {Lisp-Entry "Optional-Parameter" class #f 694 7 694 25 ("Parameter")
        {Lisp-Entry "default" slot #f 697 8 697 15 ()}
        {Lisp-Entry "get-default" accessor #f 697 23 697 31 ()}}
      {Lisp-Entry "Named-Parameter" class #f 705 7 705 22 ("Parameter")
        {Lisp-Entry "default" slot #f 708 8 708 15 ()}
        {Lisp-Entry "get-default" accessor #f 708 23 708 31 ()}}
      {Lisp-Entry "Rest-Parameter" class #f 716 7 716 21 ("Parameter")}
      {Lisp-Entry "Dynamic-Self-Binding" class #f 724 7 724 27 ("Lexical-Binding")
        {Lisp-Entry "code" slot #f 727 8 727 12 ()}
        {Lisp-Entry "get-code" accessor #f 727 20 727 28 ()}}
      {Lisp-Entry "Local-Variable-Binding" class #f 735 7 735 29 ("Lexical-Binding")
        {Lisp-Entry "variable" slot #f 738 8 738 16 ()}
        {Lisp-Entry "get-variable" accessor #f 738 24 738 32 ()}}
      {Lisp-Entry "Macro-Symbol" class #f 746 7 746 19 ("Symbol-Binding")
        {Lisp-Entry "getter" slot #f 749 8 749 14 ()}
        {Lisp-Entry "get-getter" accessor #f 749 22 749 30 ()}
        {Lisp-Entry "setter" slot #f 750 8 750 14 ()}
        {Lisp-Entry "get-setter" accessor #f 750 22 750 30 ()}}
      {Lisp-Entry "Form-Binding" class #f 758 7 758 19 ("Lexical-Binding")}
      {Lisp-Entry "Special-Form" class #f 766 7 766 19 ("Form-Binding")
        {Lisp-Entry "walk" slot #f 769 8 769 12 ()}
        {Lisp-Entry "get-walk" accessor #f 769 20 769 28 ()}}
      {Lisp-Entry "Macro-Form" class #f 777 7 777 17 ("Form-Binding")
        {Lisp-Entry "expander" slot #f 780 8 780 16 ()}
        {Lisp-Entry "get-expander" accessor #f 780 24 780 32 ()}}
      {Lisp-Entry "Syntax-Form" class #f 788 7 788 18 ("Form-Binding")
        {Lisp-Entry "expander" slot #f 791 8 791 16 ()}
        {Lisp-Entry "get-expander" accessor #f 791 24 791 32 ()}}
      {Lisp-Entry "Annotated-Variable" class #f 799 7 799 25 ("Object")
        {Lisp-Entry "variable" slot #f 802 8 802 16 ()}
        {Lisp-Entry "get-variable" accessor #f 802 29 802 37 ()}
        {Lisp-Entry "declared-type" slot #f 803 8 803 21 ()}
        {Lisp-Entry "get-declared-type" accessor #f 803 29 803 37 ()}
        {Lisp-Entry "type" slot #f 804 8 804 12 ()}
        {Lisp-Entry "get-type" accessor #f 804 29 804 37 ()}}
      {Lisp-Entry "Restricted-Binding" class #f 812 7 812 25 ("Object")
        {Lisp-Entry "binding" slot #f 815 8 815 15 ()}
        {Lisp-Entry "get-binding" accessor #f 815 23 815 31 ()}
        {Lisp-Entry "type" slot #f 816 8 816 12 ()}
        {Lisp-Entry "get-type" accessor #f 816 23 816 31 ()}}
      {Lisp-Entry "Annotated-Frame" class #f 824 7 824 22 ("Object")
        {Lisp-Entry "variables" slot #f 827 8 827 17 ()}
        {Lisp-Entry "get-variables" accessor #f 827 25 827 33 ()}
        {Lisp-Entry "reset" slot #f 828 8 828 13 ()}
        {Lisp-Entry "get-reset" accessor #f 828 25 828 33 ()}}
      {Lisp-Entry "Code" class #f 836 7 836 11 ("Object")
        {Lisp-Entry "form" slot #f 839 8 839 12 ()}
        {Lisp-Entry "get-form" accessor #f 839 22 839 30 ()}
        {Lisp-Entry "type" slot #f 840 8 840 12 ()}
        {Lisp-Entry "get-type" accessor #f 840 22 840 30 ()}
        {Lisp-Entry "source" slot #f 841 8 841 14 ()}
        {Lisp-Entry "get-source" accessor #f 841 22 841 30 ()}}
      {Lisp-Entry "Access" class #f 849 7 849 13 ("Object")
        {Lisp-Entry "name" slot #f 852 8 852 12 ()}
        {Lisp-Entry "get-name" accessor #f 852 23 852 31 ()}
        {Lisp-Entry "context" slot #f 853 8 853 15 ()}
        {Lisp-Entry "get-context" accessor #f 853 23 853 31 ()}}
      {Lisp-Entry "Expression" class #f 861 7 861 17 ("Object")
        {Lisp-Entry "type" slot #f 864 8 864 12 ()}
        {Lisp-Entry "get-type" accessor #f 864 22 864 30 ()}
        {Lisp-Entry "source" slot #f 865 8 865 14 ()}
        {Lisp-Entry "get-source" accessor #f 865 22 865 30 ()}}
      {Lisp-Entry "emit-expression" native #f 868 15 868 35 ()}
      {Lisp-Entry "emit-call" native #f 869 15 869 29 ()}
      {Lisp-Entry "fold-expression" native #f 870 15 870 35 ()}
      {Lisp-Entry "Proclaim" class #f 878 7 878 15 ("Expression")
        {Lisp-Entry "clauses" slot #f 881 8 881 15 ()}
        {Lisp-Entry "get-clauses" accessor #f 881 23 881 31 ()}}
      {Lisp-Entry "Constant" class #f 889 7 889 15 ("Expression")
        {Lisp-Entry "expansion" slot #f 892 8 892 17 ()}
        {Lisp-Entry "get-expansion" accessor #f 892 25 892 33 ()}}
      {Lisp-Entry "Delay" class #f 900 7 900 12 ("Expression")
        {Lisp-Entry "expression" slot #f 903 8 903 18 ()}
        {Lisp-Entry "get-expression" accessor #f 903 26 903 34 ()}}
      {Lisp-Entry "Quasiquote" class #f 911 7 911 17 ("Expression")
        {Lisp-Entry "form" slot #f 914 8 914 12 ()}
        {Lisp-Entry "get-form" accessor #f 914 20 914 28 ()}}
      {Lisp-Entry "Reference" class #f 922 7 922 16 ("Expression")
        {Lisp-Entry "binding" slot #f 925 8 925 15 ()}
        {Lisp-Entry "get-binding" accessor #f 925 23 925 31 ()}
        {Lisp-Entry "print" method #f 928 11 928 16 ("binding" "format" "function" "self" "print-unreadable" "readably" "printer")}}
      {Lisp-Entry "Assignment" class #f 940 7 940 17 ("Expression")
        {Lisp-Entry "binding" slot #f 943 8 943 15 ()}
        {Lisp-Entry "get-binding" accessor #f 943 23 943 31 ()}
        {Lisp-Entry "value" slot #f 944 8 944 13 ()}
        {Lisp-Entry "get-value" accessor #f 944 23 944 31 ()}}
      {Lisp-Entry "Lambda" class #f 952 7 952 13 ("Expression")
        {Lisp-Entry "signature" slot #f 955 8 955 17 ()}
        {Lisp-Entry "get-signature" accessor #f 955 25 955 33 ()}
        {Lisp-Entry "body" slot #f 956 8 956 12 ()}
        {Lisp-Entry "get-body" accessor #f 956 25 956 33 ()}}
      {Lisp-Entry "Let" class #f 964 7 964 10 ("Expression")
        {Lisp-Entry "bindings" slot #f 967 8 967 16 ()}
        {Lisp-Entry "get-bindings" accessor #f 967 24 967 32 ()}
        {Lisp-Entry "body" slot #f 968 8 968 12 ()}
        {Lisp-Entry "get-body" accessor #f 968 24 968 32 ()}}
      {Lisp-Entry "Named-Let" class #f 976 7 976 16 ("Let")
        {Lisp-Entry "variable" slot #f 979 8 979 16 ()}
        {Lisp-Entry "get-variable" accessor #f 979 24 979 32 ()}}
      {Lisp-Entry "Letstar" class #f 987 7 987 14 ("Expression")
        {Lisp-Entry "bindings" slot #f 990 8 990 16 ()}
        {Lisp-Entry "get-bindings" accessor #f 990 24 990 32 ()}
        {Lisp-Entry "body" slot #f 991 8 991 12 ()}
        {Lisp-Entry "get-body" accessor #f 991 24 991 32 ()}}
      {Lisp-Entry "Letrec" class #f 999 7 999 13 ("Expression")
        {Lisp-Entry "bindings" slot #f 1002 8 1002 16 ()}
        {Lisp-Entry "get-bindings" accessor #f 1002 24 1002 32 ()}
        {Lisp-Entry "body" slot #f 1003 8 1003 12 ()}
        {Lisp-Entry "get-body" accessor #f 1003 24 1003 32 ()}}
      {Lisp-Entry "Receive" class #f 1011 7 1011 14 ("Expression")
        {Lisp-Entry "variables" slot #f 1014 8 1014 17 ()}
        {Lisp-Entry "get-variables" accessor #f 1014 26 1014 34 ()}
        {Lisp-Entry "expression" slot #f 1015 8 1015 18 ()}
        {Lisp-Entry "get-expression" accessor #f 1015 26 1015 34 ()}
        {Lisp-Entry "body" slot #f 1016 8 1016 12 ()}
        {Lisp-Entry "get-body" accessor #f 1016 26 1016 34 ()}}
      {Lisp-Entry "Body" class #f 1024 7 1024 11 ("Expression")
        {Lisp-Entry "internal-defines" slot #f 1027 8 1027 24 ()}
        {Lisp-Entry "get-internal-defines" accessor #f 1027 32 1027 40 ()}
        {Lisp-Entry "expressions" slot #f 1028 8 1028 19 ()}
        {Lisp-Entry "get-expressions" accessor #f 1028 32 1028 40 ()}}
      {Lisp-Entry "Internal-Define" class #f 1036 7 1036 22 ("Expression")
        {Lisp-Entry "variable" slot #f 1039 8 1039 16 ()}
        {Lisp-Entry "get-variable" accessor #f 1039 24 1039 32 ()}
        {Lisp-Entry "value" slot #f 1040 8 1040 13 ()}
        {Lisp-Entry "get-value" accessor #f 1040 24 1040 32 ()}}
      {Lisp-Entry "Begin" class #f 1048 7 1048 12 ("Expression")
        {Lisp-Entry "expressions" slot #f 1051 8 1051 19 ()}
        {Lisp-Entry "get-expressions" accessor #f 1051 27 1051 35 ()}}
      {Lisp-Entry "Do" class #f 1059 7 1059 9 ("Expression")
        {Lisp-Entry "bindings" slot #f 1062 8 1062 16 ()}
        {Lisp-Entry "get-bindings" accessor #f 1062 24 1062 32 ()}
        {Lisp-Entry "test" slot #f 1063 8 1063 12 ()}
        {Lisp-Entry "get-test" accessor #f 1063 24 1063 32 ()}
        {Lisp-Entry "result" slot #f 1064 8 1064 14 ()}
        {Lisp-Entry "get-result" accessor #f 1064 24 1064 32 ()}
        {Lisp-Entry "body" slot #f 1065 8 1065 12 ()}
        {Lisp-Entry "get-body" accessor #f 1065 24 1065 32 ()}}
      {Lisp-Entry "Call" class #f 1073 7 1073 11 ("Expression")
        {Lisp-Entry "operator" slot #f 1076 8 1076 16 ()}
        {Lisp-Entry "get-operator" accessor #f 1076 25 1076 33 ()}
        {Lisp-Entry "arguments" slot #f 1077 8 1077 17 ()}
        {Lisp-Entry "get-arguments" accessor #f 1077 25 1077 33 ()}}
      {Lisp-Entry "If" class #f 1085 7 1085 9 ("Expression")
        {Lisp-Entry "test" slot #f 1088 8 1088 12 ()}
        {Lisp-Entry "get-test" accessor #f 1088 20 1088 28 ()}
        {Lisp-Entry "yes" slot #f 1089 8 1089 11 ()}
        {Lisp-Entry "get-yes" accessor #f 1089 20 1089 28 ()}
        {Lisp-Entry "no" slot #f 1090 8 1090 10 ()}
        {Lisp-Entry "get-no" accessor #f 1090 20 1090 28 ()}}
      {Lisp-Entry "Cond" class #f 1098 7 1098 11 ("Expression")
        {Lisp-Entry "clauses" slot #f 1101 8 1101 15 ()}
        {Lisp-Entry "get-clauses" accessor #f 1101 23 1101 31 ()}}
      {Lisp-Entry "Case" class #f 1109 7 1109 11 ("Expression")
        {Lisp-Entry "target" slot #f 1112 8 1112 14 ()}
        {Lisp-Entry "get-target" accessor #f 1112 23 1112 31 ()}
        {Lisp-Entry "clauses" slot #f 1113 8 1113 15 ()}
        {Lisp-Entry "get-clauses" accessor #f 1113 23 1113 31 ()}}
      {Lisp-Entry "And" class #f 1121 7 1121 10 ("Expression")
        {Lisp-Entry "expressions" slot #f 1124 8 1124 19 ()}
        {Lisp-Entry "get-expressions" accessor #f 1124 27 1124 35 ()}}
      {Lisp-Entry "Or" class #f 1132 7 1132 9 ("Expression")
        {Lisp-Entry "expressions" slot #f 1135 8 1135 19 ()}
        {Lisp-Entry "get-expressions" accessor #f 1135 27 1135 35 ()}}
      {Lisp-Entry "Declare" class #f 1143 7 1143 14 ("Expression")
        {Lisp-Entry "declarations" slot #f 1146 8 1146 20 ()}
        {Lisp-Entry "get-declarations" accessor #f 1146 28 1146 36 ()}}
      {Lisp-Entry "C-Include" class #f 1154 7 1154 16 ("Expression")
        {Lisp-Entry "name" slot #f 1157 8 1157 12 ()}
        {Lisp-Entry "get-name" accessor #f 1157 20 1157 28 ()}}
      {Lisp-Entry "C-Declare" class #f 1165 7 1165 16 ("Expression")
        {Lisp-Entry "code" slot #f 1168 8 1168 12 ()}
        {Lisp-Entry "get-code" accessor #f 1168 20 1168 28 ()}}
      {Lisp-Entry "C-Named-Declare-Declaration" class #f 1176 7 1176 34 ("Declaration")
        {Lisp-Entry "code" slot #f 1179 8 1179 12 ()}
        {Lisp-Entry "get-code" accessor #f 1179 20 1179 28 ()}}
      {Lisp-Entry "C-Initialize" class #f 1187 7 1187 19 ("Expression")
        {Lisp-Entry "code" slot #f 1190 8 1190 12 ()}
        {Lisp-Entry "get-code" accessor #f 1190 20 1190 28 ()}}
      {Lisp-Entry "C-Function" class #f 1198 7 1198 17 ("Expression")
        {Lisp-Entry "expansion" slot #f 1201 8 1201 17 ()}
        {Lisp-Entry "get-expansion" accessor #f 1201 25 1201 33 ()}}
      {Lisp-Entry "Parameterize" class #f 1209 7 1209 19 ("Expression")
        {Lisp-Entry "bindings" slot #f 1212 8 1212 16 ()}
        {Lisp-Entry "get-bindings" accessor #f 1212 24 1212 32 ()}
        {Lisp-Entry "body" slot #f 1213 8 1213 12 ()}
        {Lisp-Entry "get-body" accessor #f 1213 24 1213 32 ()}}
      {Lisp-Entry "Time-Special" class #f 1221 7 1221 19 ("Expression")
        {Lisp-Entry "expression" slot #f 1224 8 1224 18 ()}
        {Lisp-Entry "get-expression" accessor #f 1224 26 1224 34 ()}}
      {Lisp-Entry "Core-Dialect" class #f 1232 7 1232 19 ("Dialect")}
      {Lisp-Entry "Core-Walker" class #f 1240 7 1240 18 ("Walker")}}})
"debug"
 ({Lisp-File-Entry {File jazz "src" "jazz" "dialect" "language" "debug.jazz"} 1252923643
    {Lisp-Entry "jazz.dialect.language.debug" library #f 37 19 37 46 ("get-console-port" ":console" "register-printer" "jazz.dialect")
      {Lisp-Entry "*console-port-getter*" definition #f 53 12 53 33 ()}
      {Lisp-Entry "set-console-port-getter" definition #f 57 20 57 43 ("*console-port-getter*" "set!" "getter")}
      {Lisp-Entry "get-console-port" definition #f 61 20 61 36 ("terminal-port" "*console-port-getter*" "not" "if")}
      {Lisp-Entry "console-input-port" definition #f 67 20 67 38 ("get-console-port")}
      {Lisp-Entry "console-output-port" definition #f 70 20 70 39 ("get-console-port")}
      {Lisp-Entry "force-console" definition #f 74 20 74 33 ("get-console-port" "force-output")}
      {Lisp-Entry "console" definition #f 86 20 86 27 ("format" "console-string" "rest")}
      {Lisp-Entry "console-string" definition #f 90 20 90 34 ("force-output" "format" "terminal-string" "not" "if" "console-output-port" "output" "let" "color" "color:" "string")}
      {Lisp-Entry "debug" definition #f 103 19 103 24 ("console")}
      {Lisp-Entry "debug-string" definition #f 107 19 107 31 ("console-string")}
      {Lisp-Entry "continuation-stack" definition #f 116 20 116 38 ("get-continuation-dynamic-environment" "append" "else" "get-continuation-lexical-environment" "cons" "not" "and" "cond" "get-continuation-name" "name" "function" "map" "get-continuation-stack" "stack" "let" "depth" "depth:" "lexical-environment?" "lexical-environment?:" "dynamic-environment?" "dynamic-environment?:" "cont")}
      {Lisp-Entry "execution-stack" definition #f 130 20 130 35 ("continuation-stack" "cont" "function" "continuation-capture" "depth" "depth:" "lexical-environment?" "lexical-environment?:" "dynamic-environment?" "dynamic-environment?:")}}}
  {Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "dialect" "core" "debug.scm"} 1248273219
    {Lisp-Entry "jazz.dialect.core.debug" module #f 37 18 37 41 ()
      {Lisp-Entry "inspect" define #f 41 9 41 16 ("jazz.serial->object" "integer?" "if" "jazz.inspect-object" "obj")}
      {Lisp-Entry "run-loop" define #f 46 9 46 17 ("jazz.system.process.Process.Process.run-loop" "'jazz.system.process.Process.Process.run-loop" "run-loop" "jazz.system.access.get-process" "'jazz.system.access.get-process" "jazz.global-value" "get-process" "let")}
      {Lisp-Entry "resume" define #f 53 9 53 15 ("jazz.system.process.Process.Process.resume-loop" "'jazz.system.process.Process.Process.resume-loop" "resume-loop" "jazz.system.access.get-process" "'jazz.system.access.get-process" "jazz.global-value" "get-process" "let")}}})
"declares"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "test" "performance" "declares.scm"} 1237033585
    {Lisp-Entry "f-run-time-bindings/safe" define #f 3 9 3 33 ("car" "x")}
    {Lisp-Entry "f-not-run-time-bindings/safe" define #f 10 9 10 37 ("car" "x")}
    {Lisp-Entry "f-run-time-bindings/not-safe" define #f 17 9 17 37 ("car" "x")}
    {Lisp-Entry "f-not-run-time-bindings/not-safe" define #f 24 9 24 41 ("car" "x")}
    {Lisp-Entry "f-standard-bindings/not-run-time-bindings/not-safe" define #f 32 9 32 59 ("##pair?" "car" "x")}
    {Lisp-Entry "f-standard-bindings/run-time-bindings/not-safe" define #f 41 9 41 55 ("##pair?" "car" "x")}
    {Lisp-Entry "f-standard-bindings/extended-bindings/not-safe" define #f 50 9 50 55 ("##pair?" "car" "x")}
    {Lisp-Entry "f-block" define #f 57 9 57 16 ("g-block")}
    {Lisp-Entry "g-block" define #f 60 9 60 16 ("f-block")}
    {Lisp-Entry "f-separate" define #f 66 9 66 19 ("g-separate")}
    {Lisp-Entry "g-separate" define #f 69 9 69 19 ("f-separate")}})
"development"
 ({Lisp-File-Entry {File jazz "src" "jazz" "development.jazz"} 1251042041
    {Lisp-Entry "jazz.development" library #f 37 9 37 25 ("jazz")
      {Lisp-Entry "iter-list" definition #f 55 13 55 22 ("cdr" "iter-list" "car" "when" "proc" "lst")}
      {Lisp-Entry "iter-node" definition #f 61 13 61 22 ("get-children" "for-each" "function" "iter" "letrec" "proc" "node")}
      {Lisp-Entry "iter" definition #f 69 13 69 17 ("iter-node" "JML-Node" "is?" "iter-list" "null/pair?" "cond" "proc" "obj")}
      {Lisp-Entry "foldl-list" definition #f 74 13 74 23 ("car" "cdr" "foldl-list" "not" "if" "s" "f" "x")}
      {Lisp-Entry "foldr-list" definition #f 80 13 80 23 ("cdr" "foldr-list" "car" "not" "if" "s" "f" "x")}
      {Lisp-Entry "foldl-node" definition #f 86 13 86 23 ("foldl-node" "c" "function" "get-children" "foldl" "s" "f" "x")}
      {Lisp-Entry "foldr-node" definition #f 93 13 93 23 ("s" "f" "x")}
      {Lisp-Entry "foldl-component" definition #f 97 13 97 28 ("foldl-component" "c" "function" "get-children" "foldl" "s" "f" "x")}
      {Lisp-Entry "foldr-component" definition #f 104 13 104 28 ("s" "f" "x")}
      {Lisp-Entry "foldl" definition #f 108 13 108 18 ("foldl-component" "Component" "foldl-node" "JML-Node" "is?" "foldl-list" "null/pair?" "cond" "s" "f" "x")}
      {Lisp-Entry "foldr" definition #f 114 13 114 18 ("foldr-component" "Component" "foldr-node" "JML-Node" "is?" "foldr-list" "null/pair?" "cond" "s" "f" "x")}
      {Lisp-Entry "iter-map" definition #f 120 13 120 21 ("get-output" "put" "x" "function" "iter" "List-Factory" "new" "fact" "let" "obj" "proc")}
      {Lisp-Entry "iter-linearize" definition #f 128 13 128 27 ("identity" "iter-map" "obj")}
      {Lisp-Entry "fold-map" definition #f 132 13 132 21 ("cons" "lst" "x" "function" "foldr" "obj" "proc")}
      {Lisp-Entry "foldl-map" definition #f 139 13 139 22 ("cons" "lst" "x" "function" "foldl" "obj" "proc")}
      {Lisp-Entry "fold-linearize" definition #f 146 13 146 27 ("identity" "fold-map" "obj")}
      {Lisp-Entry "fold" definition #f 150 20 150 24 ("fold-component" "Component" "fold-node" "JML-Node" "is?" "foldl-list" "null/pair?" "cond" "s" "f" "x")}
      {Lisp-Entry "fold-node" definition #f 156 13 156 22 ("get-children" "fold-node" "c" "function" "for-each" "ps" "let" "s" "f" "x")}
      {Lisp-Entry "fold-component" definition #f 164 13 164 27 ("get-children" "fold-component" "c" "function" "for-each" "ps" "let" "s" "f" "x")}
      {Lisp-Entry "component->jml" definition #f 172 20 172 34 ("component-self->jml" "fold" "x")}
      {Lisp-Entry "component-self->jml" definition #f 178 13 178 32 ("object->serial" "serial" "'serial" "get-size" "size" "'size" "get-position" "jazz.ui.layout.Figure.Figure" "'jazz.ui.layout.Figure.Figure" "typed?" "essay" "position" "'position" "get-name" "name" "'name" "list" "properties:" "class-of" "type-name" "identifier-name" "JML-Element" "new" "p" "c")}
      {Lisp-Entry "component-ascendants->jml" definition #f 188 13 188 38 ("find-toplevel" "if" "get-parent" "parent" "let" "component-self->jml" "component->jml" "define" "c")}
      {Lisp-Entry "pprint-component" definition #f 204 20 204 36 (":console" "component->jml" "pretty-print" "x")}
      {Lisp-Entry "pprint-component-ascendants" definition #f 210 20 210 47 (":console" "component-ascendants->jml" "pretty-print" "x")}
      {Lisp-Entry "ppd" definition #f 221 20 221 23 ("unspecified" "pprint-component" "c")}
      {Lisp-Entry "ppa" definition #f 226 20 226 23 ("unspecified" "pprint-component-ascendants" "c")}
      {Lisp-Entry "hex" definition #f 236 20 236 23 ("format" "n")}}}
  {Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "dialect" "core" "development.scm"} 1248276859
    {Lisp-Entry "jazz.dialect.core.development" module #f 37 18 37 47 ()
      {Lisp-Entry "jazz.define-global" define-macro #f 45 20 45 38 ("set!" ",value" ",setter" ",getter" ",name" "define" "begin" "jazz.generate-symbol" "value" "setter" "%%symbol->string" "%%string-append" "%%string->symbol" "getter" "let" "name")}
      {Lisp-Entry "?" define-macro #f 63 20 63 21 ()}
      {Lisp-Entry "%" define-macro #f 64 20 64 21 ()}
      {Lisp-Entry "?a" define-macro #f 67 20 67 22 ()}
      {Lisp-Entry "?b" define-macro #f 68 20 68 22 ()}
      {Lisp-Entry "?c" define-macro #f 69 20 69 22 ()}
      {Lisp-Entry "?d" define-macro #f 70 20 70 22 ()}
      {Lisp-Entry "?e" define-macro #f 71 20 71 22 ()}
      {Lisp-Entry "?f" define-macro #f 72 20 72 22 ()}
      {Lisp-Entry "?g" define-macro #f 73 20 73 22 ()}
      {Lisp-Entry "?h" define-macro #f 74 20 74 22 ()}
      {Lisp-Entry "?i" define-macro #f 75 20 75 22 ()}
      {Lisp-Entry "?j" define-macro #f 76 20 76 22 ()}
      {Lisp-Entry "?k" define-macro #f 77 20 77 22 ()}
      {Lisp-Entry "?l" define-macro #f 78 20 78 22 ()}
      {Lisp-Entry "?m" define-macro #f 79 20 79 22 ()}
      {Lisp-Entry "?n" define-macro #f 80 20 80 22 ()}
      {Lisp-Entry "?o" define-macro #f 81 20 81 22 ()}
      {Lisp-Entry "?p" define-macro #f 82 20 82 22 ()}
      {Lisp-Entry "?q" define-macro #f 83 20 83 22 ()}
      {Lisp-Entry "?r" define-macro #f 84 20 84 22 ()}
      {Lisp-Entry "?s" define-macro #f 85 20 85 22 ()}
      {Lisp-Entry "?t" define-macro #f 86 20 86 22 ()}
      {Lisp-Entry "?u" define-macro #f 87 20 87 22 ()}
      {Lisp-Entry "?v" define-macro #f 88 20 88 22 ()}
      {Lisp-Entry "?w" define-macro #f 89 20 89 22 ()}
      {Lisp-Entry "?x" define-macro #f 90 20 90 22 ()}
      {Lisp-Entry "?y" define-macro #f 91 20 91 22 ()}
      {Lisp-Entry "?z" define-macro #f 92 20 92 22 ()}
      {Lisp-Entry "%a" define-macro #f 95 20 95 22 ()}
      {Lisp-Entry "%b" define-macro #f 96 20 96 22 ()}
      {Lisp-Entry "%c" define-macro #f 97 20 97 22 ()}
      {Lisp-Entry "%d" define-macro #f 98 20 98 22 ()}
      {Lisp-Entry "%e" define-macro #f 99 20 99 22 ()}
      {Lisp-Entry "%f" define-macro #f 100 20 100 22 ()}
      {Lisp-Entry "%g" define-macro #f 101 20 101 22 ()}
      {Lisp-Entry "%h" define-macro #f 102 20 102 22 ()}
      {Lisp-Entry "%i" define-macro #f 103 20 103 22 ()}
      {Lisp-Entry "%j" define-macro #f 104 20 104 22 ()}
      {Lisp-Entry "%k" define-macro #f 105 20 105 22 ()}
      {Lisp-Entry "%l" define-macro #f 106 20 106 22 ()}
      {Lisp-Entry "%m" define-macro #f 107 20 107 22 ()}
      {Lisp-Entry "%n" define-macro #f 108 20 108 22 ()}
      {Lisp-Entry "%o" define-macro #f 109 20 109 22 ()}
      {Lisp-Entry "%p" define-macro #f 110 20 110 22 ()}
      {Lisp-Entry "%q" define-macro #f 111 20 111 22 ()}
      {Lisp-Entry "%r" define-macro #f 112 20 112 22 ()}
      {Lisp-Entry "%s" define-macro #f 113 20 113 22 ()}
      {Lisp-Entry "%t" define-macro #f 114 20 114 22 ()}
      {Lisp-Entry "%u" define-macro #f 115 20 115 22 ()}
      {Lisp-Entry "%v" define-macro #f 116 20 116 22 ()}
      {Lisp-Entry "%w" define-macro #f 117 20 117 22 ()}
      {Lisp-Entry "%x" define-macro #f 118 20 118 22 ()}
      {Lisp-Entry "%y" define-macro #f 119 20 119 22 ()}
      {Lisp-Entry "%z" define-macro #f 120 20 120 22 ()}}})
"dialect"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "dialect" "dialect.scm"} 1253398111
    {Lisp-Entry "jazz.dialect.dialect" module #f 37 18 37 38 ("jazz.dialect" "'jazz.dialect" "jazz" "'jazz" "jazz.register-dialect" "jazz.new-jazz-dialect" "dialect" "jazz.Jazz-Walker" "jazz.Dispatch" "jazz.Construct" "jazz.Cast" "jazz.With-Dynamic-Self" "jazz.With-Self" "jazz.new" "jazz.new2" "2" "jazz.new1" "1" "jazz.codes-forms" "jazz.new0" "0" "%%length" "jazz.new-code" "values-codes" "jazz.Autoload-Declaration" "or" "%%get-reference-binding" "binding" "jazz.Reference" "class-expression" "let" "jazz.dialect.kernel.new" "'jazz.dialect.kernel.new" "%%eq?" "if" "declaration" "arguments-codes" "operator" "jazz.emit-primitive-new-call" "else" "%%car" "jazz.emit-specialized-class-of" "%%cdr" "%%null?" "%%pair?" "%%assert" "jazz.dialect.kernel.class-of" "case" "environment" "arguments" "locator" "jazz.emit-specialized-locator" "jazz.Jazz-Dialect" "jazz.Method-Declaration" "jazz.Property-Declaration" "jazz.Slot-Declaration" "jazz.Field-Declaration" "jazz.Interface-Declaration" "%%get-class-declaration-ascendant" "%%not" "%%class-is?" "and" "type" "lambda" "jazz.object-declaration?" "set!" "jazz.Class-Declaration" "jazz.Category-Declaration" "jazz.Specific-Declaration" "jazz.Generic-Declaration" "jazz.Specialize" "jazz.Definition-Declaration" "jazz.encapsulate-class")
      {Lisp-Entry "jazz.Definition-Declaration" define-class #f 45 27 45 54 ()}
      {Lisp-Entry "jazz.new-definition-declaration" define #f 48 9 48 40 ("jazz.setup-declaration" "jazz.Definition-Declaration" "jazz.allocate-definition-declaration" "new-declaration" "let" "signature" "expansion" "parent" "attributes" "compatibility" "access" "type" "name")}
      {Lisp-Entry "jazz.walk-binding-validate-call" define-generic/specific ("jazz.Definition-Declaration") 54 21 54 52 ("jazz.validate-arguments" "if" "declaration" "%%get-definition-declaration-signature" "signature" "let" "arguments" "operator" "source-declaration" "resume" "walker")}
      {Lisp-Entry "jazz.emit-inlined-binding-call" define-generic/specific ("jazz.Definition-Declaration") 60 21 60 51 ("jazz.error" "jazz.call-return-type" "jazz.sourcified-form" "%%get-signature-positional" "%%get-lexical-binding-type" "jazz.emit-type-cast" "%%get-lexical-binding-name" "argument" "parameter" "map" "jazz.new-code" "jazz.emit-expression" "body-code" "%%cons" "augmented-environment" "frame" "lambda" "jazz.annotate-inlined-signature" "jazz.with-annotated-frame" "%%length" "%%get-signature-mandatory" "%%fx=" "jazz.only-positional?" "%%get-lambda-body" "body" "%%get-lambda-signature" "signature" "jazz.untyped-inline-definition?" "jazz.inline-definitions?" "or" "inline" "'inline" "%%get-definition-declaration-expansion" "%%eq?" "and" "jazz.Lambda" "%%class-is?" "if" "declaration" "%%get-definition-declaration-value" "value" "let" "environment" "source-declaration" "arguments")}
      {Lisp-Entry "jazz.untyped-inline-definition?" define #f 92 9 92 40 ("%%get-lambda-signature" "%%get-signature-positional" "%%get-lexical-binding-type" "%%not" "parameter" "lambda" "jazz.every?" "value")}
      {Lisp-Entry "jazz.emit-declaration" define-generic/specific ("jazz.Definition-Declaration") 98 21 98 42 ("%%get-declaration-source" "%%get-lexical-binding-type" "jazz.emit-expression" "jazz.emit-type-cast" ",locator" "define" "jazz.sourcify-if" "%%get-definition-declaration-value" "value" "declaration" "%%get-declaration-locator" "locator" "let" "environment")}
      {Lisp-Entry "jazz.emit-binding-reference" define-generic/specific ("jazz.Definition-Declaration") 107 21 107 48 ("jazz.Any" "%%get-lexical-binding-type" "or" "declaration" "%%get-declaration-locator" "jazz.new-code" "environment" "source-declaration")}
      {Lisp-Entry "jazz.walk-binding-validate-assignment" define-generic/specific ("jazz.Definition-Declaration") 115 21 115 58 ("%%get-lexical-binding-name" "jazz.walk-error" "%%get-declaration-toplevel" "%%neq?" "%%when" "declaration" "nextmethod" "source-declaration" "resume" "walker")}
      {Lisp-Entry "jazz.walk-binding-assignable?" define-generic/specific ("jazz.Definition-Declaration") 121 21 121 50 ()}
      {Lisp-Entry "jazz.emit-binding-assignment" define-generic/specific ("jazz.Definition-Declaration") 125 21 125 49 ("jazz.Any" "%%get-lexical-binding-type" "jazz.emit-expression" "jazz.emit-type-cast" ",locator" "set!" "jazz.new-code" "declaration" "%%get-declaration-locator" "locator" "let" "environment" "source-declaration" "value")}
      {Lisp-Entry "jazz.fold-declaration" define-generic/specific ("jazz.Definition-Declaration") 133 21 133 42 ("%%get-definition-declaration-value" "jazz.fold-statement" "declaration" "s" "k" "f")}
      {Lisp-Entry "jazz.Specialize" define-class #f 147 27 147 42 ()}
      {Lisp-Entry "jazz.new-specialize" define #f 150 9 150 28 ("jazz.Specialize" "jazz.allocate-specialize")}
      {Lisp-Entry "jazz.emit-expression" define-generic/specific ("jazz.Specialize") 154 21 154 41 ("jazz.Any" "begin" "jazz.new-code" "environment" "declaration")}
      {Lisp-Entry "jazz.fold-expression" define-generic/specific ("jazz.Specialize") 161 21 161 41 ("expression" "s" "k" "f")}
      {Lisp-Entry "jazz.Generic-Declaration" define-class #f 173 27 173 51 ()}
      {Lisp-Entry "jazz.new-generic-declaration" define #f 176 9 176 37 ("jazz.setup-declaration" "jazz.Generic-Declaration" "jazz.allocate-generic-declaration" "new-declaration" "let" "signature" "dispatch-types" "parent" "attributes" "compatibility" "access" "type" "name")}
      {Lisp-Entry "jazz.walk-binding-validate-call" define-generic/specific ("jazz.Generic-Declaration") 182 21 182 52 ("%%get-generic-declaration-signature" "declaration" "jazz.validate-arguments" "arguments" "operator" "source-declaration" "resume" "walker")}
      {Lisp-Entry "jazz.emit-declaration" define-generic/specific ("jazz.Generic-Declaration") 186 21 186 42 ("%%get-declaration-source" "jazz.emit-expression" "jazz.sourcified-form" "jazz.emit-signature" "jazz.define-generic" "jazz.sourcify-if" "%%cons" "augmented-environment" "frame" "lambda" "jazz.annotate-signature" "jazz.with-annotated-frame" "%%get-generic-declaration-body" "body" "%%get-generic-declaration-signature" "signature" "declaration" "%%get-declaration-locator" "generic-locator" "let" "environment")}
      {Lisp-Entry "jazz.emit-binding-reference" define-generic/specific ("jazz.Generic-Declaration") 199 21 199 48 ("jazz.Any" "declaration" "%%get-declaration-locator" "jazz.new-code" "environment" "source-declaration")}
      {Lisp-Entry "jazz.fold-declaration" define-generic/specific ("jazz.Generic-Declaration") 206 21 206 42 ("%%get-generic-declaration-body" "jazz.fold-statement" "declaration" "s" "k" "f")}
      {Lisp-Entry "jazz.Specific-Declaration" define-class #f 220 27 220 52 ()}
      {Lisp-Entry "jazz.new-specific-declaration" define #f 223 9 223 38 ("jazz.setup-declaration" "jazz.Specific-Declaration" "jazz.allocate-specific-declaration" "new-declaration" "let" "root?" "signature" "generic" "parent" "attributes" "compatibility" "access" "type" "name")}
      {Lisp-Entry "jazz.emit-declaration" define-generic/specific ("jazz.Specific-Declaration") 229 21 229 42 ("%%get-declaration-source" "jazz.emit-expression" "jazz.sourcified-form" ",modifier" "jazz.emit-signature" "jazz.define-specific" "jazz.sourcify-if" "child" "'child" "root" "'root" "%%get-specific-declaration-root?" "if" "modifier" "%%cons" "augmented-environment" "let" "frame" "lambda" "jazz.annotate-signature" "jazz.with-annotated-frame" "%%get-specific-declaration-body" "body" "%%get-specific-declaration-signature" "signature" "jazz.generic-object-locator" "generic-object-locator" "%%get-declaration-locator" "generic-locator" "declaration" "%%get-specific-declaration-generic" "generic-declaration" "let*" "environment")}
      {Lisp-Entry "jazz.fold-declaration" define-generic/specific ("jazz.Specific-Declaration") 245 21 245 42 ("%%get-specific-declaration-body" "jazz.fold-statement" "declaration" "s" "k" "f")}
      {Lisp-Entry "jazz.Category-Declaration" define-class #f 259 27 259 52 ()}
      {Lisp-Entry "jazz.emit-binding-reference" define-generic/specific ("jazz.Category-Declaration") 262 21 262 48 ("jazz.Category-Declaration" "declaration" "%%get-declaration-locator" "jazz.new-code" "environment" "source-declaration")}
      {Lisp-Entry "jazz.Class-Declaration" define-class #f 277 27 277 49 ()}
      {Lisp-Entry "jazz.new-class-declaration" define #f 280 9 280 35 ("jazz.setup-declaration" "jazz.new-queue" "jazz.protected-access" "jazz.make-access-lookups" "jazz.Class-Declaration" "jazz.allocate-class-declaration" "new-declaration" "let" "interfaces" "ascendant-base" "ascendant-relation" "ascendant" "metaclass" "implementor" "parent" "attributes" "compatibility" "access" "type" "name")}
      {Lisp-Entry "jazz.setup-class-lookups" define #f 286 9 286 33 ("jazz.protected-access" "%%get-namespace-declaration-lookups" "%%vector-set!" "not-private" "public" "interface" "lambda" "for-each" "jazz.public-access" "%%table-merge!" "%%get-declaration-toplevel" "%%eq?" "same-library?" "if" "jazz.private-access" "%%get-access-lookup" "private" "%%get-class-declaration-interfaces" "resolve-interface" "map" "interfaces" "%%get-class-declaration-ascendant" "resolve-class" "ascendant" "let" "class-declaration")
        {Lisp-Entry "resolve-class" define #f 287 11 287 24 ("jazz.Class-Declaration" "%%is?" "%%assert" "jazz.resolve-binding" "class-declaration" "let" "if" "decl")}
        {Lisp-Entry "resolve-interface" define #f 294 11 294 28 ("jazz.Interface-Declaration" "%%is?" "%%assert" "jazz.resolve-binding" "interface-declaration" "let" "if" "decl")}}
      {Lisp-Entry "jazz.emit-binding-reference" define-generic/specific ("jazz.Class-Declaration") 333 21 333 48 ("jazz.Class-Declaration" "%%get-category-declaration-metaclass" "or" "declaration" "%%get-declaration-locator" "jazz.new-code" "environment" "source-declaration")}
      {Lisp-Entry "jazz.of-subtype?" define-generic/specific ("jazz.Class-Declaration") 341 21 341 37 ("%%get-class-declaration-ascendant" "%%eq?" "jazz.resolve-binding" "target-declaration" "%%not" "target" "iter" "let" "jazz.Class-Declaration" "%%class-is?" "and" "declaration" "jazz.object-declaration?" "if" "subtype")}
      {Lisp-Entry "jazz.emit-declaration" define-generic/specific ("jazz.Class-Declaration") 354 21 354 42 ("%%get-declaration-source" "jazz.emit-namespace-statements" ",@interface-accesses" "%%list" ",metaclass-access" "jazz.new-class" "jazz.global-value" "',locator" "jazz.global-variable?" "lambda" "map" "interface-accesses" ",ascendant-access" "%%get-object-class" "jazz.Object-Class" "'jazz.Object-Class" "metaclass-access" "jazz.emit-ascendant-access" "%%get-category-declaration-metaclass" "metaclass-declaration" "jazz.remove-own-slots" ",name" "',name" "jazz.identifier-name" "jazz.set-core-class-redefined" "%%get-class-level" ",level-locator" "%%get-category-name" ",locator" "define" "jazz.emit-binding-reference" "jazz.sourcified-form" "%%not" "ascendant-access" "jazz.validate-core-class" "jazz.get-core-class" "core-class" "jazz.core-class?" "if" "begin" "jazz.sourcify-if" "level" "'level" "jazz.compose-helper" "level-locator" "%%get-namespace-declaration-body" "body" "%%get-class-declaration-interfaces" "interface-declarations" "%%get-class-declaration-ascendant" "ascendant-declaration" "%%get-declaration-locator" "locator" "declaration" "%%get-lexical-binding-name" "name" "let" "environment")}
      {Lisp-Entry "jazz.emit-ascendant-access" define #f 385 9 385 35 ("%%get-object-class" "else" "jazz.emit-binding-reference" "jazz.sourcified-form" "%%not" "cond" "%%get-class-declaration-ascendant-base" "ascendant-base" "%%get-class-declaration-ascendant-relation" "ascendant-relation" "%%get-class-declaration-ascendant" "ascendant" "let" "environment" "declaration")}
      {Lisp-Entry "jazz.find-class-declaration" define #f 400 9 400 36 ("%%get-declaration-parent" "else" "jazz.Class-Declaration" "%%class-is?" "jazz.error" "%%not" "cond" "decl" "iter" "let" "declaration")}
      {Lisp-Entry "jazz.validate-core-class" define #f 421 9 421 33 ("validate-slots" "validate-category" "declaration" "core-class")
        {Lisp-Entry "validate-category" define #f 422 11 422 28 ("validate-interfaces" "validate-ascendant")
          {Lisp-Entry "validate-ascendant" define #f 423 13 423 31 ("%%get-lexical-binding-name" "jazz.error" "%%eq?" "%%when" "%%get-declaration-locator" "declaration-ascendant-name" "declaration" "%%get-class-declaration-ascendant" "declaration-ascendant" "%%get-category-name" "jazz.identifier-name" "%%not" "if" "core-class-ascendant-name" "core-class" "%%get-class-ascendant" "core-class-ascendant" "let*")}
          {Lisp-Entry "validate-interfaces" define #f 431 13 431 32 ("%%get-lexical-binding-name" "jazz.error" "%%null?" "%%not" "%%when" "declaration" "%%get-class-declaration-interfaces" "declaration-interfaces" "let")}}
        {Lisp-Entry "validate-slots" define #f 439 11 439 25 ("jazz.error" "%%equal?" "%%not" "%%when" "declaration" "%%get-namespace-declaration-body" "collect-slots" "%%get-lexical-binding-name" "decl" "declaration-slot-names" "core-class" "%%get-class-instance-slots" "%%get-field-name" "%%symbol?" "if" "name/slot" "lambda" "map" "core-class-slot-names" "let")
          {Lisp-Entry "collect-slots" define #f 440 13 440 26 ("jazz.queue-list" "%%get-begin-expressions" "for-each" "jazz.Begin" "jazz.enqueue" "jazz.Slot-Declaration" "%%is?" "cond" "obj" "process" "define" "jazz.new-queue" "queue" "let" "lst")}}}
      {Lisp-Entry "jazz.Interface-Declaration" define-class #f 465 27 465 53 ()}
      {Lisp-Entry "jazz.new-interface-declaration" define #f 468 9 468 39 ("jazz.setup-declaration" "jazz.new-queue" "jazz.protected-access" "jazz.make-access-lookups" "jazz.Interface-Declaration" "jazz.allocate-interface-declaration" "new-declaration" "let" "ascendants" "metaclass" "implementor" "parent" "attributes" "compatibility" "access" "type" "name")}
      {Lisp-Entry "jazz.setup-interface-lookups" define #f 474 9 474 37 ("jazz.protected-access" "%%get-namespace-declaration-lookups" "%%vector-set!" "jazz.public-access" "%%table-merge!" "interface" "lambda" "for-each" "jazz.private-access" "%%get-access-lookup" "private" "%%get-interface-declaration-ascendants" "resolve-interface" "map" "ascendants" "let" "interface-declaration")
        {Lisp-Entry "resolve-interface" define #f 475 11 475 28 ("jazz.Interface-Declaration" "%%is?" "%%assert" "jazz.resolve-binding" "interface-declaration" "let" "if" "decl")}}
      {Lisp-Entry "jazz.of-subtype?" define-generic/specific ("jazz.Interface-Declaration") 507 21 507 37 ("subtype")}
      {Lisp-Entry "jazz.emit-declaration" define-generic/specific ("jazz.Interface-Declaration") 512 21 512 42 ("%%get-declaration-source" "jazz.emit-namespace-statements" "%%get-interface-rank" ",rank-locator" ",@ascendant-accesses" "%%list" "',locator" ",metaclass-access" "jazz.new-interface" ",locator" "define" "begin" "jazz.sourcify-if" "%%get-namespace-declaration-body" "body" "lambda" "map" "ascendant-accesses" "jazz.emit-binding-reference" "jazz.sourcified-form" "jazz.Interface" "'jazz.Interface" "%%not" "if" "metaclass-access" "%%get-category-declaration-metaclass" "metaclass-declaration" "%%get-interface-declaration-ascendants" "ascendant-declarations" "rank" "'rank" "jazz.compose-helper" "rank-locator" "%%get-declaration-locator" "locator" "declaration" "%%get-lexical-binding-name" "name" "let*" "environment")}
      {Lisp-Entry "jazz.Field-Declaration" define-class #f 539 27 539 49 ()}
      {Lisp-Entry "jazz.Slot-Declaration" define-class #f 550 27 550 48 ()}
      {Lisp-Entry "jazz.new-slot-declaration" define #f 553 9 553 34 ("jazz.setup-declaration" "jazz.Slot-Declaration" "jazz.allocate-slot-declaration" "new-declaration" "let" "setter-name" "getter-name" "initialize" "parent" "attributes" "compatibility" "access" "type" "name")}
      {Lisp-Entry "jazz.walk-binding-validate-call" define-generic/specific ("jazz.Slot-Declaration") 559 21 559 52 ("arguments" "operator" "source-declaration" "resume" "walker")}
      {Lisp-Entry "jazz.emit-declaration" define-generic/specific ("jazz.Slot-Declaration") 563 21 563 42 ("%%get-declaration-source" "jazz.declaration-result" "%%get-slot-offset" ",offset-locator" ",allocate?" ",name" "',name" ",class-locator" "jazz.add-slot" ",slot-locator" "jazz.emit-expression" "jazz.sourcified-form" "self" ",initialize-locator" "define" "if" "begin" "jazz.sourcify-if" "offset" "'offset" "offset-locator" "slot" "'slot" "slot-locator" "'initialize" "jazz.compose-helper" "and" "initialize-locator" "%%get-slot-declaration-initialize" "initialize" "jazz.Void" "%%get-lexical-binding-type" "%%neq?" "allocate?" "class-locator" "%%get-declaration-parent" "class-declaration" "%%get-declaration-locator" "locator" "declaration" "%%get-lexical-binding-name" "name" "let*" "environment")}
      {Lisp-Entry "jazz.emit-binding-reference" define-generic/specific ("jazz.Slot-Declaration") 587 21 587 48 ("jazz.error" "jazz.find-annotated-type" ",offset-locator" "jazz.sourcified-form" "%%object-ref" "jazz.new-code" "offset" "'offset" "declaration" "%%get-declaration-locator" "jazz.compose-helper" "offset-locator" "if" "jazz.*self*" "self" "let" "environment" "source-declaration")}
      {Lisp-Entry "jazz.walk-binding-assignable?" define-generic/specific ("jazz.Slot-Declaration") 598 21 598 50 ()}
      {Lisp-Entry "jazz.emit-binding-assignment" define-generic/specific ("jazz.Slot-Declaration") 602 21 602 49 ("jazz.error" "jazz.Any" "jazz.emit-expression" ",offset-locator" "jazz.sourcified-form" "%%object-set!" "jazz.new-code" "offset" "'offset" "declaration" "%%get-declaration-locator" "jazz.compose-helper" "offset-locator" "if" "jazz.*self*" "self" "let" "environment" "source-declaration" "value")}
      {Lisp-Entry "jazz.fold-declaration" define-generic/specific ("jazz.Slot-Declaration") 613 21 613 42 ("%%get-slot-declaration-initialize" "jazz.fold-statement" "declaration" "s" "k" "f")}
      {Lisp-Entry "jazz.Property-Declaration" define-class #f 627 27 627 52 ()}
      {Lisp-Entry "jazz.new-property-declaration" define #f 630 9 630 38 ("jazz.setup-declaration" "jazz.Property-Declaration" "jazz.allocate-property-declaration" "new-declaration" "let" "setter-name" "getter-name" "initialize" "parent" "attributes" "compatibility" "access" "type" "name")}
      {Lisp-Entry "jazz.emit-declaration" define-generic/specific ("jazz.Property-Declaration") 636 21 636 42 ("%%get-declaration-source" "jazz.declaration-result" "%%get-slot-offset" ",offset-locator" ",allocate?" ",name" "',name" ",class-locator" "jazz.add-property" ",slot-locator" "jazz.emit-expression" "jazz.sourcified-form" "self" ",initialize-locator" "define" "if" "begin" "jazz.sourcify-if" "%%get-property-declaration-setter" "setter" "%%get-property-declaration-getter" "getter" "offset" "'offset" "offset-locator" "slot" "'slot" "slot-locator" "'initialize" "jazz.compose-helper" "and" "initialize-locator" "%%get-slot-declaration-initialize" "initialize" "jazz.Void" "%%get-lexical-binding-type" "%%neq?" "allocate?" "class-locator" "%%get-declaration-parent" "class-declaration" "%%get-declaration-locator" "locator" "declaration" "%%get-lexical-binding-name" "name" "let*" "environment")}
      {Lisp-Entry "jazz.Method-Declaration" define-class #f 672 27 672 50 ()}
      {Lisp-Entry "jazz.new-method-declaration" define #f 675 9 675 36 ("jazz.setup-declaration" "jazz.Method-Declaration" "jazz.allocate-method-declaration" "new-declaration" "let" "signature" "synchronized" "remote" "expansion" "abstraction" "propagation" "root" "parent" "attributes" "compatibility" "access" "type" "name")}
      {Lisp-Entry "jazz.method-dispatch-info" define #f 681 9 681 34 ("error" "else" "interface" "'interface" "jazz.Interface-Declaration" "class" "'class" "jazz.Class-Declaration" "%%class-is?" "cond" "%%get-declaration-parent" "category-declaration" "method-declaration" "root-method-declaration" "values" "inherited" "'inherited" "final" "'final" "%%eq?" "or" "%%not" "and" "if" "%%get-method-declaration-propagation" "propagation" "%%get-method-declaration-root" "root" "let" "declaration")}
      {Lisp-Entry "jazz.native-category?" define #f 697 9 697 30 ("primitive" "'primitive" "%%get-category-declaration-implementor" "%%neq?" "category-declaration")}
      {Lisp-Entry "jazz.emit-method-dispatch" define #f 701 9 701 34 ("%%get-lexical-binding-type" "jazz.call-return-type" "%%interface-dispatch" ",interface-rank-locator" "%%interface-native-dispatch" "interface-rank-locator" "interface" "%%class-dispatch" ",method-rank-locator" ",class-level-locator" "%%class-native-dispatch" "jazz.native-category?" "if" "rank" "'rank" "method-rank-locator" "level" "'level" "jazz.compose-helper" "class-level-locator" "class" ",implementation-locator" "jazz.sourcified-form" "%%final-dispatch" "%%get-declaration-locator" "implementation-locator" "final" "case" "jazz.new-code" "%%get-declaration-parent" "category-declaration" "jazz.method-dispatch-info" "method-declaration" "dispatch-type" "receive" "%%get-lexical-binding-name" "name" "let" "declaration" "object")}
      {Lisp-Entry "jazz.emit-binding-reference" define-generic/specific ("jazz.Method-Declaration") 726 21 726 48 ("%%get-declaration-locator" "%%get-lexical-binding-name" "jazz.error" "%%get-code-type" "jazz.sourcified-form" "apply" "rest" "lambda" "jazz.new-code" "declaration" "jazz.emit-method-dispatch" "dispatch-code" "if" "jazz.*self*" "self" "let" "environment" "source-declaration")}
      {Lisp-Entry "jazz.walk-binding-validate-call" define-generic/specific ("jazz.Method-Declaration") 738 21 738 52 ("jazz.validate-arguments" "if" "declaration" "%%get-method-declaration-signature" "signature" "let" "arguments" "operator" "source-declaration" "resume" "walker")}
      {Lisp-Entry "jazz.emit-inlined-binding-call" define-generic/specific ("jazz.Method-Declaration") 744 21 744 51 ("else" "jazz.error" "jazz.call-return-type" "jazz.sourcified-form" "%%get-signature-positional" "%%get-lexical-binding-type" "jazz.emit-type-cast" "%%get-lexical-binding-name" "argument" "parameter" "map" "jazz.new-code" "jazz.emit-expression" "body-code" "%%cons" "augmented-environment" "frame" "lambda" "jazz.annotate-signature" "jazz.with-annotated-frame" "%%length" "%%get-signature-mandatory" "%%fx=" "jazz.only-positional?" "%%get-method-declaration-body" "body" "%%get-method-declaration-signature" "signature" "let" "final" "case" "jazz.method-dispatch-info" "method-declaration" "dispatch-type" "receive" "inline" "'inline" "declaration" "%%get-method-declaration-expansion" "%%eq?" "if" "environment" "source-declaration" "arguments")}
      {Lisp-Entry "jazz.emit-binding-call" define-generic/specific ("jazz.Method-Declaration") 774 21 774 43 ("%%get-declaration-locator" "%%get-lexical-binding-name" "jazz.error" "%%get-code-type" ",@arguments" "jazz.sourcified-form" "jazz.new-code" "jazz.emit-method-dispatch" "dispatch-code" "jazz.codes-forms" "declaration" "%%get-lexical-binding-type" "type" "if" "jazz.*self*" "self" "let" "environment" "source-declaration" "arguments")}
      {Lisp-Entry "jazz.emit-declaration" define-generic/specific ("jazz.Method-Declaration") 789 21 789 42 ("%%get-declaration-source" "',class-locator" "jazz.call-into-abstract" "rest" ",method-rank-locator" "abstract" "'abstract" "%%eq?" "if" "jazz.declaration-result" ",name" "',name" ",class-locator" ",method-call" "jazz.emit-expression" "jazz.sourcified-form" ",method-node-locator" "%%get-method-node-next-implementation" "nextmethod" "jazz.emit-signature-casts" "jazz.emit-signature" "self" ",method-locator" "define" "begin" "jazz.generate-symbol" "jazz.sourcify-if" "%%cons" "augmented-environment" "frame" "lambda" "jazz.annotate-signature" "jazz.with-annotated-frame" "jazz.Interface-Declaration" "jazz.add-virtual-method" "'jazz.add-virtual-method" "chained" "virtual" "jazz.add-final-method" "'jazz.add-final-method" "inherited" "final" "case" "jazz.Class-Declaration" "%%class-is?" "jazz.add-method-node" "'jazz.add-method-node" "cond" "method-call" "node" "'node" "method-node-locator" "rank" "'rank" "jazz.compose-helper" "method-rank-locator" "method-locator" "%%get-declaration-locator" "class-locator" "and" "root-category-declaration" "%%get-method-declaration-root" "root-method-declaration" "%%get-declaration-parent" "category-declaration" "let*" "%%get-method-declaration-body" "body" "%%get-method-declaration-signature" "signature" "%%get-method-declaration-abstraction" "abstraction" "%%get-method-declaration-propagation" "propagation" "declaration" "%%get-lexical-binding-name" "name" "let" "environment")}
      {Lisp-Entry "jazz.fold-declaration" define-generic/specific ("jazz.Method-Declaration") 845 21 845 42 ("jazz.fold-statement" "%%not" "if" "%%get-method-declaration-body" "body" "let" "declaration" "s" "k" "f")}
      {Lisp-Entry "jazz.Jazz-Dialect" define-class #f 861 27 861 44 ()}
      {Lisp-Entry "jazz.new-jazz-dialect" define #f 864 9 864 30 ("jazz.Jazz-Dialect" "jazz.allocate-jazz-dialect")}
      {Lisp-Entry "jazz.dialect-name" define-generic/specific ("jazz.Jazz-Dialect") 868 21 868 38 ("'jazz")}
      {Lisp-Entry "jazz.dialect-walker" define-generic/specific ("jazz.Jazz-Dialect") 872 21 872 40 ("jazz.new-jazz-walker")}
      {Lisp-Entry "jazz.Jazz-Walker" define-class #f 884 27 884 43 ()}
      {Lisp-Entry "jazz.new-jazz-walker" define #f 887 9 887 29 ("jazz.Jazz-Walker" "jazz.allocate-jazz-walker")}
      {Lisp-Entry "jazz.runtime-export" define-generic/specific ("jazz.Jazz-Walker") 891 21 891 40 ("%%get-declaration-locator" "jazz.Category-Declaration" "jazz.Generic-Declaration" "jazz.Definition-Declaration" "%%is?" "if" "walker" "nextmethod" "or" "declaration")}
      {Lisp-Entry "jazz.jazz-bindings" define #f 905 9 905 27 ("jazz.expand-form" "form" "'form" "jazz.expand-com-external" "com-external" "'com-external" "jazz.expand-c-external-so" "c-external-so" "'c-external-so" "jazz.expand-c-external" "c-external" "'c-external" "jazz.expand-c-union" "c-union" "'c-union" "jazz.expand-c-structure" "c-structure" "'c-structure" "jazz.expand-assertion" "assertion" "'assertion" "jazz.expand-assert" "assert" "'assert" "jazz.expand-remotable-stub" "remotable-stub" "'remotable-stub" "jazz.walk-time" "time" "'time" "jazz.walk-construct" "construct" "'construct" "jazz.walk-cast" "cast" "'cast" "jazz.walk-with-local-variables" "with-local-variables" "'with-local-variables" "jazz.walk-with-dynamic-self" "with-dynamic-self" "'with-dynamic-self" "jazz.walk-with-self" "with-self" "'with-self" "jazz.walk-with-slots" "with-slots" "'with-slots" "jazz.walk-parameterize" "parameterize" "'parameterize" "jazz.walk-specialize" "%specialize" "'%specialize" "jazz.expand-specialize" "specialize" "'specialize" "jazz.new-macro-form" "jazz.walk-function" "function" "'function" "jazz.walk-c-definition" "c-definition" "'c-definition" "jazz.walk-c-type" "c-type" "'c-type" "jazz.walk-c-function" "c-function" "'c-function" "jazz.walk-c-initialize" "c-initialize" "'c-initialize" "jazz.walk-c-named-declare" "c-named-declare" "'c-named-declare" "jazz.walk-c-declare" "c-declare" "'c-declare" "jazz.walk-c-include" "c-include" "'c-include" "jazz.walk-declare" "declare" "'declare" "jazz.walk-method" "method" "'method" "%property" "'%property" "jazz.walk-%slot" "%slot" "'%slot" "jazz.expand-property" "property" "'property" "jazz.expand-slot" "slot" "'slot" "jazz.walk-interface" "interface" "'interface" "jazz.walk-%class" "%class" "'%class" "jazz.expand-class" "class" "'class" "jazz.new-syntax-form" "jazz.walk-specific" "specific" "'specific" "jazz.walk-generic" "generic" "'generic" "jazz.walk-definition" "definition" "'definition" "jazz.new-special-form" "%%list")}
      {Lisp-Entry "jazz.jazz-environment" define #f 950 8 950 29 ()}
      {Lisp-Entry "jazz.walker-environment" define-generic/specific ("jazz.Jazz-Walker") 954 21 954 44 ("jazz.jazz-bindings" "jazz.scheme-bindings" "jazz.core-bindings" "append" "jazz.new-walk-frame" "%%list" "set!" "begin" "jazz.jazz-environment" "or")}
      {Lisp-Entry "jazz.walk-declaration" define-generic/specific ("jazz.Jazz-Walker") 966 21 966 42 ("nextmethod" "else" "jazz.walk-c-definition-declaration" "c-definition" "jazz.walk-c-type-declaration" "c-type" "jazz.walk-c-named-declare-declaration" "c-named-declare" "c-include" "jazz.walk-with-local-variables-declaration" "with-local-variables" "jazz.walk-with-dynamic-self-declaration" "with-dynamic-self" "jazz.walk-method-declaration" "method" "jazz.walk-%slot-declaration" "%property" "%slot" "jazz.walk-interface-declaration" "interface" "jazz.walk-%class-declaration" "%class" "specific" "jazz.walk-generic-declaration" "generic" "jazz.walk-%specialize-declaration" "%specialize" "walker" "jazz.walk-definition-declaration" "definition" "case" "%%car" "first" "let" "%%pair?" "if" "form" "environment" "declaration" "resume")}
      {Lisp-Entry "jazz.parse-keywords" define #f 993 9 993 28 ("%%list" "jazz.unspecified" "%%table-ref" "keyword" "lambda" "map" "%%append" "values" "%%apply" "%%cddr" "%%cadr" "%%table-set!" "begin" "set!" "%%memq" "if" "%%car" "jazz.source-code" "symbol" "%%null?" "%%not" "and" "%%while" "done?" "eq?" "test:" "%%make-table" "table" "let" "rest" "keywords")}
      {Lisp-Entry "jazz.emit-specialized-class-of" define #f 1024 9 1024 39 ("%%get-category-declaration-metaclass" "jazz.Class-Declaration" "%%class-is?" "%%get-code-type" "type" "let" "%%class-of" "jazz.sourcified-form" "jazz.class-of" "jazz.debug-user?" "if" "jazz.new-code" "environment" "object")}
      {Lisp-Entry "jazz.walk-symbol" define-generic/specific ("jazz.Jazz-Walker") 1069 21 1069 37 ("nextmethod" "else" "jazz.error" "or" "jazz.new-method-reference" "jazz.Method-Declaration" "method-declaration" "jazz.Category-Declaration" "walker" "jazz.lookup-reference" "jazz.resolve-binding" "category-declaration" "jazz.new-reference" "jazz.Slot-Declaration" "%%class-is?" "%%assert" "jazz.private-access" "jazz.find-class-declaration" "jazz.lookup-declaration" "slot-declaration" "self" "'self" "%%eq?" "and" "cond" "if" "self/class-name" "name" "tilde?" "lambda" "jazz.split-tilde" "jazz.source-code" "symbol" "let" "symbol-src" "environment" "declaration" "resume")}
      {Lisp-Entry "jazz.split-tilde" define #f 1091 9 1091 25 ("1" "%%fx+" "%%fx<" "%%substring" "%%string->symbol" "0" "%%fx>" "%%string-length" "len" "%%not" "if" "jazz.string-find-reversed" "n" "%%symbol->string" "str" "let" "proc" "symbol")}
      {Lisp-Entry "jazz.walk-symbol-assignment" define-generic/specific ("jazz.Jazz-Walker") 1107 21 1107 48 ("nextmethod" "%%desourcify" "jazz.error" "walker" "jazz.walk" "jazz.new-assignment" "jazz.Slot-Declaration" "%%class-is?" "%%assert" "jazz.private-access" "jazz.find-class-declaration" "jazz.lookup-declaration" "slot-declaration" "let" "self" "'self" "%%eq?" "and" "if" "self/class-name" "name" "tilde?" "lambda" "jazz.source-code" "jazz.split-tilde" "value" "symbol-src" "environment" "declaration" "resume")}
      {Lisp-Entry "jazz.walk-form" define-generic/specific ("jazz.Jazz-Walker") 1124 21 1124 35 ("nextmethod" "walker" "jazz.walk-dispatch" "jazz.dispatch?" "if" "%%car" "jazz.source-code" "procedure-expr" "let" "form-src" "environment" "declaration" "resume")}
      {Lisp-Entry "jazz.With-Self" define-class #f 1136 27 1136 41 ()}
      {Lisp-Entry "jazz.new-with-self" define #f 1139 9 1139 27 ("jazz.With-Self" "jazz.allocate-with-self" "body")}
      {Lisp-Entry "jazz.emit-expression" define-generic/specific ("jazz.With-Self") 1143 21 1143 41 ("jazz.Any" "jazz.emit-expression" "jazz.sourcified-form" "self" "'self" "jazz.*self*" "parameterize" "begin" "jazz.simplify-begin" "jazz.new-code" "expression" "%%get-with-self-body" "body" "let" "environment" "declaration")}
      {Lisp-Entry "jazz.fold-expression" define-generic/specific ("jazz.With-Self") 1154 21 1154 41 ("%%get-with-self-body" "jazz.fold-expression" "expression" "s" "k" "f")}
      {Lisp-Entry "jazz.With-Dynamic-Self" define-class #f 1168 27 1168 49 ()}
      {Lisp-Entry "jazz.new-with-dynamic-self" define #f 1171 9 1171 35 ("jazz.With-Dynamic-Self" "jazz.allocate-with-dynamic-self" "body" "code")}
      {Lisp-Entry "jazz.emit-expression" define-generic/specific ("jazz.With-Dynamic-Self") 1175 21 1175 41 ("jazz.Any" "jazz.emit-statements-code" "jazz.sourcified-form" "jazz.*self*" "parameterize" "begin" "jazz.simplify-begin" "jazz.new-code" "%%get-with-dynamic-self-body" "body" "expression" "%%get-with-dynamic-self-code" "code" "let" "environment" "declaration")}
      {Lisp-Entry "jazz.fold-expression" define-generic/specific ("jazz.With-Dynamic-Self") 1187 21 1187 41 ("%%get-with-dynamic-self-body" "jazz.fold-expressions" "expression" "s" "k" "f")}
      {Lisp-Entry "jazz.Cast" define-class #f 1200 27 1200 36 ()}
      {Lisp-Entry "jazz.new-cast" define #f 1203 9 1203 22 ("jazz.Cast" "jazz.allocate-cast" "expression" "type")}
      {Lisp-Entry "jazz.emit-expression" define-generic/specific ("jazz.Cast") 1207 21 1207 41 ("jazz.emit-expression" "jazz.emit-type-cast" "jazz.new-code" "%%get-cast-expression" "expression" "%%get-expression-type" "type" "let" "environment" "declaration")}
      {Lisp-Entry "jazz.fold-expression" define-generic/specific ("jazz.Cast") 1220 21 1220 41 ("%%get-cast-expression" "jazz.fold-expression" "expression" "s" "k" "f")}
      {Lisp-Entry "jazz.Construct" define-class #f 1233 27 1233 41 ()}
      {Lisp-Entry "jazz.new-construct" define #f 1236 9 1236 27 ("jazz.Construct" "jazz.allocate-construct" "values" "class")}
      {Lisp-Entry "jazz.emit-expression" define-generic/specific ("jazz.Construct") 1240 21 1240 41 ("jazz.Any" "jazz.emit-expressions" "jazz.codes-forms" "jazz.emit-expression" "jazz.sourcified-form" "%%object" "jazz.new-code" "%%get-construct-values" "values" "expression" "%%get-construct-class" "class" "let" "environment" "declaration")}
      {Lisp-Entry "jazz.fold-expression" define-generic/specific ("jazz.Construct") 1250 21 1250 41 ("%%get-construct-values" "jazz.fold-expressions" "%%get-construct-class" "jazz.fold-expression" "expression" "s" "k" "f")}
      {Lisp-Entry "jazz.cache-dispatch" define #f 1264 9 1264 28 ("jazz.interface-dispatch" "interface" "jazz.class-dispatch" "jazz.final-dispatch" "final" "%%get-method-dispatch-type" "case" "proc" "%%get-category-field" "field" "jazz.error" "%%assertion" "jazz.locate-method-owner" "category" "%%class-of" "class" "let" "object" "lambda" "setter" "name")}
      {Lisp-Entry "jazz.final-dispatch" define #f 1282 9 1282 28 ("%%get-method-implementation" "%%final-dispatch" "jazz.dispatch-error" "%%category-is?" "%%debug-assertion" "object" "lambda" "type" "field")}
      {Lisp-Entry "jazz.class-dispatch" define #f 1288 9 1288 28 ("%%class-dispatch" "jazz.dispatch-error" "%%category-is?" "%%debug-assertion" "object" "lambda" "%%get-method-implementation-rank" "implementation-rank" "%%get-method-category-rank" "class-level" "let" "type" "field")}
      {Lisp-Entry "jazz.interface-dispatch" define #f 1296 9 1296 32 ("%%interface-dispatch" "jazz.dispatch-error" "%%category-is?" "%%debug-assertion" "object" "lambda" "%%get-method-implementation-rank" "implementation-rank" "%%get-method-category-rank" "interface-rank" "let" "type" "field")}
      {Lisp-Entry "jazz.dispatch" define #f 1304 9 1304 22 ("jazz.error" "jazz.find-dispatch" "or" "name" "object")}
      {Lisp-Entry "jazz.find-dispatch" define #f 1309 9 1309 27 ("%%interface-dispatch" "interface" "%%get-method-implementation-rank" "%%get-method-category-rank" "%%class-dispatch" "%%get-method-implementation" "%%final-dispatch" "final" "%%get-method-dispatch-type" "case" "%%get-category-field" "field" "%%not" "if" "jazz.locate-method-owner" "category" "%%class-of" "class" "let" "name" "object")}
      {Lisp-Entry "jazz.Dispatch" define-class #f 1324 27 1324 40 ()}
      {Lisp-Entry "jazz.new-dispatch" define #f 1327 9 1327 26 ("jazz.Dispatch" "jazz.allocate-dispatch" "arguments" "name" "source")}
      {Lisp-Entry "jazz.emit-expression" define-generic/specific ("jazz.Dispatch") 1331 21 1331 41 ("expression" "jazz.emit-dispatch" "environment" "declaration")}
      {Lisp-Entry "jazz.emit-dispatch" define #f 1335 9 1335 27 ("jazz.Any" ",object" "object" "jazz.with-uniqueness" ",d" "set!" ",name" "',name" "jazz.cache-dispatch" "%%set-cdr!" "d" "%%symbol->string" "%%string-append" "jazz.register-variable" "dv" "%%get-expression-source" "jazz.codes-forms" "jazz.sourcified-form" "jazz.new-code" "jazz.emit-method-dispatch" "dispatch-code" "code" "lambda" "jazz.with-code-value" "jazz.emit-inlined-final-dispatch" "or" "jazz.emit-expressions" "rest-codes" "jazz.emit-expression" "%%cdr" "rest-arguments" "%%car" "object-argument" "method" "'method" "dispatch" "'dispatch" "find" "'find" "to" "'to" "unable" "'unable" "%%get-declaration-locator" "In" "'In" "Warning:" "'Warning:" "jazz.debug" "optimizations" "'optimizations" "%%get-declaration-toplevel" "jazz.get-library-warn?" "jazz.warnings?" "begin" "%%not" "method-declaration" "lookup-method/warn" "jazz.Method-Declaration" "and" "jazz.public-access" "jazz.lookup-declaration" "jazz.Category-Declaration" "lookup-method" "jazz.resolve-binding" "jazz.Autoload-Declaration" "%%class-is?" "if" "%%get-code-type" "jazz.patch-type-until-unification" "object-type" "object-code" "resolve-type" "define" "%%get-dispatch-arguments" "arguments" "%%get-dispatch-name" "name" "let" "environment" "declaration" "expression")}
      {Lisp-Entry "jazz.with-code-value" define #f 1389 9 1389 29 ("%%get-code-source" ",form" ",value" "%%get-code-type" "jazz.new-code" "jazz.generate-symbol" "value" "%%symbol?" "if" "%%get-code-form" "form" "let" "proc" "code")}
      {Lisp-Entry "jazz.emit-inlined-final-dispatch" define #f 1402 9 1402 41 ("else" "jazz.error" "jazz.call-return-type" "%%get-signature-positional" "%%get-lexical-binding-type" "jazz.emit-type-cast" "%%get-lexical-binding-name" "argument" "parameter" "map" "jazz.sourcified-form" "self" "jazz.new-code" "jazz.emit-expression" "body-code" "%%cons" "augmented-environment" "frame" "lambda" "jazz.annotate-signature" "jazz.with-annotated-frame" "%%length" "%%get-signature-mandatory" "%%fx=" "jazz.only-positional?" "%%get-method-declaration-body" "body" "%%get-method-declaration-signature" "signature" "let" "final" "case" "jazz.method-dispatch-info" "method-declaration" "dispatch-type" "receive" "inline" "'inline" "%%get-method-declaration-expansion" "%%eq?" "if" "environment" "source-declaration" "arguments" "object" "declaration" "expression")}
      {Lisp-Entry "jazz.fold-expression" define-generic/specific ("jazz.Dispatch") 1433 21 1433 41 ("%%get-dispatch-arguments" "jazz.fold-expressions" "%%get-dispatch-name" "expression" "s" "k" "f")}
      {Lisp-Entry "jazz.walk-dispatch" define #f 1442 9 1442 27 ("jazz.walk-list" "jazz.new-dispatch" "%%desourcify" "jazz.error" "%%null?" "%%not" "%%assertion" "%%cdr" "arguments" "%%car" "jazz.source-code" "jazz.dispatch->symbol" "name" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.definition-modifiers" define #f 1455 8 1455 33 ()}
      {Lisp-Entry "jazz.parse-definition" define #f 1461 9 1461 30 (",@effective-body" ",parameters" "value" "unspecified" "'unspecified" "%%list" "%%null?" "effective-body" "body" "%%desourcify" "parameters" "let*" "values" "specifier" "lambda" "%%cdr" "jazz.parse-specifier" "name" "let" "%%car" "jazz.source-code" "%%symbol?" "if" "jazz.definition-modifiers" "jazz.parse-modifiers" "expansion" "compatibility" "access" "receive" "rest" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.walk-definition-declaration" define #f 1479 9 1479 41 ("jazz.walk" "%%set-definition-declaration-value" "%%cons" "new-environment" "inline" "'inline" "%%eq?" "%%when" "jazz.add-declaration-child" "effective-declaration" "jazz.new-definition-declaration" "new-declaration" "jazz.build-function-type" "if" "effective-type" "jazz.walk-parameters" "and" "signature" "jazz.specifier->type" "type" "let" "%%cdr" "jazz.parse-definition" "parameters" "value" "expansion" "compatibility" "access" "specifier" "name" "receive" "form" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.walk-definition" define #f 1493 9 1493 29 ("%%set-declaration-source" "jazz.walk" "%%set-definition-declaration-value" "%%cons" "%%set-definition-declaration-signature" "jazz.walk-parameters" "augmented-environment" "signature" "if" "new-environment" "inline" "'inline" "%%neq?" "%%when" "jazz.find-form-declaration" "new-declaration" "let" "jazz.source-code" "%%cdr" "jazz.parse-definition" "parameters" "value" "expansion" "compatibility" "access" "specifier" "name" "receive" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.build-function-type" define #f 1512 9 1512 33 ("jazz.Any" "or" "and" "%%get-signature-rest" "rest" "let" "%%get-signature-named" "%%get-signature-optional" "%%get-signature-positional" "parameter-type" "map" "jazz.new-function-type" "result-type" "signature")
        {Lisp-Entry "parameter-type" define #f 1513 11 1513 25 ("jazz.Any" "%%get-lexical-binding-type" "or" "parameter")}}
      {Lisp-Entry "jazz.specialize-modifiers" define #f 1531 8 1531 33 ()}
      {Lisp-Entry "jazz.parse-specialize" define #f 1535 9 1535 30 ("%%cddr" "%%cadr" "values" "as" "'as" "%%car" "%%eq?" "if" "jazz.specialize-modifiers" "jazz.parse-modifiers" "expansion" "receive" "rest" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.expand-specialize" define #f 1542 9 1542 31 (",operator" "%specialize" ",@rest" ",@parameters" ",name" ",expansion" "undocumented" "public" "definition" "begin" "jazz.compose-specializer-name" "or" "name" "parameters" "operator" "%%cdr" "%%car" "signature" "let" "jazz.parse-specialize" "as" "expansion" "receive" "rest" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.compose-specializer-name" define #f 1554 9 1554 38 ("jazz.specifier->name" "%%list" "jazz.specifier?" "if" "parameter" "lambda" "map" "append" "string-append" "%%apply" "%%symbol->string" "%%string-append" "%%string->symbol" "parameters" "operator")}
      {Lisp-Entry "jazz.walk-%specialize-declaration" define #f 1569 9 1569 42 ("jazz.new-specialize" "jazz.add-specializer" "specializer-declaration" "jazz.lookup-reference" "specialized-declaration" "%%cddr" "%%car" "specializer" "%%cadr" "specialized" "let" "form" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.walk-specialize" define #f 1579 9 1579 29 ("jazz.new-specialize" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.generic-modifiers" define #f 1588 8 1588 30 ()}
      {Lisp-Entry "jazz.parse-generic" define #f 1593 9 1593 27 ("values" "body" "specifier" "lambda" "jazz.parse-specifier" "%%cdr" "parameters" "name" "%%car" "jazz.source-code" "signature" "let" "jazz.generic-modifiers" "jazz.parse-modifiers" "compatibility" "access" "receive" "rest" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.walk-generic-declaration" define #f 1603 9 1603 38 ("jazz.walk-error" "jazz.add-declaration-child" "effective-declaration" "jazz.new-generic-declaration" "new-declaration" "jazz.walk-parameters" "signature" "jazz.dynamic-parameter-types" "jazz.lookup-reference" "dynamic-parameter-type" "lambda" "map" "dispatch-type-declarations" "jazz.Any" "jazz.walk-specifier" "type" "let" "jazz.Library-Declaration" "%%class-is?" "if" "%%cdr" "jazz.parse-generic" "body" "parameters" "compatibility" "access" "specifier" "name" "receive" "form" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.walk-generic" define #f 1617 9 1617 26 ("%%set-declaration-source" "jazz.walk-body" "%%set-generic-declaration-body" "%%set-generic-declaration-signature" "jazz.find-form-declaration" "new-declaration" "let" "jazz.walk-parameters" "augmented-environment" "signature" "jazz.source-code" "%%cdr" "jazz.parse-generic" "body" "parameters" "compatibility" "access" "specifier" "name" "receive" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.specific-modifiers" define #f 1633 8 1633 31 ()}
      {Lisp-Entry "jazz.parse-specific" define #f 1637 9 1637 28 ("values" "parameters" "name" "unspecified" "'unspecified" "%%list" "%%null?" "if" "effective-body" "%%cdr" "body" "%%car" "jazz.desourcify" "signature" "let*" "jazz.specific-modifiers" "jazz.parse-modifiers" "receive" "rest" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.walk-specific" define #f 1647 9 1647 27 ("jazz.walk-error" "%%set-declaration-source" "jazz.walk-body" "%%set-specific-declaration-body" "nextmethod" "'nextmethod" "jazz.new-nextmethod-variable" "%%cons" "body-environment" "uptodate" "'uptodate" "public" "'public" "jazz.new-specific-declaration" "new-declaration" "jazz.walk-specific-root-dynamic-parameters?" "root?" "let*" "jazz.walk-parameters" "augmented-environment" "signature" "jazz.Generic-Declaration" "jazz.private-access" "jazz.lookup-declaration" "generic-declaration" "let" "jazz.Library-Declaration" "%%class-is?" "if" "jazz.source-code" "%%cdr" "jazz.parse-specific" "body" "parameters" "name" "receive" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.walk-specific-root-dynamic-parameters?" define #f 1664 9 1664 52 ("else" "or" "%%cons" "%%get-declaration-locator" "%%get-lexical-binding-name" "jazz.walk-error" "%%eq?" "%%cdr" "if" "specific-class" "%%get-dynamic-parameter-class" "%%get-reference-binding" "jazz.resolve-binding" "generic-class" "cond" "specific-dynamic?" "jazz.Dynamic-Parameter" "%%is?" "generic-dynamic?" "specific-parameter" "%%car" "%%pair?" "and" "generic-parameter" "root?" "specific-parameters" "%%get-generic-declaration-signature" "%%get-signature-positional" "generic-parameters" "iter" "let" "parameters" "name" "specific-signature" "generic-declaration" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.class-modifiers" define #f 1694 8 1694 28 ()}
      {Lisp-Entry "jazz.class-keywords" define #f 1700 8 1700 27 ()}
      {Lisp-Entry "jazz.parse-class" define #f 1704 9 1704 25 ("values" "jazz.class-keywords" "jazz.parse-keywords" "body" "attributes" "interface-names" "ascendant-name" "metaclass-name" "%%cdr" "jazz.Any" "type" "%%car" "jazz.source-code" "name" "let" "jazz.class-modifiers" "jazz.parse-modifiers" "implementor" "compatibility" "abstraction" "access" "receive" "rest" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.expand-class" define #f 1713 9 1713 26 (",@class-body" ",interface-names" "implements" "metaclass" ",name" ",implementor" ",compatibility" ",abstraction" ",access" ",@metaclass-body" ",ascendant-name" ":class" "extends" ",metaclass-name" "begin" "%%symbol->string" "%%string-append" "%%string->symbol" "let" "else" "jazz.walk-error" "%%specified?" "%class" "%%null?" "cond" "jazz.preprocess-meta" "class-body" "metaclass-body" "jazz.source-code" "%%cdr" "jazz.parse-class" "body" "attributes" "interface-names" "ascendant-name" "metaclass-name" "implementor" "compatibility" "abstraction" "access" "type" "name" "receive" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.preprocess-meta" define #f 1729 9 1729 29 ("jazz.queue-list" "values" "%%cddr" "%%car" "%%cons" "jazz.enqueue" "meta" "'meta" "%%cadr" "%%eq?" "%%cdr" "jazz.source-code" "%%pair?" "and" "if" "expr" "lambda" "for-each" "class" "jazz.new-queue" "metaclass" "let" "body")}
      {Lisp-Entry "jazz.walk-%class-declaration" define #f 1743 9 1743 37 ("jazz.walk-error" "jazz.walk-declarations" "%%cons" "new-environment" "jazz.setup-class-lookups" "jazz.add-declaration-child" "effective-declaration" "jazz.new-class-declaration" "jazz.Class-Declaration" "jazz.find-typed-declaration" "or" "new-declaration" "jazz.listify" "jazz.lookup-reference" "interface-name" "lambda" "map" "jazz.unspecified?" "interfaces" "jazz.lookup-metaclass" "metaclass" "let" "jazz.lookup-ascendant" "ascendant-base" "ascendant-relation" "ascendant" "jazz.Library-Declaration" "%%class-is?" "if" "%%cdr" "jazz.parse-class" "body" "attributes" "interface-names" "ascendant-name" "metaclass-name" "implementor" "compatibility" "abstraction" "access" "type" "name" "receive" "form" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.walk-%class" define #f 1760 9 1760 25 ("%%set-declaration-source" "jazz.walk-namespace" "%%set-namespace-declaration-body" "begin" "jazz.error" "Object" "'Object" "%%neq?" "%%not" "and" "if" "%%get-class-declaration-ascendant" "ascendant-declaration" "%%cons" "new-environment" "jazz.find-form-declaration" "new-declaration" "let*" "%%cdr" "jazz.parse-class" "body" "attributes" "interface-names" "ascendant-name" "metaclass-name" "implementor" "compatibility" "abstraction" "access" "type" "name" "receive" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.lookup-metaclass" define #f 1774 9 1774 30 ("jazz.lookup-reference" "Object-Class" "'Object-Class" "%%eq?" "jazz.unspecified?" "or" "if" "metaclass-name" "ascendant" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.lookup-ascendant" define #f 1780 9 1780 30 ("else" "Object-Class" "'Object-Class" "jazz.effective-class-declaration-metaclass" "or" "%%cadr" "jazz.lookup-reference" "base" "relation" "let" ":class" "':class" "%%car" "%%eq?" "%%pair?" "and" "values" "jazz.unspecified?" "cond" "ascendant-name" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.effective-class-declaration-metaclass" define #f 1800 9 1800 51 ("jazz.effective-class-declaration-metaclass" "%%get-class-declaration-ascendant" "ascendant" "%%get-category-declaration-metaclass" "or" "jazz.resolve-binding" "let" "%%not" "if" "class-declaration")}
      {Lisp-Entry "jazz.interface-modifiers" define #f 1816 8 1816 32 ()}
      {Lisp-Entry "jazz.interface-keywords" define #f 1821 8 1821 31 ()}
      {Lisp-Entry "jazz.parse-interface" define #f 1825 9 1825 29 ("values" "jazz.interface-keywords" "jazz.parse-keywords" "body" "attributes" "ascendant-names" "metaclass-name" "%%cdr" "jazz.Any" "type" "%%car" "name" "let" "jazz.interface-modifiers" "jazz.parse-modifiers" "implementor" "compatibility" "access" "receive" "rest" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.walk-interface-declaration" define #f 1834 9 1834 40 ("jazz.walk-error" "jazz.walk-declarations" "%%cons" "new-environment" "jazz.setup-interface-lookups" "jazz.add-declaration-child" "effective-declaration" "jazz.new-interface-declaration" "new-declaration" "jazz.listify" "ascendant-name" "lambda" "map" "ascendants" "jazz.lookup-reference" "Interface" "'Interface" "%%eq?" "jazz.unspecified?" "or" "metaclass" "let" "jazz.Library-Declaration" "%%class-is?" "if" "%%cdr" "jazz.parse-interface" "body" "attributes" "ascendant-names" "metaclass-name" "implementor" "compatibility" "access" "type" "name" "receive" "form" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.walk-interface" define #f 1848 9 1848 28 ("%%set-declaration-source" "jazz.walk-namespace" "%%set-namespace-declaration-body" "%%cons" "new-environment" "jazz.find-form-declaration" "new-declaration" "let*" "%%cdr" "jazz.parse-interface" "body" "attributes" "ascendant-names" "metaclass-name" "implementor" "compatibility" "access" "type" "name" "receive" "%%desourcify" "form" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.slot-modifiers" define #f 1864 8 1864 27 ()}
      {Lisp-Entry "jazz.slot-keywords" define #f 1868 8 1868 26 ()}
      {Lisp-Entry "jazz.slot-accessors-modifiers" define #f 1872 8 1872 37 ()}
      {Lisp-Entry "jazz.slot-accessor-modifiers" define #f 1880 8 1880 36 ()}
      {Lisp-Entry "jazz.parse-slot" define #f 1888 9 1888 24 ("values" "%%desourcify" "jazz.walk-error" "%%not-null?" "if" "jazz.slot-keywords" "jazz.parse-keywords" "setter" "getter" "accessors" "initialize" "specifier" "lambda" "jazz.parse-specifier" "%%car" "name" "let" "jazz.source-code" "%%cdr" "jazz.slot-modifiers" "jazz.parse-modifiers" "rest" "compatibility" "access" "receive" "form-src" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.expand-slot" define #f 1899 9 1899 25 ("%slot" "'%slot" "jazz.expand-slot-form" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.parse-slot-accessors" define #f 1903 9 1903 34 ("or" "values" "jazz.walk-error" "%%not-null?" "if" "jazz.slot-accessors-modifiers" "jazz.parse-modifiers" "rest" "generation" "expansion" "abstraction" "propagation" "access" "receive" "slot-access" "form" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.parse-slot-accessor" define #f 1910 9 1910 33 ("values" "jazz.walk-error" "else" "%%car" "%%cdr" "%%symbol->string" "%%string-append" "%%string->symbol" "generate" "'generate" "%%eq?" "and" "%%null?" "cond" "name" "or" "let" "jazz.slot-accessor-modifiers" "jazz.parse-modifiers" "rest" "generation" "expansion" "abstraction" "propagation" "access" "receive" "prefix" "form" "default-generation" "default-expansion" "default-abstraction" "default-propagation" "default-access" "slot-name" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.expand-slot-form" define #f 1928 9 1928 30 ("set!" ",value" ",setter-expansion" ",setter-abstraction" ",setter-propagation" "protected" "'protected" ",@specifier-list" ",getter-expansion" ",getter-abstraction" ",getter-propagation" "public" "'public" "or" "method" ",setter-name" ",getter-name" ",initialize" "with-self" "%%unspecified?" ",compatibility" ",access" ",specifier" ",name" ",symbol" "begin" "if" "specifier-list" "generate-setter?" "generate" "'generate" "%%eq?" "generate-getter?" "jazz.generate-symbol" "value" "let*" "setter-name" "setter-generation" "setter-expansion" "setter-abstraction" "setter-propagation" "setter-access" "jazz.parse-slot-accessor" "getter-name" "getter-generation" "getter-expansion" "getter-abstraction" "getter-propagation" "getter-access" "jazz.parse-slot-accessors" "default-generation" "default-expansion" "default-abstraction" "default-propagation" "default-access" "else" "%%list" "%%symbol?" "jazz.unspecified?" "cond" "jazz.desourcify" "info" "lambda" "standardize" "let" "jazz.parse-slot" "setter" "getter" "accessors" "initialize" "compatibility" "access" "specifier" "name" "receive" "symbol" "form-src" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.walk-%slot-declaration" define #f 1961 9 1961 36 ("jazz.add-declaration-child" "effective-declaration" "new-declaration" "jazz.new-slot-declaration" "jazz.new-property-declaration" "%property" "'%property" "%%car" "%%eq?" "new" "jazz.Any" "jazz.walk-specifier" "if" "type" "let" "%%cdr" "setter-name" "getter-name" "initialize" "compatibility" "access" "specifier" "name" "jazz.bind" "form" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.walk-%slot" define #f 1970 9 1970 24 ("%%set-declaration-source" ",name" "set!" ",setter-name" ",value" "jazz.generate-symbol" "value" "%%set-property-declaration-setter" ",getter-name" "with-self" "self" "lambda" "%%set-property-declaration-getter" "jazz.Property-Declaration" "%%class-is?" "%%when" "jazz.walk" "%%set-slot-declaration-initialize" "%%cadr" "jazz.find-form-declaration" "new-declaration" "jazz.unspecified?" "if" "%%cdr" "setter-name" "getter-name" "initialize" "compatibility" "access" "specifier" "name" "jazz.bind" "%%desourcify" "form" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.expand-property" define #f 2002 9 2002 29 ("%property" "'%property" "jazz.expand-slot-form" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.method-modifiers" define #f 2011 8 2011 29 ()}
      {Lisp-Entry "jazz.parse-method" define #f 2022 9 2022 26 ("values" "unspecified" "'unspecified" "%%list" "%%null?" "if" "effective-body" "body" "specifier" "lambda" "jazz.parse-specifier" "%%desourcify" "%%cdr" "jazz.wrap-parameters" "parameters" "name" "let" "jazz.desourcify-all" "method" "'method" "%%cons" "%%get-declaration-toplevel" "%%get-lexical-binding-name" "jazz.error" "%%car" "jazz.source-code" "%%pair?" "and" "%%assertion" "jazz.method-modifiers" "jazz.parse-modifiers" "synchronized" "remote" "expansion" "abstraction" "propagation" "compatibility" "access" "receive" "rest" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.walk-method-declaration" define #f 2033 9 2033 37 (",@body" "with-self" "jazz.walk" "%%set-method-declaration-body" "%%set-method-declaration-signature" "%%when" "jazz.add-declaration-child" "effective-declaration" "jazz.new-method-declaration" "new-declaration" "find-root-declaration" "root-declaration" "let*" "jazz.unspecified" "values" "jazz.walk-parameters" "augmented-environment" "signature" "concrete" "'concrete" "inline" "'inline" "%%eq?" "and" "inline?" "jazz.Procedure" "jazz.walk-specifier" "jazz.new-function-type" "if" "type" "let" "jazz.walk-error" "jazz.Category-Declaration" "%%class-is?" "%%assertion" "%%cdr" "jazz.parse-method" "body" "parameters" "synchronized" "remote" "expansion" "abstraction" "propagation" "compatibility" "access" "specifier" "name" "receive" "form" "environment" "declaration" "resume" "walker")
        {Lisp-Entry "find-root-declaration" define #f 2034 11 2034 32 ("%%get-declaration-parent" "%%eq?" "if" "%%get-method-declaration-root" "or" "and" "root-declaration" "jazz.private-access" "declaration" "jazz.lookup-declaration" "next-declaration" "let*" "name")}}
      {Lisp-Entry "jazz.walk-method" define #f 2063 9 2063 25 ("%%set-declaration-source" "%%set-method-declaration-body" "%%set-method-declaration-signature" "inline" "'inline" "%%when" "concrete" "'concrete" ",@body" "with-self" "%%get-lexical-binding-type" "nextmethod" "'nextmethod" "jazz.new-nextmethod-variable" "%%cons" "jazz.walk" "body-expression" "let" "jazz.walk-parameters" "augmented-environment" "signature" "else" "'virtual" "jazz.Interface-Declaration" "%%not" "case" "'inherited" "%%neq?" "chained" "virtual" "inherited" "final" "%%memq" "%%eq?" "cond" "root-category-declaration" "%%get-method-declaration-propagation" "and" "root-method-propagation" "%%get-method-declaration-root" "root-method-declaration" "%%get-declaration-parent" "category-declaration" "jazz.private-access" "jazz.lookup-declaration" "new-declaration" "let*" "jazz.walk-error" "jazz.Category-Declaration" "%%class-is?" "%%assertion" "jazz.source-code" "%%cdr" "jazz.parse-method" "body" "parameters" "synchronized" "remote" "expansion" "abstraction" "propagation" "compatibility" "access" "specifier" "name" "receive" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.wrap-parameters" define #f 2100 9 2100 29 ("jazz.queue-list" "%%cdr" "with-self" ",@specifier-list" "%%cadr" "%%list" "specifier-list" "rest" "specifier" "lambda" "%%cddr" "jazz.parse-specifier" "%%keyword?" "jazz.enqueue" "jazz.specifier?" "%%pair?" "if" "%%car" "parameter" "else" "jazz.enqueue-list" "%%symbol?" "%%null?" "cond" "scan" "iter" "jazz.new-queue" "queue" "let" "parameters")}
      {Lisp-Entry "jazz.walk-cast" define #f 2130 9 2130 23 ("jazz.walk" "jazz.walk-specifier" "jazz.new-cast" "%%cddr" "%%car" "expression" "%%cadr" "specifier" "%%desourcify" "form" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.walk-construct" define #f 2143 9 2143 28 ("jazz.walk-list" "jazz.walk" "jazz.new-construct" "%%cddr" "values" "%%cadr" "class" "%%desourcify" "form" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.walk-with-self" define #f 2156 9 2156 28 ("jazz.walk-body" "%%cdr" "body" "jazz.new-with-self" "jazz.new-self-binding" "%%cons" "new-environment" "%%desourcify" "form" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.parse-with-dynamic-self" define #f 2169 9 2169 37 ("values" "%%cdr" "body" "%%car" "code" "let" "form")}
      {Lisp-Entry "jazz.walk-with-dynamic-self-declaration" define #f 2175 9 2175 48 ("jazz.walk-declarations" "%%cdr" "jazz.parse-with-dynamic-self" "body" "code" "receive" "form" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.walk-with-dynamic-self" define #f 2180 9 2180 36 ("jazz.walk-list" "jazz.new-with-dynamic-self" "jazz.new-dynamic-self-binding" "%%cons" "new-environment" "let" "%%desourcify" "%%cdr" "jazz.parse-with-dynamic-self" "body" "code" "receive" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.parse-with-local-variables" define #f 2193 9 2193 40 ("values" "%%cdr" "body" "%%car" "variables" "let" "form")}
      {Lisp-Entry "jazz.walk-with-local-variables-declaration" define #f 2199 9 2199 51 ("jazz.walk-declarations" "%%cdr" "jazz.parse-with-local-variables" "body" "variables" "receive" "form" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.walk-with-local-variables" define #f 2204 9 2204 39 ("jazz.walk-list" "jazz.new-begin" "jazz.new-local-variable-binding" "variable" "lambda" "map" "jazz.new-walk-frame" "%%cons" "new-environment" "let" "%%desourcify" "%%cdr" "jazz.parse-with-local-variables" "body" "variables" "receive" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.validate-proclaim" define-generic/specific ("jazz.Jazz-Walker") 2215 21 2215 43 ("walker" "jazz.walk-error" "jazz.Category-Declaration" "jazz.Library-Declaration" "%%class-is?" "%%not" "and" "if" "form-src" "environment" "declaration" "resume")}
      {Lisp-Entry "jazz.remotable-stub-modifiers" define #f 2226 8 2226 37 ()}
      {Lisp-Entry "jazz.remotable-stub-keywords" define #f 2229 8 2229 36 ()}
      {Lisp-Entry "jazz.parse-remotable-stub" define #f 2233 9 2233 34 ("values" "jazz.remotable-stub-keywords" "jazz.parse-keywords" "body" "ascendant-name" "%%cdr" "%%car" "name" "let" "jazz.remotable-stub-modifiers" "jazz.parse-modifiers" "access" "receive" "rest" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.method-stub-modifiers" define #f 2241 8 2241 34 ()}
      {Lisp-Entry "jazz.parse-method-stub" define #f 2247 9 2247 31 ("jazz.Any" "values" "body" "%%cdr" "parameters" "name" "%%car" "signature" "let*" "jazz.method-stub-modifiers" "jazz.parse-modifiers" "passage" "invocation" "access" "receive" "rest" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.expand-remotable-stub" define #f 2256 9 2256 35 ("Remote-Proxy" "'Remote-Proxy" ",@values-method" "implements" "Local-Proxy" "'Local-Proxy" "metaclass" "Remotable-Stub" "'Remotable-Stub" ",stub-interface" ",stub-access" "interface" ",remote-class" ",local-class" "Stub-Interface" "'Stub-Interface" "jazz.specified?" "extends" ",interface-class" "package" "class" "begin" "nextmethod" ",@values-list" "list" "append" "proxy-values" "values-method" "values-list" ",call" "function" ",value-keyword" "proxy-value" "self" "',name" ",invoker" "if" ",dispatch" ",@local-result" ",rest" ",@positional" "object" "" "apply" "%%not-null?" "%%when" ",@parameters" ",name" "abstract" "virtual" ",access" "value-keyword" "unspecified" "local-result" "dispatch" "call-remote" "'call-remote" "call" "exec-remote" "'exec-remote" "exec" "post-remote" "'post-remote" "post" "invoker" "jazz.parse-method-stub" "invocation" "access" "method" "'method" "%%eq?" "method-form" "lambda" "for-each" "remotes" "locals" "proxies" "remote-class" "local-class" "stub-interface" "interface-class" "jazz.string->keyword" "0" "%%substring" "%%string=?" "4" "%%fx>" "and" "%%assert" "%%string-length" "len" "str" "let*" "value" "reference" "case" "passage" "parse-value-keyword" "%%cdr" "jazz.enqueue" "%%car" "else" "jazz.enqueue-list" "%%symbol?" "jazz.queue-list" "values" "%%null?" "cond" "scan" "iter" "parameter" "encode" "positional" "jazz.new-queue" "parameters" "let" "params" "parse-parameters" "%%symbol->string" "%%string-append" "%%string->symbol" "suffix" "add" "define" "jazz.parse-remotable-stub" "body" "ascendant-name" "stub-access" "type" "name" "receive" "rest" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.expand-com-external" define #f 2399 9 2399 33 ("jazz.emit-com-external" ",name" "public" "jazz.emit-com-function" ",lowlevel-name" "definition" "begin" "%%cons" "jazz.C-Type-Declaration" "%%class-is?" "resolved" "jazz.every?" "jazz.platform.windows.com.HRESULT" "'jazz.platform.windows.com.HRESULT" "%%get-declaration-locator" "%%eq?" "hresult?" "%%symbol->string" "%%string-append" "%%string->symbol" "lowlevel-name" "car" "resolved-directions" "resolved-params" "resolved-result" "let" "jazz.walk-error" "jazz.resolve-c-type-reference" "%%symbol?" "type" "lambda" "resolve-declaration" "%%null?" "if" "refiid" "%%cdr" "cadr" "map" "param-types" "%%car" "name" "let*" "rest" "signature" "result-type" "offset" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.emit-com-function" define #f 2417 9 2417 31 ("resolved-params" "param-types" "resolved-result" "result-type" "offset")
        {Lisp-Entry "fix-locator" define #f 2418 11 2418 22 ("%%symbol->string" "%%string-append" "%%string->symbol" "'type" "%%get-c-type-declaration-kind" "%%eq?" "if" "declaration" "type")}}
      {Lisp-Entry "jazz.emit-com-external" define #f 2448 9 2448 31 ("'result" "%%fx=" ",@out-list" "values" "else" "%%car" "1" "unspecified" "0" "%%length" "case" "generate-free" "generate-ref" "begin" "validate-hresult" ",refiid" "validate-hresult2" "if" "generate-low" ",lowlevel-name" "result" "generate-encode/enref" "generate-in" "coptr" "function" "generate-out" "generate-cotype-transform" "out-list" "let" "refiid" "resolved-directions" "resolved-params" "lowlevel-name" "hresult?")
        {Lisp-Entry "generate-in" define #f 2449 11 2449 22 ("%%number->string" "%%string-append" "%%string->symbol" "out" "'out" "%%eq?" "if" "order" "resolved-direction" "resolved-param")}
        {Lisp-Entry "generate-low" define #f 2454 11 2454 23 ("%%number->string" "%%string-append" "%%string->symbol" "order" "resolved-direction" "resolved-param")}
        {Lisp-Entry "generate-out" define #f 2457 11 2457 23 ("%%number->string" "%%string-append" "%%string->symbol" "in" "'in" "%%eq?" "if" "order" "resolved-direction" "resolved-param")}
        {Lisp-Entry "generate-encode/enref" define #f 2462 11 2462 32 (",value" ",encode/enref" ",binding" "generate-in" "get-cotype-default-value" "out" "'out" "%%eq?" "if" "value" "get-cotype-encode/enref" "encode/enref" "generate-low" "binding" "let" "order" "resolved-direction" "resolved-param")}
        {Lisp-Entry "generate-ref" define #f 2472 11 2472 23 (",value" ",ref" ",binding" "generate-low" "value" "get-cotype-ref" "ref" "generate-out" "binding" "let" "in" "'in" "%%eq?" "if" "order" "resolved-direction" "resolved-param")}
        {Lisp-Entry "generate-free" define #f 2482 11 2482 24 (",value" ",free" "if" "generate-low" "value" "get-cotype-free" "free" "let" "order" "resolved-direction" "resolved-param")}
        {Lisp-Entry "generate-cotype-transform" define #f 2489 11 2489 36 ("%%fx+" "%%cdr" "cons" "%%car" "generated" "%%pair?" "if" "1" "order" "resolved-directions" "resolved-params" "iter" "let" "generator")}}
      {Lisp-Entry "get-cotype-default-value" define #f 2525 9 2525 33 ("else" "jazz.platform.windows.WinTypes.LONG*" "0" "jazz.platform.windows.WinTypes.INT*" "jazz.platform.windows.com.IUnknown**" "jazz.platform.windows.com.IUnknown*" "jazz.platform.windows.com.VARIANT*" "jazz.platform.windows.com.VARIANT" "jazz.platform.windows.com.VARIANT_BOOL*" "jazz.platform.windows.com.VARIANT_BOOL" "jazz.platform.windows.com.GUID*" "jazz.platform.windows.com.GUID" "jazz.platform.windows.com.BSTR*" "error" "jazz.platform.windows.com.BSTR" "%%get-declaration-locator" "case" "cotype")}
      {Lisp-Entry "get-cotype-encode/enref" define #f 2542 9 2542 32 ("else" "LONG-enref" "'LONG-enref" "jazz.platform.windows.WinTypes.LONG*" "INT-enref" "'INT-enref" "jazz.platform.windows.WinTypes.INT*" "IUnknown*-enref" "'IUnknown*-enref" "jazz.platform.windows.com.IUnknown**" "jazz.platform.windows.com.IUnknown*" "jazz.platform.windows.com.VARIANT*" "VARIANT-encode" "'VARIANT-encode" "jazz.platform.windows.com.VARIANT" "VARIANT_BOOL-enref" "'VARIANT_BOOL-enref" "jazz.platform.windows.com.VARIANT_BOOL*" "VARIANT_BOOL-encode" "'VARIANT_BOOL-encode" "jazz.platform.windows.com.VARIANT_BOOL" "jazz.platform.windows.com.GUID*" "GUID-encode" "'GUID-encode" "jazz.platform.windows.com.GUID" "BSTR*-enref" "'BSTR*-enref" "jazz.platform.windows.com.BSTR*" "BSTR-encode" "'BSTR-encode" "jazz.platform.windows.com.BSTR" "%%get-declaration-locator" "case" "cotype")}
      {Lisp-Entry "get-cotype-ref" define #f 2559 9 2559 23 ("else" "LONG*-ref" "'LONG*-ref" "jazz.platform.windows.WinTypes.LONG*" "INT*-ref" "'INT*-ref" "jazz.platform.windows.WinTypes.INT*" "IUnknown**-ref" "'IUnknown**-ref" "jazz.platform.windows.com.IUnknown**" "jazz.platform.windows.com.IUnknown*" "jazz.platform.windows.com.VARIANT*" "VARIANT-ref" "'VARIANT-ref" "jazz.platform.windows.com.VARIANT" "VARIANT_BOOL*-ref" "'VARIANT_BOOL*-ref" "jazz.platform.windows.com.VARIANT_BOOL*" "VARIANT_BOOL-decode" "'VARIANT_BOOL-decode" "jazz.platform.windows.com.VARIANT_BOOL" "jazz.platform.windows.com.GUID*" "GUID-ref" "'GUID-ref" "jazz.platform.windows.com.GUID" "BSTR*-ref" "'BSTR*-ref" "jazz.platform.windows.com.BSTR*" "BSTR-ref" "'BSTR-ref" "jazz.platform.windows.com.BSTR" "%%get-declaration-locator" "case" "cotype")}
      {Lisp-Entry "get-cotype-free" define #f 2576 9 2576 24 ("else" "LONG*-free" "'LONG*-free" "jazz.platform.windows.WinTypes.LONG*" "INT*-free" "'INT*-free" "jazz.platform.windows.WinTypes.INT*" "IUnknown**-free" "'IUnknown**-free" "jazz.platform.windows.com.IUnknown**" "jazz.platform.windows.com.IUnknown*" "jazz.platform.windows.com.VARIANT*" "VARIANT-decode" "'VARIANT-decode" "jazz.platform.windows.com.VARIANT" "VARIANT_BOOL*-free" "'VARIANT_BOOL*-free" "jazz.platform.windows.com.VARIANT_BOOL*" "jazz.platform.windows.com.VARIANT_BOOL" "jazz.platform.windows.com.GUID*" "GUID-free" "'GUID-free" "jazz.platform.windows.com.GUID" "BSTR*-free" "'BSTR*-free" "jazz.platform.windows.com.BSTR*" "BSTR-free" "'BSTR-free" "jazz.platform.windows.com.BSTR" "%%get-declaration-locator" "case" "cotype")}
      {Lisp-Entry "jazz.expand-assert" define #f 2598 9 2598 27 ("jazz.expand-assert-test" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.expand-assertion" define #f 2603 9 2603 30 ("jazz.expand-assertion-test" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.expand-assert-test" define #f 2608 9 2608 32 ("error" "'error" "%%list" "jazz.expand-assertion-body" "get-output-string" "%%desourcify" "write" "display" "open-output-string" "port" "message" "%%cddr" "body" "jazz.source-code" "%%cadr" "assertion" "let" "src" "test?")}
      {Lisp-Entry "jazz.expand-assertion-test" define #f 2619 9 2619 35 ("jazz.expand-assertion-body" "%%cdr" "body" "%%cddr" "%%car" "action" "jazz.source-code" "%%cadr" "assertion" "let" "src" "test?")}
      {Lisp-Entry "jazz.expand-assertion-body" define #f 2626 9 2626 35 (",@body" "begin" "jazz.simplify-begin" ",action" ",assertion" "not" "unspecified" "%%not-null?" "if" "let" "body" "action" "assertion" "test?")}
      {Lisp-Entry "jazz.walk-declare" define #f 2642 9 2642 26 ("jazz.new-declare" "%%cdr" "declarations" "%%desourcify" "form" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.walk-c-include" define #f 2653 9 2653 28 ("jazz.new-c-include" "%%cdr" "name" "jazz.bind" "%%desourcify" "form" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.walk-c-declare" define #f 2664 9 2664 28 ("jazz.new-c-declare" "%%cdr" "code" "jazz.bind" "%%desourcify" "form" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.c-named-declare-modifiers" define #f 2675 8 2675 38 ()}
      {Lisp-Entry "jazz.parse-c-named-declare" define #f 2680 9 2680 35 ("values" "jazz.Any" "type" "let" "code" "name" "jazz.bind" "jazz.c-named-declare-modifiers" "jazz.parse-modifiers" "compatibility" "access" "receive" "rest" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.walk-c-named-declare-declaration" define #f 2687 9 2687 46 ("jazz.add-declaration-child" "effective-declaration" "jazz.new-c-named-declare-declaration" "new-declaration" "let" "%%cdr" "jazz.parse-c-named-declare" "code" "compatibility" "access" "type" "name" "receive" "form" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.resolve-c-named-declare-reference" define #f 2694 9 2694 47 ("%%get-declaration-locator" "jazz.walk-error" "jazz.C-Named-Declare-Declaration" "%%class-is?" "if" "jazz.lookup-reference" "c-named-declare-declaration" "let" "symbol" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.walk-c-named-declare" define #f 2701 9 2701 34 ("jazz.find-form-declaration" "new-declaration" "%%cdr" "jazz.parse-c-named-declare" "code" "compatibility" "access" "type" "name" "receive" "%%desourcify" "form" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.walk-c-initialize" define #f 2713 9 2713 31 ("jazz.new-c-initialize" "%%cdr" "code" "jazz.bind" "%%desourcify" "form" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.c-type-modifiers" define #f 2724 8 2724 29 ()}
      {Lisp-Entry "jazz.parse-c-type" define #f 2729 9 2729 26 ("declare" "scheme-to-c" "c-to-scheme" "values" "%%null?" "if" "jazz.Any" "type" "let" "conversions" "c-type" "name" "jazz.bind" "jazz.c-type-modifiers" "jazz.parse-modifiers" "compatibility" "access" "receive" "rest" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.walk-c-type-declaration" define #f 2739 9 2739 37 ("jazz.add-declaration-child" "effective-declaration" "%%get-c-type-declaration-pointer-types" "%%set-c-type-declaration-pointer-types" "%%when" "jazz.new-c-type-declaration" "new-declaration" "jazz.walk-error" "jazz.resolve-c-named-declare-reference" "%%cons" "%%string?" "let" "jazz.resolve-c-type" "inclusions" "base-type-declaration" "expansion" "kind" "jazz.Library-Declaration" "%%class-is?" "if" "%%cdr" "jazz.parse-c-type" "declare" "scheme-to-c" "c-to-scheme" "c-type" "compatibility" "access" "type" "name" "receive" "form" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.walk-c-type" define #f 2756 9 2756 25 ("jazz.find-form-declaration" "%%cdr" "jazz.parse-c-type" "declare" "scheme-to-c" "c-to-scheme" "c-type" "compatibility" "access" "type" "name" "receive" "%%desourcify" "form" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.resolve-c-type" define #f 2762 9 2762 28 ("jazz.queue-list" "base-type-declaration" "expansion" "kind" "receive" "jazz.error" "else" "'union" "union" "'struct" "struct" "map" "'function" "result-type" "parameter-types" "function" "and" "resolve-expansion" "'pointer" "base-type" "pointer" ",@tag-rest" ",c-string" "%%cdr" "tag-rest" "c-string" "jazz.bind" "%%cadr" "'native" "native" "%%car" "case" "%%pair?" "'type" "%%string?" "%%get-declaration-locator" "alias" "'alias" "values" "jazz.enqueue" "jazz.resolve-c-type-reference" "c-type-declaration" "%%symbol?" "cond" "resolve" "define" "jazz.new-queue" "queue" "let" "type" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.resolve-c-type-reference" define #f 2802 9 2802 38 ("%%get-declaration-locator" "jazz.walk-error" "jazz.C-Type-Declaration" "%%class-is?" "if" "jazz.lookup-reference" "c-type-declaration" "let" "symbol" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.expand-c-type-reference" define #f 2809 9 2809 37 ("%%get-library-declaration-inclusions" "%%append" "%%set-library-declaration-inclusions" "%%get-declaration-toplevel" "library-declaration" "let" "jazz.resolve-c-type" "inclusions" "base-type-declaration" "expansion" "kind" "receive" "type" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.walk-c-function" define #f 2821 9 2821 29 (",c-name-or-code" "map" "c-lambda" "jazz.new-c-function" "jazz.expand-c-type-reference" "type" "lambda" "resolve-access" "%%cdr" "c-name-or-code" "result-type" "types" "jazz.bind" "jazz.error" "%%length" "4" "%%fx=" "list?" "and" "%%assertion" "%%desourcify" "form" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.c-definition-modifiers" define #f 2835 8 2835 35 ()}
      {Lisp-Entry "jazz.parse-c-definition" define #f 2840 9 2840 32 ("values" "%%cdr" "parameters" "jazz.Any" "type" "%%car" "name" "let" "body" "scope" "c-name" "result-type" "parameter-types" "signature" "jazz.bind" "jazz.c-definition-modifiers" "jazz.parse-modifiers" "compatibility" "access" "receive" "rest" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.walk-c-definition-declaration" define #f 2849 9 2849 43 ("jazz.add-declaration-child" "effective-declaration" "map" "jazz.new-c-definition-declaration" "new-declaration" "jazz.walk-parameters" "signature" "jazz.expand-c-type-reference" "lambda" "resolve-access" "let" "%%cdr" "jazz.parse-c-definition" "body" "scope" "c-name" "result-type" "parameter-types" "parameters" "compatibility" "access" "type" "name" "receive" "form" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.walk-c-definition" define #f 2858 9 2858 31 ("%%set-declaration-source" "jazz.walk-body" "%%set-c-definition-declaration-body" "%%set-c-definition-declaration-signature" "jazz.walk-parameters" "augmented-environment" "signature" "jazz.find-form-declaration" "new-declaration" "let*" "%%cdr" "jazz.parse-c-definition" "body" "scope" "c-name" "result-type" "parameter-types" "parameters" "compatibility" "access" "type" "name" "receive" "%%desourcify" "form" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.build-pointer-symbol" define #f 2875 9 2875 34 ("%%symbol->string" "%%string-append" "%%string->symbol" "type")}
      {Lisp-Entry "jazz.pointer?" define #f 2879 9 2879 22 ("1" "%%fx-" "%%string-ref" "%%eq?" "%%string-length" "lgt" "%%symbol->string" "str" "let*" "type")}
      {Lisp-Entry "jazz.build-method-symbol" define #f 2885 9 2885 33 ("symbol->string" "map" "%%symbol->string" "string-append" "apply" "%%string->symbol" "rest" "struct")}
      {Lisp-Entry "jazz.parse-structure-name" define #f 2889 9 2889 34 ("%%cddr" "%%cadr" "%%car" "%%symbol->string" "values" "%%symbol?" "if" "name")}
      {Lisp-Entry "jazz.kind+type" define #f 2895 9 2895 23 ("values" "%%car" "alias" "'alias" "%%eq?" "if" "%%get-c-type-declaration-inclusions" "inclusions" "%%get-c-type-declaration-expansion" "expansion" "%%get-c-type-declaration-kind" "kind" "jazz.resolve-c-type-reference" "loop" "let" "type" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.expand-accessor" define #f 2905 9 2905 29 ("values" ",setter-string" "void" "-set!" "'-set!" "setter" ",getter-string" ",type" ",struct*" "c-function" "-ref" "'-ref" "jazz.build-method-symbol" "public" "definition" "getter" "%%memq" "wchar_t-string" "char-string" "type*" "jazz.build-pointer-symbol" "struct*" "let*" "'type" "'union" "'struct" "else" "%%number->string" "size-string" "cond" "setter-string" "union" "function" "pointer" "native" "case" "%%string-append" "wchar_t" "'wchar_t" "char" "'char" "%%eq?" "or" "if" "getter-string" "%%symbol->string" "id-string" "jazz.kind+type" "expansion" "kind" "receive" "jazz.walk-error" "%%symbol?" "%%integer?" "%%when" "%%null?" "%%not" "and" "%%cddr" "clause-rest" "size" "%%cadr" "id" "%%car" "type" "let" "struct" "clause" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.expand-structure/union" define #f 2961 9 2961 36 ("map" "append" "%%apply" "unsigned-int" "'sizeof" "void" "native" "free" "'free" "c-function" "make" "'make" "jazz.build-method-symbol" "public" "definition" ",@tag*-rest" "pointer" ",struct*" ",@tag-rest" ",c-struct-string" "type" ",struct" "c-type" "begin" "%%list" "jazz.expand-accessor" "setter" "getter" "clause" "expand-accessor" "define" "%%cdr" "%%car" "%%cons" "%%null?" "if" "tag*-rest" "%%string-append" "sizeof" "jazz.build-pointer-symbol" "struct*" "let" "jazz.parse-structure-name" "tag-rest" "c-struct-string" "struct" "receive" "clauses" "name" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.expand-c-structure" define #f 2983 9 2983 32 ("jazz.expand-structure/union" "clauses" "name" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.expand-c-structure-array" define #f 2987 9 2987 38 ("array-element" "'array-element" "%%string-append" ",struct*" "int" "c-function" "array-make" "'array-make" "jazz.build-method-symbol" "public" "definition" "begin" "%%symbol->string" "%%car" "%%null?" "%%not" "if" "c-struct-string" "jazz.build-pointer-symbol" "struct*" "struct" "let*" "rest" "name" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.expand-c-union" define #f 2998 9 2998 28 ("jazz.expand-structure/union" "clauses" "name" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.expand-c-external" define #f 3007 9 3007 31 (",c-name" ",type" ",params" "c-function" ",s-name" "public" "definition" "%%symbol->string" "%%null?" "if" "c-name" "%%cdr" "params" "%%car" "s-name" "let*" "rest" "signature" "type" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.expand-c-external-so" define #f 3016 9 3016 34 ("WCHAR-string" "values" ",ext-s-name" "result" "WCHAR-copy" "1" ",string-param" "string-length" "+" "WCHAR-array-make" "pt" "let" ",@new-params" ",s-name" "public" "definition" ",c-name" "%%cons" ",type" "c-external" "begin" "%%null?" "if" "c-name" "list-ref" "string-param" "jazz.generate-symbol" "param" "lambda" "map" "new-params" "%%cdr" "params" "%%symbol->string" "%%string-append" "%%string->symbol" "ext-s-name" "%%car" "s-name" "let*" "rest" "signature" "arg" "type" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.parse-function" define #f 3038 9 3038 28 ("values" "unspecified" "'unspecified" "%%list" "%%null?" "if" "effective-body" "body" "%%car" "%%desourcify" "parameters" "jazz.source-code" "%%cdr" "rest" "let*" "form-src" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.walk-function" define #f 3046 9 3046 27 (",@body" ",parameters" "lambda" "jazz.walk-lambda" "jazz.parse-function" "body" "parameters" "receive" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.walk-parameterize" define #f 3059 9 3059 31 ("jazz.walk-body" "jazz.queue-list" "jazz.new-parameterize" "jazz.walk" "%%cons" "jazz.enqueue" "%%cdr" "value" "%%car" "variable" "continuation-capture" "binding-form" "lambda" "for-each" "jazz.new-queue" "expanded-bindings" "unspecified" "'unspecified" "%%list" "%%null?" "if" "effective-body" "%%cddr" "body" "%%cadr" "jazz.source-code" "bindings" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.walk-with-slots" define #f 3086 9 3086 29 (",@body" ",setter-name" "',setter-name" "value" "',object-symbol" ",getter-name" "',getter-name" "%%list" "%%get-slot-declaration-setter-name" "setter-name" "%%get-slot-declaration-getter-name" "getter-name" "jazz.lookup-reference" "slot-declaration" "let*" "slot-name" "lambda" "map" "let-symbol" ",object" ",object-symbol" "jazz.walk" "jazz.generate-symbol" "object-symbol" "%%cdr" "body" "object" "slot-names" "jazz.bind" "%%desourcify" "form" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.walk-time" define #f 3106 9 3106 23 ("jazz.walk-list" "jazz.new-time-special" "%%cdr" "forms" "%%desourcify" "form" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.expand-form" define #f 3117 9 3117 25 ("nextmethod" "cons" "get-class-forms" "get-class-form" "method" ",class-locator" "',class-locator" "register-form" ",class-name" ",form" "',form" "jml->form>>" "class-form" "definition" "begin" "%%get-declaration-locator" "class-locator" "%%get-lexical-binding-name" "class-name" "let*" "form" "environment" "declaration" "resume" "walker")}}})
"ecase"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "dialect" "syntax" "ecase.scm"} 1252768922
    {Lisp-Entry "jazz.dialect.syntax.ecase" library #f 37 19 37 44 ("scheme")
      {Lisp-Entry "private" native #f 43 8 43 15 ("jazz.error")}
      {Lisp-Entry "ecase" macro #f 53 16 53 21 ("desourcify" "error" "eqv?" "'eqv?" "=" "'=" "list" "integer?" "if" "value" "or" "'or" "pair?" "cons" "else" "'else" "eq?" "cdr" "body" "car" "selector" "clause" "map" "cond" "symbol" "lambda" "with-uniqueness" "sourcify-if" "cddr" "clauses" "source-code" "cadr" "target" "let" "form-src")}}})
"either"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "dialect" "syntax" "either.scm"} 1248708411
    {Lisp-Entry "jazz.dialect.syntax.either" library #f 37 19 37 45 ("scheme")
      {Lisp-Entry "private" native #f 45 8 45 15 ("jazz.error")}
      {Lisp-Entry "either" macro #f 51 16 51 22 ("'let" "generate-symbol" "symbol" "'if" "list" "rest" "expr" "bind" "pair" "lambda" "proc" "letrec" "set!" "car" "symbol?" "when" "not" "while" "complex?" "scan" "sourcify-if" "error" "null?" "if" "source-code" "cdr" "expressions" "let" "form-src")}}})
"enumeration"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "dialect" "syntax" "enumeration.scm"} 1238328026
    {Lisp-Entry "jazz.dialect.syntax.enumeration" library #f 37 19 37 50 ("scheme")}})
"essay"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "dialect" "syntax" "essay.scm"} 1248797037
    {Lisp-Entry "jazz.dialect.syntax.essay" library #f 37 19 37 44 ("scheme")
      {Lisp-Entry "private" native #f 43 8 43 15 ("jazz.butlast")}
      {Lisp-Entry "private" native #f 44 8 44 15 ("jazz.error")}
      {Lisp-Entry "private" native #f 45 8 45 15 ("jazz.last")}
      {Lisp-Entry "essay" macro #f 50 16 50 21 (",expr" ",@tests" "and" "when" "last" "expr" "butlast" "tests" "sourcify-if" "error" "null?" "if" "source-code" "cdr" "expressions" "let" "form-src")}}})
"exception"
 ({Lisp-File-Entry {File jazz "src" "jazz" "dialect" "language" "exception.jazz"} 1252768922
    {Lisp-Entry "jazz.dialect.language.exception" library #f 37 19 37 50 ("jazz.dialect")
      {Lisp-Entry "*exception-debugger*" definition #f 55 12 55 32 ()}
      {Lisp-Entry "get-exception-debugger" definition #f 59 20 59 42 ("*exception-debugger*")}
      {Lisp-Entry "set-exception-debugger" definition #f 62 20 62 42 ("*exception-debugger*" "set!" "exception-debugger")}
      {Lisp-Entry "current-exception-debugger" definition #f 66 12 66 38 ("make-parameter")}
      {Lisp-Entry "exception-debugger-hook" definition #f 70 21 70 44 ("system-exception-hook" "if" "*exception-debugger*" "current-exception-debugger" "either" "exception-debugger" "let" "other" "exc")}
      {Lisp-Entry "with-exception-debugger" definition #f 77 20 77 43 ("current-exception-debugger" "parameterize" "thunk" "exception-debugger")}
      {Lisp-Entry "system-exception-debugger" definition #f 82 20 82 45 ("system-exception-hook" "invoke-exception-hook" "exc")}
      {Lisp-Entry "with-system-exception-debugger" definition #f 86 20 86 50 ("system-exception-debugger" "with-exception-debugger" "thunk")}
      {Lisp-Entry "Exception" class #f 91 7 91 16 ("Object")
        {Lisp-Entry "get-message" method #f 94 26 94 37 ()}
        {Lisp-Entry "present-message" method #f 98 26 98 41 ("get-message" "list" "rest")}
        {Lisp-Entry "print" method #f 102 11 102 16 ("get-message" "format" "function" "self" "print-unreadable" "readably" "printer")}}
      {Lisp-Entry "exception?" definition #f 108 20 108 30 ("Exception" "is?" "object?" "and" "obj")}
      {Lisp-Entry "Exception-Detail" class #f 113 15 113 31 ("Object")
        {Lisp-Entry "icon" slot #f 116 8 116 12 ()}
        {Lisp-Entry "get-icon" accessor #f 116 24 116 32 ()}
        {Lisp-Entry "title" slot #f 117 8 117 13 ()}
        {Lisp-Entry "get-title" accessor #f 117 24 117 32 ()}
        {Lisp-Entry "location" slot #f 118 8 118 16 ()}
        {Lisp-Entry "get-location" accessor #f 118 24 118 32 ()}
        {Lisp-Entry "children" slot #f 119 8 119 16 ()}
        {Lisp-Entry "get-children" accessor #f 119 24 119 32 ()}
        {Lisp-Entry "initialize" method #f 122 11 122 21 ("children~self" "location~self" "title~self" "icon~self" "set!" "nextmethod" "children" "location" "title" "icon")}
        {Lisp-Entry "print" method #f 130 11 130 16 ("children" "location" "title" "icon" "self" "class-of" "type-name" "identifier-name" "format" "readably" "printer")}}
      {Lisp-Entry "System-Exception" class #f 139 7 139 23 ("Exception")
        {Lisp-Entry "exception" slot #f 142 8 142 17 ()}
        {Lisp-Entry "get-exception" accessor #f 142 25 142 33 ()}
        {Lisp-Entry "initialize" method #f 145 11 145 21 ("exception~self" "set!" "nextmethod" "exception")}}
      {Lisp-Entry "wrap-exception" definition #f 150 20 150 34 ("System-Exception" "new" "exception?" "if" "obj")}
      {Lisp-Entry "Continue" class #f 156 7 156 15 ("Exception")}
      {Lisp-Entry "Error" class #f 159 7 159 12 ("generate" "inherited" "Exception")
        {Lisp-Entry "message" slot #f 162 8 162 15 ()}
        {Lisp-Entry "set-message" accessor #f 162 23 162 31 ()}
        {Lisp-Entry "initialize" method #f 165 11 165 21 ("set-message" "nextmethod" "message" "message:")}}
      {Lisp-Entry "error?" definition #f 170 20 170 26 ("Error" "is?" "object?" "and" "obj")}
      {Lisp-Entry "Read-Error" class #f 175 15 175 25 ("Error")
        {Lisp-Entry "source" slot #f 178 8 178 14 ()}
        {Lisp-Entry "start" slot #f 179 8 179 13 ()}
        {Lisp-Entry "end" slot #f 180 8 180 11 ()}
        {Lisp-Entry "initialize" method #f 183 11 183 21 ("end~self" "start~self" "source~self" "set!" "nextmethod" "apply" "others" "end" "start" "source" "bind-keywords" "rest")}
        {Lisp-Entry "get-source" method #f 191 18 191 28 ("source")}
        {Lisp-Entry "get-start" method #f 195 18 195 27 ("start")}
        {Lisp-Entry "get-end" method #f 199 18 199 25 ("end")}
        {Lisp-Entry "get-range" method #f 203 18 203 27 ("end" "start" "Range" "new")}}
      {Lisp-Entry "Parse-Error" class #f 207 15 207 26 ("Error")
        {Lisp-Entry "source" slot #f 210 8 210 14 ()}
        {Lisp-Entry "start" slot #f 211 8 211 13 ()}
        {Lisp-Entry "end" slot #f 212 8 212 11 ()}
        {Lisp-Entry "initialize" method #f 215 11 215 21 ("end~self" "start~self" "source~self" "set!" "nextmethod" "apply" "others" "end" "start" "source" "bind-keywords" "rest")}
        {Lisp-Entry "get-source" method #f 223 18 223 28 ("source")}
        {Lisp-Entry "get-start" method #f 227 18 227 27 ("start")}
        {Lisp-Entry "get-end" method #f 231 18 231 25 ("end")}}
      {Lisp-Entry "Convertion-Error" class #f 235 15 235 31 ("Parse-Error")
        {Lisp-Entry "object" slot #f 238 8 238 14 ()}
        {Lisp-Entry "type" slot #f 239 8 239 12 ()}
        {Lisp-Entry "initialize" method #f 242 11 242 21 ("type~self" "object~self" "set!" "nextmethod" "apply" "others" "type" "object" "bind-keywords" "rest")}
        {Lisp-Entry "get-object" method #f 249 18 249 28 ("object")}
        {Lisp-Entry "get-type" method #f 253 18 253 26 ("type")}
        {Lisp-Entry "get-message" method #f 257 11 257 22 ("format-gender" "object" "format" "type-name" "string?" "if" "type" "let")}}
      {Lisp-Entry "Signal" class #f 265 7 265 13 ("Exception")}
      {Lisp-Entry "Cancel-Signal" class #f 268 15 268 28 ("Signal")}
      {Lisp-Entry "call-with-catch" definition #f 271 20 271 35 ("is?" "object?" "and" "procedure?" "if" "obj" "function" "with-exception-filter" "thunk" "catcher" "predicate/type")}
      {Lisp-Entry "throw" definition #f 289 20 289 25 ("raise" "exception")}
      {Lisp-Entry "throw-cancel" definition #f 293 27 293 39 ("Cancel-Signal" "new" "throw")}
      {Lisp-Entry "signal" definition #f 297 19 297 25 ("throw")}
      {Lisp-Entry "error" definition #f 300 20 300 25 ("format" "apply" "message:" "Error" "new" "signal" "rest")}
      {Lisp-Entry "Restart" class #f 309 7 309 14 ("Object")
        {Lisp-Entry "name" slot #f 312 8 312 12 ()}
        {Lisp-Entry "get-name" accessor #f 312 23 312 31 ()}
        {Lisp-Entry "message" slot #f 313 8 313 15 ()}
        {Lisp-Entry "get-message" accessor #f 313 23 313 31 ()}
        {Lisp-Entry "handler" slot #f 314 8 314 15 ()}
        {Lisp-Entry "get-handler" accessor #f 314 23 314 31 ()}
        {Lisp-Entry "initialize" method #f 317 11 317 21 ("handler~self" "message~self" "name~self" "set!" "nextmethod" "handler" "message" "name")}
        {Lisp-Entry "print" method #f 324 11 324 16 ("name" "format" "function" "self" "print-unreadable" "readably" "printer")}}
      {Lisp-Entry "current-restarts" definition #f 331 19 331 35 ("make-parameter")}
      {Lisp-Entry "with-restart-handler" definition #f 335 20 335 40 ("Restart" "new" "cons" "current-restarts" "parameterize" "thunk" "handler" "message" "name")}
      {Lisp-Entry "with-restart-catcher" definition #f 340 20 340 40 ("else" "car" "null?" "not" "cond" "continuation-return" "rest" "with-restart-handler" "catcher-cont" "function" "continuation-capture" "thunk" "catcher" "message" "name")}
      {Lisp-Entry "find-restart" definition #f 352 20 352 32 ("current-restarts" "get-name" "eq?" "restart" "function" "find-if" "name")}
      {Lisp-Entry "find-restarts" definition #f 358 20 358 33 ("current-restarts" "get-name" "eq?" "restart" "function" "collect-if" "name")}
      {Lisp-Entry "invoke-restart" definition #f 364 20 364 34 ("apply" "get-handler" "handler" "let" "rest" "restart")}
      {Lisp-Entry "new-system-thread" definition #f 374 20 374 37 ("with-system-exception-debugger" "function" "new-thread" "apply" "rest" "thunk")}}}
  {Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "dialect" "core" "exception.scm"} 1250852530
    {Lisp-Entry "jazz.dialect.core.exception" module #f 39 18 39 45 ()
      {Lisp-Entry "jazz.get-exception-hook" define #f 47 9 47 32 ("##primordial-exception-handler-hook")}
      {Lisp-Entry "jazz.set-exception-hook" define #f 50 9 50 32 ("##primordial-exception-handler-hook" "set!" "hook")}
      {Lisp-Entry "jazz.invoke-exception-hook" define #f 54 9 54 35 ("##thread-end-with-uncaught-exception!" "exc" "hook")}
      {Lisp-Entry "jazz.system-exception-hook" define #f 63 9 63 35 ("##repl-exception-handler-hook" "other" "exc")}
      {Lisp-Entry "jazz.set-terminal-title" define #f 72 9 72 32 ("repl-output-port" "display")}
      {Lisp-Entry "jazz.bring-terminal-to-front" define #f 75 9 75 37 ("repl-output-port" "display")}
      {Lisp-Entry "jazz.clear-terminal" define #f 78 9 78 28 ("repl-output-port" "display")}
      {Lisp-Entry "jazz.with-exception-filter" define #f 87 9 87 35 ("%%continuation-graft" "filter-exc" "if" "exc" "with-exception-handler" "catcher-cont" "lambda" "%%continuation-capture" "current-exception-handler" "previous-handler" "let" "thunk" "catcher" "filter")}
      {Lisp-Entry "jazz.with-exception-propagater" define #f 112 9 112 39 ("current-exception-handler" "let" "%%continuation-graft" "raise-cont" "exc" "with-exception-handler" "catcher-cont" "lambda" "%%continuation-capture" "thunk" "handler")}}})
"foreign"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "dialect" "core" "foreign.scm"} 1238328026
    {Lisp-Entry "jazz.dialect.core.foreign" module #f 37 18 37 43 ()
      {Lisp-Entry "jazz.foreign?" define #f 42 12 42 25 ("foreign?")}
      {Lisp-Entry "jazz.foreign-address" define #f 43 12 43 32 ("foreign-address")}
      {Lisp-Entry "jazz.foreign-release!" define #f 44 12 44 33 ("foreign-release!")}
      {Lisp-Entry "jazz.foreign-released?" define #f 45 12 45 34 ("foreign-released?")}
      {Lisp-Entry "jazz.foreign-tags" define #f 46 12 46 29 ("foreign-tags")}
      {Lisp-Entry "jazz.still-obj-refcount-dec!" define #f 51 13 51 41 ("%%still-obj-refcount-dec!" "foreign")}
      {Lisp-Entry "jazz.still-obj-refcount-inc!" define #f 54 13 54 41 ("%%still-obj-refcount-inc!" "foreign")}}})
"format"
 ({Lisp-File-Entry {File jazz "src" "jazz" "dialect" "language" "format.jazz"} 1253358671
    {Lisp-Entry "jazz.dialect.language.format" library #f 37 19 37 47 ("jazz.dialect")
      {Lisp-Entry "private" native #f 47 8 47 15 ("jazz.error")}
      {Lisp-Entry "format" definition #f 68 20 68 26 ("with-printer" ":string" "':string" "string?" "parse-format" "cdr" "prog1" ":reader" "detail:" "empty-value:" "properties:" "3" "precision:" "after:" "before:" "last-separator:" "separator:" "padding:" "justify:" "width:" "list?:" "get-list?" "not-found:" "getf" "keyword" "keyword-parameter" ":v" "param" "default" ":right" ":left" "n" ">=" "cardinality" "size" "justify" "buffer" "get-padding" "padding" "get-justify" "justification" "get-width" "width" "proc" "localize" "'localize-directive" "unimplemented" "force-output" "-" "fresh-line" "newline" "do" "repeat" "loop" "1" "optional-parameter" "count" "cddr" "neq?" "memq" "cadr" "value" "car" "key" "not-null?" "scan" "get-empty-value" "empty-value" "get-properties" "properties" "print-list" "get-detail" "get-after" "after" "get-before" "before" "get-last-separator" "last-separator" "get-separator" "separator" "let*" "print-real" "get-precision" "precision" "print-hexadecimal" "print-binary" "print-unsigned" "print-expr" "detail" "textual" "write" "display" "function" "with-justification" "argument" "peek-argument" "next-argument" "or" "open-input-string" "subreader" "explicit?" "get-output-string" "begin" "open-output-string" "printer" "read-control-string" "process-conditional" "eqv?" "cond" "null?" "eq?" "read-delimited" "arguments-empty?" "toplevel?" "and" "localize-directive" "z" "force-directive" "!" "freshline-directive" "$" "newline-directive" "%" "tab-directive" "&" "column-directive" "_" "properties-directive" "k" "list-directive" "l" "real-directive" "r" "hexadecimal-directive" "x" "binary-directive" "b" "unsigned-directive" "u" "char-directive" "print-directive" "p" "text-directive" "t" "write-directive" "s" "display-directive" "a" "read-parameters" "parameters" "read" "directive" "else" "conditional-directive" "error" "peek-char" "write-char" "when" "require-char" "case" "set!" "eof-object?" "if" "read-char" "c" "not" "while" "done?" "let" "output?" "reader" "process" "arguments-scan" "control-reader" "out" "arguments" "control-string" "destination" "process-format" "define" "rest")}
      {Lisp-Entry "format-cardinality" definition #f 420 20 420 38 ("->string" "0" "=" "if" "n")}
      {Lisp-Entry "format-plural" definition #f 426 20 426 33 ("1" "=" "if" "plural" "n")}
      {Lisp-Entry "format-gender" definition #f 432 20 432 33 ("first" "vowel?" "if" "word")}
      {Lisp-Entry "format-is/are" definition #f 438 20 438 33 ("1" "=" "if" "n")}
      {Lisp-Entry "format-was/were" definition #f 444 20 444 35 ("1" "=" "if" "n")}
      {Lisp-Entry "format-y/ies" definition #f 450 20 450 32 ("1" "=" "if" "n")}
      {Lisp-Entry "format-following" definition #f 456 20 456 36 ("format" "1" "=" "if" "n" "name")}
      {Lisp-Entry "print-expr" definition #f 467 13 467 23 ("print" "current-output-port" "printer" "detail" "expr")}
      {Lisp-Entry "print-unsigned" definition #f 471 13 471 27 ("print-unsigned" "'print-unsigned" "unimplemented" "current-output-port" "printer" "n")}
      {Lisp-Entry "print-binary" definition #f 475 13 475 25 ("2" "number->string" "display" "current-output-port" "printer" "n")}
      {Lisp-Entry "print-hexadecimal" definition #f 479 13 479 30 ("16" "number->string" "display" "current-output-port" "printer" "n")}
      {Lisp-Entry "print-real" definition #f 483 13 483 23 ("new-frac" ">" "and" "carry?" "dot-pos" "or" "if" "len" "string->number" "round" "temp-str" "last-part" "first-part" "else" "-" "make-string" "string-append" "<" "display" "=" "cond" "frac-len" "string-length" "1" "+" "frac-str" "0" "substring" "pre-str" "find" "dot-index" "exact->inexact" "number->string" "str" "let*" "current-output-port" "printer" "precision" "r")}
      {Lisp-Entry "print-list" definition #f 522 13 522 23 ("null?" "pair?" "if" "cdr" "next" "print" "car" "expr" "scan" "iter" "let" "display" "not-null?" "when" "current-output-port" "printer" "detail" "after" "before" "last-separator" "separator" "list")}}})
"functional"
 ({Lisp-File-Entry {File jazz "src" "jazz" "dialect" "language" "functional.jazz"} 1253137558
    {Lisp-Entry "jazz.dialect.language.functional" library #f 37 19 37 51 ("terminal-port" ":terminal" "register-printer" "axis-find-in" "axis-find" "axis-for-each" "instantiate-ends-with?" "instantiate-starts-with?" "string-find-in" "instantiate-find-in" "string-find" "instantiate-find" "instantiate-butlast" "string-for-each" "instantiate-for-each" "jazz.dialect")
      {Lisp-Entry "private" native #f 48 8 48 15 ("jazz.error")}
      {Lisp-Entry "private" native #f 49 8 49 15 ("jazz.system-format")}
      {Lisp-Entry "Library" class #f 57 7 57 14 ("Object")
        {Lisp-Entry "name" slot #f 60 8 60 12 ()}
        {Lisp-Entry "get-name" accessor #f 60 23 60 31 ()}
        {Lisp-Entry "exports" slot #f 61 8 61 15 ()}
        {Lisp-Entry "get-exports" accessor #f 61 23 61 31 ()}}
      {Lisp-Entry "Type" class #f 69 7 69 11 ("Object")}
      {Lisp-Entry "Category" class #f 77 7 77 15 ("Type")
        {Lisp-Entry "name" slot #f 80 8 80 12 ()}
        {Lisp-Entry "get-name" accessor #f 80 28 80 36 ()}
        {Lisp-Entry "fields" slot #f 81 8 81 14 ()}
        {Lisp-Entry "get-fields" accessor #f 81 28 81 36 ()}
        {Lisp-Entry "virtual-size" slot #f 82 8 82 20 ()}
        {Lisp-Entry "get-virtual-size" accessor #f 82 28 82 36 ()}
        {Lisp-Entry "ancestors" slot #f 83 8 83 17 ()}
        {Lisp-Entry "get-ancestors" accessor #f 83 28 83 36 ()}
        {Lisp-Entry "descendants" slot #f 84 8 84 19 ()}
        {Lisp-Entry "get-descendants" accessor #f 84 28 84 36 ()}
        {Lisp-Entry "print" method #f 87 11 87 16 ("get-name" "system-format" "function" "self" "print-unreadable" "detail" "output")}}
      {Lisp-Entry "typed?" definition #f 93 20 93 26 ("class-of" "get-ancestors" "get-name" "eq?" "category" "function" "some?" "category-name" "obj")}
      {Lisp-Entry "Class" class #f 104 7 104 12 ("Category")
        {Lisp-Entry "ascendant" slot #f 107 8 107 17 ()}
        {Lisp-Entry "get-ascendant" accessor #f 107 34 107 42 ()}
        {Lisp-Entry "interfaces" slot #f 108 8 108 18 ()}
        {Lisp-Entry "get-interfaces" accessor #f 108 34 108 42 ()}
        {Lisp-Entry "slots" slot #f 109 8 109 13 ()}
        {Lisp-Entry "get-slots" accessor #f 109 34 109 42 ()}
        {Lisp-Entry "instance-slots" slot #f 110 8 110 22 ()}
        {Lisp-Entry "get-instance-slots" accessor #f 110 34 110 42 ()}
        {Lisp-Entry "instance-size" slot #f 111 8 111 21 ()}
        {Lisp-Entry "get-instance-size" accessor #f 111 34 111 42 ()}
        {Lisp-Entry "level" slot #f 112 8 112 13 ()}
        {Lisp-Entry "get-level" accessor #f 112 34 112 42 ()}
        {Lisp-Entry "dispatch-table" slot #f 113 8 113 22 ()}
        {Lisp-Entry "get-dispatch-table" accessor #f 113 34 113 42 ()}
        {Lisp-Entry "core-method-alist" slot #f 114 8 114 25 ()}
        {Lisp-Entry "get-core-method-alist" accessor #f 114 34 114 42 ()}
        {Lisp-Entry "core-virtual-alist" slot #f 115 8 115 26 ()}
        {Lisp-Entry "get-core-virtual-alist" accessor #f 115 34 115 42 ()}
        {Lisp-Entry "core-virtual-names" slot #f 116 8 116 26 ()}
        {Lisp-Entry "get-core-virtual-names" accessor #f 116 34 116 42 ()}
        {Lisp-Entry "core-vtable" slot #f 117 8 117 19 ()}
        {Lisp-Entry "get-core-vtable" accessor #f 117 34 117 42 ()}
        {Lisp-Entry "class-table" slot #f 118 8 118 19 ()}
        {Lisp-Entry "get-class-table" accessor #f 118 34 118 42 ()}
        {Lisp-Entry "interface-table" slot #f 119 8 119 23 ()}
        {Lisp-Entry "get-interface-table" accessor #f 119 34 119 42 ()}
        {Lisp-Entry "coerce-object" method #f 122 26 122 39 ("self" "type-name" "error" "obj")}
        {Lisp-Entry "external-name" method #f 126 26 126 39 ("self" "type-name" "error" "when" "error?" "error?:")}}
      {Lisp-Entry "Object-Class" class #f 131 7 131 19 ("Class")}
      {Lisp-Entry "class?" definition #f 134 27 134 33 ("Class" "is?" "obj")}
      {Lisp-Entry "instance-of?" definition #f 138 27 138 39 ("class-of" "eq?" "class" "obj")}
      {Lisp-Entry "coerce" definition #f 142 27 142 33 ("coerce-object" "class" "object")}
      {Lisp-Entry "allocate" definition #f 146 20 146 28 ("call-into-abstract" "size" "class")}
      {Lisp-Entry "Interface" class #f 155 7 155 16 ("Category")
        {Lisp-Entry "ascendants" slot #f 158 8 158 18 ()}
        {Lisp-Entry "get-ascendants" accessor #f 158 26 158 34 ()}
        {Lisp-Entry "rank" slot #f 159 8 159 12 ()}
        {Lisp-Entry "get-rank" accessor #f 159 26 159 34 ()}}
      {Lisp-Entry "Field" class #f 167 7 167 12 ("Object")
        {Lisp-Entry "name" slot #f 170 8 170 12 ()}
        {Lisp-Entry "get-name" accessor #f 170 20 170 28 ()}
        {Lisp-Entry "print" method #f 173 11 173 16 ("get-name" "system-format" "function" "self" "print-unreadable" "detail" "output")}}
      {Lisp-Entry "category-field" definition #f 179 20 179 34 ("find-field" "field-name" "category")}
      {Lisp-Entry "Method" class #f 188 7 188 13 ("Field")
        {Lisp-Entry "dispatch-type" slot #f 191 8 191 21 ()}
        {Lisp-Entry "get-dispatch-type" accessor #f 191 35 191 43 ()}
        {Lisp-Entry "implementation" slot #f 192 8 192 22 ()}
        {Lisp-Entry "get-implementation" accessor #f 192 35 192 43 ()}
        {Lisp-Entry "implementation-tree" slot #f 193 8 193 27 ()}
        {Lisp-Entry "get-implementation-tree" accessor #f 193 35 193 43 ()}
        {Lisp-Entry "category-rank" slot #f 194 8 194 21 ()}
        {Lisp-Entry "get-category-rank" accessor #f 194 35 194 43 ()}
        {Lisp-Entry "implementation-rank" slot #f 195 8 195 27 ()}
        {Lisp-Entry "get-implementation-rank" accessor #f 195 35 195 43 ()}}
      {Lisp-Entry "object-method" definition #f 199 20 199 33 ("apply" "rest" "function" "class-of" "find-field" "get-implementation" "impl" "let" "name" "object")}
      {Lisp-Entry "Method-Node" class #f 210 7 210 18 ("Object")
        {Lisp-Entry "category" slot #f 213 8 213 16 ()}
        {Lisp-Entry "get-category" accessor #f 213 35 213 43 ()}
        {Lisp-Entry "implementation" slot #f 214 8 214 22 ()}
        {Lisp-Entry "get-implementation" accessor #f 214 35 214 43 ()}
        {Lisp-Entry "next-node" slot #f 215 8 215 17 ()}
        {Lisp-Entry "get-next-node" accessor #f 215 35 215 43 ()}
        {Lisp-Entry "next-implementation" slot #f 216 8 216 27 ()}
        {Lisp-Entry "get-next-implementation" accessor #f 216 35 216 43 ()}
        {Lisp-Entry "children" slot #f 217 8 217 16 ()}
        {Lisp-Entry "get-children" accessor #f 217 35 217 43 ()}}
      {Lisp-Entry "Queue" class #f 225 7 225 12 ("Object")
        {Lisp-Entry "list" slot #f 228 8 228 12 ()}
        {Lisp-Entry "get-list" accessor #f 228 27 228 35 ()}
        {Lisp-Entry "last-list" slot #f 229 8 229 17 ()}
        {Lisp-Entry "get-last-list" accessor #f 229 27 229 35 ()}
        {Lisp-Entry "last-anchor" slot #f 230 8 230 19 ()}
        {Lisp-Entry "get-last-anchor" accessor #f 230 27 230 35 ()}
        {Lisp-Entry "current" slot #f 231 8 231 15 ()}
        {Lisp-Entry "get-current" accessor #f 231 27 231 35 ()}}
      {Lisp-Entry "Generic" class #f 239 7 239 14 ("Object")
        {Lisp-Entry "locator" slot #f 242 8 242 15 ()}
        {Lisp-Entry "get-locator" accessor #f 242 36 242 44 ()}
        {Lisp-Entry "name" slot #f 243 8 243 12 ()}
        {Lisp-Entry "get-name" accessor #f 243 36 243 44 ()}
        {Lisp-Entry "root-specific" slot #f 244 8 244 21 ()}
        {Lisp-Entry "get-root-specific" accessor #f 244 36 244 44 ()}
        {Lisp-Entry "pending-specifics" slot #f 245 8 245 25 ()}
        {Lisp-Entry "get-pending-specifics" accessor #f 245 36 245 44 ()}}
      {Lisp-Entry "Specific" class #f 248 7 248 15 ("Object")
        {Lisp-Entry "dynamic-signature" slot #f 251 8 251 25 ()}
        {Lisp-Entry "get-dynamic-signature" accessor #f 251 36 251 44 ()}
        {Lisp-Entry "implementation" slot #f 252 8 252 22 ()}
        {Lisp-Entry "get-implementation" accessor #f 252 36 252 44 ()}
        {Lisp-Entry "ancestor-specifics" slot #f 253 8 253 26 ()}
        {Lisp-Entry "get-ancestor-specifics" accessor #f 253 36 253 44 ()}
        {Lisp-Entry "descendant-specifics" slot #f 254 8 254 28 ()}
        {Lisp-Entry "get-descendant-specifics" accessor #f 254 36 254 44 ()}}
      {Lisp-Entry "Boolean-Class" class #f 262 7 262 20 ("Class")}
      {Lisp-Entry "Boolean" class #f 265 17 265 24 ("Object" "Boolean-Class")
        {Lisp-Entry "initialize" method #f 268 11 268 21 ("native-class" "rest")}}
      {Lisp-Entry "/=" definition #f 272 27 272 29 ("=" "not" "y" "x")}
      {Lisp-Entry "neq?" definition #f 276 27 276 31 ("eq?" "not" "y" "x")}
      {Lisp-Entry "xor" definition #f 280 27 280 30 ("not" "and" "or" "y" "x")}
      {Lisp-Entry "nu=?" definition #f 285 20 285 24 ("cdr" "else" "car" "neq?" "null?" "cond" "scan" "iter" "first" "let" ":equal" "compare" "eq?" "and" "rest" "m" "n")}
      {Lisp-Entry "nu/=?" definition #f 297 20 297 25 ("nu=?" "apply" "not" ":equal" "compare" "neq?" "null?" "if" "rest" "m" "n")}
      {Lisp-Entry "nu<?" definition #f 303 20 303 24 ("cdr" "car" "value" "null?" "if" "max" "scan" "iter" "let" "error" "else" ":equal" ":greater" ":less" "compare" "case" "and" "rest" "m" "n")}
      {Lisp-Entry "nu<=?" definition #f 318 20 318 25 ("cdr" "car" "value" "null?" "if" "max" "scan" "iter" "let" "error" "else" ":greater" ":equal" ":less" "compare" "case" "and" "rest" "m" "n")}
      {Lisp-Entry "nu>?" definition #f 333 20 333 24 ("cdr" "car" "value" "null?" "if" "min" "scan" "iter" "let" "error" "else" ":equal" ":less" ":greater" "compare" "case" "and" "rest" "m" "n")}
      {Lisp-Entry "nu>=?" definition #f 348 20 348 25 ("cdr" "car" "value" "null?" "if" "min" "scan" "iter" "let" "error" "else" ":less" ":equal" ":greater" "compare" "case" "and" "rest" "m" "n")}
      {Lisp-Entry "ci=?" definition #f 363 20 363 24 ("finally" "return" ":equal" "ci-compare" "neq?" "when" "cdr" "in" "object" "for" "loop" "car" "first" "let" "null?" "if" "rest")}
      {Lisp-Entry "ci/=?" definition #f 373 20 373 25 ("ci=?" "apply" "not" "rest")}
      {Lisp-Entry "ci<?" definition #f 377 20 377 24 ("error" "else" ":equal" ":greater" "cdr" ":less" "ci-compare" "case" "car" "value" "null?" "if" "max" "scan" "iter" "let" "rest" "n")}
      {Lisp-Entry "ci<=?" definition #f 388 20 388 25 ("error" "else" ":greater" "cdr" ":equal" ":less" "ci-compare" "case" "car" "value" "null?" "if" "max" "scan" "iter" "let" "rest" "n")}
      {Lisp-Entry "ci>?" definition #f 399 20 399 24 ("error" "else" ":equal" ":less" "cdr" ":greater" "ci-compare" "case" "car" "value" "null?" "if" "min" "scan" "iter" "let" "rest" "n")}
      {Lisp-Entry "ci>=?" definition #f 410 20 410 25 ("error" "else" ":less" "cdr" ":equal" ":greater" "ci-compare" "case" "car" "value" "null?" "if" "min" "scan" "iter" "let" "rest" "n")}
      {Lisp-Entry "boolean->integer" definition #f 421 27 421 43 ("0" "1" "if" "bool")}
      {Lisp-Entry "integer->boolean" definition #f 425 27 425 43 ("0" "/=" "n")}
      {Lisp-Entry "Whitespace-Chars" definition #f 434 19 434 35 ()}
      {Lisp-Entry "Uppercase-Chars" definition #f 437 19 437 34 ()}
      {Lisp-Entry "Lowercase-Chars" definition #f 440 19 440 34 ()}
      {Lisp-Entry "Alphabetic-Chars" definition #f 443 19 443 35 ("Lowercase-Chars" "Uppercase-Chars" "append")}
      {Lisp-Entry "Numeric-Chars" definition #f 446 19 446 32 ()}
      {Lisp-Entry "Uppercase-Lowerbound" definition #f 450 12 450 32 ("char->integer")}
      {Lisp-Entry "Uppercase-Upperbound" definition #f 453 12 453 32 ("char->integer")}
      {Lisp-Entry "Lowercase-Lowerbound" definition #f 456 12 456 32 ("char->integer")}
      {Lisp-Entry "Lowercase-Upperbound" definition #f 459 12 459 32 ("char->integer")}
      {Lisp-Entry "Numeric-Lowerbound" definition #f 462 12 462 30 ("char->integer")}
      {Lisp-Entry "Numeric-Upperbound" definition #f 465 12 465 30 ("char->integer")}
      {Lisp-Entry "Char-Class" class #f 469 7 469 17 ("Class")}
      {Lisp-Entry "Char" class #f 472 17 472 21 ("Object" "Char-Class")
        {Lisp-Entry "initialize" method #f 475 11 475 21 ("native-class" "rest")}
        {Lisp-Entry "coerce-string" method #f 479 11 479 24 ("get-output-string" "self" "write-char" "open-output-string" "port" "let")}
        {Lisp-Entry "compare-object" method #f 485 11 485 25 (":incompatible" ":less" "else" ":greater" ">" ":equal" "=" "cond" "v2" "self" "char->integer" "v1" "let" "Char" "is?" "if" "c")}
        {Lisp-Entry "ci-compare-object" method #f 495 11 495 28 ("self" "downcase" "compare" "c")}
        {Lisp-Entry "object-similar?" method #f 500 11 500 26 ("self" "char-similar?" "char?" "and" "object-similar?" "'object-similar?" "unimplemented" "object")}
        {Lisp-Entry "object-alphabetic?" method #f 507 11 507 29 ("object-lower-case?" "object-upper-case?" "or")}
        {Lisp-Entry "object-numeric?" method #f 512 11 512 26 ("Numeric-Upperbound" "<=" "Numeric-Lowerbound" ">=" "and" "self" "char->integer" "n" "let")}
        {Lisp-Entry "object-alphanumeric?" method #f 518 11 518 31 ("object-numeric?" "object-alphabetic?" "or")}
        {Lisp-Entry "object-whitespace?" method #f 523 11 523 29 ("self" "eqv?" "or")}
        {Lisp-Entry "object-upper-case?" method #f 531 11 531 29 ("Uppercase-Upperbound" "<=" "Uppercase-Lowerbound" ">=" "and" "self" "char->integer" "n" "let")}
        {Lisp-Entry "object-lower-case?" method #f 537 11 537 29 ("Lowercase-Upperbound" "<=" "Lowercase-Lowerbound" ">=" "and" "self" "char->integer" "n" "let")}
        {Lisp-Entry "object-upcase" method #f 543 11 543 24 ("32" "char->integer" "-" "integer->char" "self" "lower-case?" "if")}
        {Lisp-Entry "object-downcase" method #f 549 11 549 26 ("32" "char->integer" "+" "integer->char" "self" "upper-case?" "if")}
        {Lisp-Entry "object-capitalize" method #f 555 11 555 28 ("object-upcase")}}
      {Lisp-Entry "whitechar?" definition #f 559 12 559 22 ("char-whitespace?")}
      {Lisp-Entry "char-presentation" definition #f 563 20 563 37 ("string" "char-symbol" "or" "char")}
      {Lisp-Entry "alphabetic?" definition #f 568 27 568 38 ("object-alphabetic?" "object")}
      {Lisp-Entry "numeric?" definition #f 572 27 572 35 ("object-numeric?" "object")}
      {Lisp-Entry "alphanumeric?" definition #f 576 27 576 40 ("object-alphanumeric?" "object")}
      {Lisp-Entry "whitespace?" definition #f 580 27 580 38 ("object-whitespace?" "object")}
      {Lisp-Entry "upper-case?" definition #f 584 27 584 38 ("object-upper-case?" "object")}
      {Lisp-Entry "lower-case?" definition #f 588 27 588 38 ("object-lower-case?" "object")}
      {Lisp-Entry "upcase" definition #f 592 27 592 33 ("object-upcase" "object")}
      {Lisp-Entry "downcase" definition #f 596 27 596 35 ("object-downcase" "object")}
      {Lisp-Entry "capitalize" definition #f 600 27 600 37 ("object-capitalize" "object")}
      {Lisp-Entry "vowel?" definition #f 604 20 604 26 ("downcase" "memv?" "c")}
      {Lisp-Entry "character-types" definition #f 608 12 608 27 ("symbol" "literal" "quasiquote" "backslash" "reference" "exprcomment" "comment" "unquote" "terminator" "list" "quote" "sharp" "string" "constituent" "whitespace" "invalid" "#")}
      {Lisp-Entry "character-type" definition #f 627 20 627 34 ("character-types" "vector-ref" "constituent" "'constituent" "127" ">" "if" "char->integer" "num" "let" "ascii-c")}
      {Lisp-Entry "word-constituent?" definition #f 634 20 634 37 ("memq?" "alphanumeric?" "or" "c")}
      {Lisp-Entry "scheme-constituent?" definition #f 639 20 639 39 ("eqv?" "constituent" "'constituent" "character-type" "eq?" "alphanumeric?" "or" "c")}
      {Lisp-Entry "jazz-constituent?" definition #f 646 20 646 37 ("eqv?" "constituent" "'constituent" "character-type" "eq?" "alphanumeric?" "or" "c")}
      {Lisp-Entry "c-constituent?" definition #f 652 20 652 34 ("eqv?" "alphanumeric?" "or" "c")}
      {Lisp-Entry "sql-constituent?" definition #f 657 20 657 36 ("eqv?" "alphanumeric?" "or" "c")}
      {Lisp-Entry "Port-Class" class #f 670 7 670 17 ("Class")}
      {Lisp-Entry "Port" class #f 673 17 673 21 ("Object" "Port-Class")
        {Lisp-Entry "initialize" method #f 676 11 676 21 ("native-class" "rest")}
        {Lisp-Entry "destroy" method #f 680 11 680 18 ("nextmethod" "self" "close-port")}}
      {Lisp-Entry "Symbol-Class" class #f 690 7 690 19 ("Class")}
      {Lisp-Entry "Symbol" class #f 693 17 693 23 ("Object" "Symbol-Class")
        {Lisp-Entry "initialize" method #f 696 11 696 21 ("native-class" "rest")}
        {Lisp-Entry "coerce-string" method #f 700 11 700 24 ("self" "symbol->string")}
        {Lisp-Entry "compare-object" method #f 704 11 704 25 (":incompatible" "self" "symbol->string" "compare" "symbol?" "if" "obj")}
        {Lisp-Entry "ci-compare-object" method #f 710 11 710 28 (":incompatible" "self" "symbol->string" "ci-compare" "symbol?" "if" "obj")}}
      {Lisp-Entry "=" specialize #f 716 20 716 21 ("eq?" "s2" "s1")}
      {Lisp-Entry "generated-symbol?" definition #f 720 20 720 37 ("symbol->string" "starts-with?" "symbol")}
      {Lisp-Entry "symbol->keyword" definition #f 724 27 724 42 ("symbol->string" "string->keyword" "symbol")}
      {Lisp-Entry "keyword->symbol" definition #f 728 27 728 42 ("keyword->string" "string->symbol" "keyword")}
      {Lisp-Entry "find-symbol" definition #f 732 20 732 31 ("string->symbol" "str")}
      {Lisp-Entry "symbol-bound?" definition #f 737 20 737 33 ("rest" "name")}
      {Lisp-Entry "symbol-unbound?" definition #f 740 20 740 35 ("rest" "name")}
      {Lisp-Entry "Keyword-Class" class #f 750 7 750 20 ("Class")}
      {Lisp-Entry "Keyword" class #f 753 17 753 24 ("Object" "Keyword-Class")
        {Lisp-Entry "initialize" method #f 756 11 756 21 ("native-class" "rest")}}
      {Lisp-Entry "find-keyword" definition #f 760 20 760 32 ("specified?" "null?" "cdr" "cddr" "set-cdr!" "cadr" "set!" "begin" "eq?" "error" "car" "keyword?" "if" "elem" "not-null?" "unspecified?" "and" "while" "unspecified" "found" "unbox-list" "scan" "before" "let" "default" "box" "keyword")}
      {Lisp-Entry "box-list" definition #f 786 21 786 29 ("cons" "lst")}
      {Lisp-Entry "unbox-list" definition #f 790 21 790 31 ("cdr" "box")}
      {Lisp-Entry "Continuation-Class" class #f 799 7 799 25 ("Class")}
      {Lisp-Entry "Continuation" class #f 802 17 802 29 ("Object" "Continuation-Class")}
      {Lisp-Entry "Procedure-Class" class #f 810 7 810 22 ("Class")}
      {Lisp-Entry "Procedure" class #f 813 17 813 26 ("Object" "Procedure-Class")}
      {Lisp-Entry "Foreign-Class" class #f 821 7 821 20 ("Class")}
      {Lisp-Entry "Foreign" class #f 824 17 824 24 ("Object" "Foreign-Class")}
      {Lisp-Entry "Numeric-Class" class #f 832 7 832 20 ("Class")}
      {Lisp-Entry "Numeric" class #f 835 17 835 24 ("Object" "Numeric-Class")
        {Lisp-Entry "numeric-norm" method #f 838 35 838 47 ()}
        {Lisp-Entry "numeric-add" method #f 839 35 839 46 ("obj")}
        {Lisp-Entry "numeric-negate" method #f 840 35 840 49 ()}
        {Lisp-Entry "numeric-multiply" method #f 841 35 841 51 ("n")}
        {Lisp-Entry "numeric-inverse" method #f 842 35 842 50 ()}}
      {Lisp-Entry "Number-Class" class #f 850 7 850 19 ("Numeric-Class")}
      {Lisp-Entry "Number" class #f 853 17 853 23 ("Numeric" "Number-Class")
        {Lisp-Entry "initialize" method #f 856 11 856 21 ("native-class" "rest")}
        {Lisp-Entry "compare-object" method #f 860 11 860 25 (":incompatible" ":greater" "else" ":less" "<" ":equal" "self" "=" "cond" "number?" "if" "obj")}
        {Lisp-Entry "ci-compare-object" method #f 868 11 868 28 ("compare-object" "obj")}
        {Lisp-Entry "numeric-norm" method #f 872 11 872 23 ("self" "abs")}
        {Lisp-Entry "numeric-add" method #f 876 11 876 22 ("error" "self" "+" "number?" "if" "obj")}
        {Lisp-Entry "numeric-negate" method #f 882 11 882 25 ("self" "-")}
        {Lisp-Entry "numeric-multiply" method #f 886 11 886 27 ("error" "self" "*" "number?" "if" "obj")}
        {Lisp-Entry "numeric-inverse" method #f 892 11 892 26 ("self" "/")}}
      {Lisp-Entry "Complex-Class" class #f 901 7 901 20 ("Number-Class")}
      {Lisp-Entry "Complex" class #f 904 17 904 24 ("Number" "Complex-Class")
        {Lisp-Entry "numeric-norm" method #f 907 11 907 23 ("imag-part" "2" "self" "real-part" "expt" "+" "sqrt")}}
      {Lisp-Entry "Real-Class" class #f 916 7 916 17 ("Complex-Class")}
      {Lisp-Entry "Real" class #f 919 17 919 21 ("Complex" "Real-Class")}
      {Lisp-Entry "Rational-Class" class #f 927 7 927 21 ("Real-Class")}
      {Lisp-Entry "Rational" class #f 930 17 930 25 ("Real" "Rational-Class")}
      {Lisp-Entry "Integer-Class" class #f 938 7 938 20 ("Rational-Class")}
      {Lisp-Entry "Integer" class #f 941 17 941 24 ("Rational" "Integer-Class")}
      {Lisp-Entry "Fixnum-Class" class #f 949 7 949 19 ("Integer-Class")}
      {Lisp-Entry "Fixnum" class #f 952 17 952 23 ("Integer" "Fixnum-Class")}
      {Lisp-Entry "Flonum-Class" class #f 960 7 960 19 ("Real-Class")}
      {Lisp-Entry "Flonum" class #f 963 17 963 23 ("Real" "Flonum-Class")}
      {Lisp-Entry "fl+" definition #f 968 27 968 30 ("##fl+" "y" "x")}
      {Lisp-Entry "fl-" definition #f 971 27 971 30 ("##fl-" "y" "x")}
      {Lisp-Entry "fl*" definition #f 974 27 974 30 ("##fl*" "y" "x")}
      {Lisp-Entry "fl/" definition #f 977 27 977 30 ("##fl/" "y" "x")}
      {Lisp-Entry "relate" definition #f 986 20 986 26 ("0" "else" "1" ">" "-1" "<" "cond" "y" "x")}
      {Lisp-Entry "sign" definition #f 992 20 992 24 ("0" "relate" "n")}
      {Lisp-Entry "nu+" definition #f 996 20 996 23 ("numeric-add" "cdr" "scan" "car" "result" "iter" "let" "0" "null?" "if" "rest")}
      {Lisp-Entry "nu-" definition #f 1005 20 1005 23 ("nu+" "apply" "r" "let" "numeric-negate" "null?" "if" "rest" "n")}
      {Lisp-Entry "nu*" definition #f 1012 20 1012 23 ("numeric-multiply" "cdr" "scan" "car" "result" "iter" "let" "1" "null?" "if" "rest")}
      {Lisp-Entry "nu/" definition #f 1021 20 1021 23 ("nu*" "apply" "r" "let" "numeric-inverse" "null?" "if" "rest" "n")}
      {Lisp-Entry "minimum" definition #f 1028 20 1028 27 ("cdr" "set!" ":less" "apply-key" "eq?" "when" "object" "function" "for-each" "car" "min" "let" "compare" "compare:" "key" "key:" "lst")}
      {Lisp-Entry "maximum" definition #f 1037 20 1037 27 ("cdr" "set!" ":greater" "apply-key" "eq?" "when" "object" "function" "for-each" "car" "max" "let" "compare" "compare:" "key" "key:" "lst")}
      {Lisp-Entry "between?" definition #f 1046 20 1046 28 ("<=" ">=" "not" "or" "and" "upper" "lower" "n")}
      {Lisp-Entry "between" definition #f 1051 20 1051 27 ("else" ">" "<" "cond" "upper" "n" "lower")}
      {Lisp-Entry "in-interval?" definition #f 1057 20 1057 32 ("<" ">=" "and" "upper" "lower" "n")}
      {Lisp-Entry "norm" definition #f 1061 27 1061 31 ("numeric-norm" "x")}
      {Lisp-Entry "distance" definition #f 1065 20 1065 28 ("nu-" "norm" "end" "start")}
      {Lisp-Entry "near?" definition #f 1069 20 1069 25 ("nu-" "norm" "<=" "distance" "y" "x")}
      {Lisp-Entry "contiguous-range" definition #f 1073 20 1073 36 ("cons" "cdr" "continuation-return" "set!" "1" "+" "=" "if" "n" "for-each" "second" "car" "first" "let*" "return" "function" "continuation-capture" "not-null?" "when" "lst")}
      {Lisp-Entry "naturals" definition #f 1087 20 1087 28 ("collect" "below" "from" "n" "for" "loop" "upper" "lower")}
      {Lisp-Entry "lobyte" definition #f 1092 20 1092 26 ("#xFF" "bitwise-and" "word")}
      {Lisp-Entry "hibyte" definition #f 1096 20 1096 26 ("-8" "arithmetic-shift" "lobyte" "word")}
      {Lisp-Entry "make-word" definition #f 1100 20 1100 29 ("8" "arithmetic-shift" "bitwise-ior" "hi" "lo")}
      {Lisp-Entry "lochar" definition #f 1104 20 1104 26 ("#xFF" "#x80" "+" "bitwise-and" "-" "word")}
      {Lisp-Entry "hichar" definition #f 1108 20 1108 26 ("-8" "arithmetic-shift" "lochar" "word")}
      {Lisp-Entry "make-int" definition #f 1112 20 1112 28 ("16" "arithmetic-shift" "bitwise-ior" "hi" "lo")}
      {Lisp-Entry "loword" definition #f 1116 20 1116 26 ("#xFFFF" "bitwise-and" "dword")}
      {Lisp-Entry "hiword" definition #f 1120 20 1120 26 ("-16" "arithmetic-shift" "loword" "dword")}
      {Lisp-Entry "signed-loword" definition #f 1124 20 1124 33 ("#xFFFF" "#x8000" "+" "bitwise-and" "-" "dword")}
      {Lisp-Entry "signed-hiword" definition #f 1128 20 1128 33 ("-16" "arithmetic-shift" "signed-loword" "dword")}
      {Lisp-Entry "sign-word" definition #f 1132 20 1132 29 ("#x10000" "-" "15" "bit-set?" "if" "word")}
      {Lisp-Entry "separate" definition #f 1138 20 1138 28 ("values" "*" "-" "r" "quotient" "q" "let*" "int2" "int1")}
      {Lisp-Entry "randomize" definition #f 1144 20 1144 29 ("default-random-source" "random-source-randomize!")}
      {Lisp-Entry "random" definition #f 1147 20 1147 26 ("random-integer" "n")}
      {Lisp-Entry "bit-set" definition #f 1151 20 1151 27 ("bitwise-not" "bitwise-and" "bitwise-ior" "if" "1" "arithmetic-shift" "msk" "let" "bit" "pos" "num")}
      {Lisp-Entry "mask-bit-set" definition #f 1158 20 1158 32 ("bitwise-not" "bitwise-and" "bitwise-ior" "if" "bit" "msk" "num")}
      {Lisp-Entry "mask-bit-set?" definition #f 1164 20 1164 33 ("0" "bitwise-and" "/=" "msk" "num")}
      {Lisp-Entry "bit-mask" definition #f 1168 20 1168 28 ("1" "arithmetic-shift" "-" "lo" "hi")}
      {Lisp-Entry "random-seed" definition #f 1172 20 1172 31 ("10000" "random" "randomize")}
      {Lisp-Entry "sqr" definition #f 1178 27 1178 30 ("2" "expt" "num")}
      {Lisp-Entry "percentage" definition #f 1182 27 1182 37 ("100." "/" "*" "total" "part")}
      {Lisp-Entry "percent" definition #f 1186 27 1186 34 ("100." "*" "/" "n" "percent")}
      {Lisp-Entry "fxfloor" definition #f 1190 27 1190 34 ("floor" "flonum->fixnum" "r")}
      {Lisp-Entry "fxceiling" definition #f 1193 27 1193 36 ("ceiling" "flonum->fixnum" "r")}
      {Lisp-Entry "fxtruncate" definition #f 1196 27 1196 37 ("truncate" "flonum->fixnum" "r")}
      {Lisp-Entry "fxround" definition #f 1199 27 1199 34 ("round" "flonum->fixnum" "r")}
      {Lisp-Entry "fxfloor/" definition #f 1205 27 1205 35 ("fl/" "fxfloor" "d" "n")}
      {Lisp-Entry "fxceiling/" definition #f 1208 27 1208 37 ("fl/" "fxceiling" "d" "n")}
      {Lisp-Entry "fxtruncate/" definition #f 1211 27 1211 38 ("fl/" "fxtruncate" "d" "n")}
      {Lisp-Entry "fxround/" definition #f 1214 27 1214 35 ("fl/" "fxround" "d" "n")}
      {Lisp-Entry "Iterator" class #f 1223 15 1223 23 ("Empty" "initialize" "Object")
        {Lisp-Entry "Empty" definition #f 1226 14 1226 19 ("empty")}
        {Lisp-Entry "peeked" slot #f 1230 8 1230 14 ()}
        {Lisp-Entry "iterate-object" method #f 1233 11 1233 25 ("self")}
        {Lisp-Entry "get-next" method #f 1237 26 1237 34 ("next" "peek" "prog1")}
        {Lisp-Entry "peek" method #f 1242 26 1242 30 ("next" "set!" "Empty" "peeked" "eq?" "when")}
        {Lisp-Entry "unget" method #f 1248 26 1248 31 ("error" "set!" "Empty" "peeked" "eq?" "if" "object")}
        {Lisp-Entry "next" method #f 1254 26 1254 30 ("get-next!" "else" "set!" "prog1" "Empty" "neq?" "peeked" "eof-object?" "cond")}
        {Lisp-Entry "done?" method #f 1264 26 1264 31 ("peek" "eof-object?")}
        {Lisp-Entry "get-next!" method #f 1268 26 1268 35 ()}
        {Lisp-Entry "put" method #f 1272 26 1272 29 ("error" "object")}
        {Lisp-Entry "get-position" method #f 1276 26 1276 38 ("self" "error")}
        {Lisp-Entry "set-position" method #f 1280 26 1280 38 ("self" "error" "pos")}
        {Lisp-Entry "get-state" method #f 1284 26 1284 35 ()}
        {Lisp-Entry "reset-state" method #f 1288 26 1288 37 ("old")}}
      {Lisp-Entry "iterate-sequence" definition #f 1292 27 1292 43 ("iterate-object" "obj")}
      {Lisp-Entry "Explorer" class #f 1301 15 1301 23 ("forward" "'forward" "initialize" "Iterator")
        {Lisp-Entry "direction" slot #f 1304 8 1304 17 ()}
        {Lisp-Entry "peek-forward" method #f 1307 29 1307 41 ("error")}
        {Lisp-Entry "peek-backward" method #f 1311 29 1311 42 ("error")}
        {Lisp-Entry "peek" method #f 1315 11 1315 15 ("peek-backward" "backward" "peek-forward" "forward" "direction" "case" "eof-object" "done?" "if")}
        {Lisp-Entry "goto-beginning" method #f 1323 26 1323 40 ("error")}
        {Lisp-Entry "goto-end" method #f 1327 26 1327 34 ("error")}
        {Lisp-Entry "forward" method #f 1331 26 1331 33 ("error")}
        {Lisp-Entry "backward" method #f 1335 26 1335 34 ("error")}
        {Lisp-Entry "next" method #f 1339 11 1339 15 ("backward" "forward" "direction" "case" "done?" "not" "when")}
        {Lisp-Entry "done-forward?" method #f 1346 29 1346 42 ("error")}
        {Lisp-Entry "done-backward?" method #f 1350 29 1350 43 ("error")}
        {Lisp-Entry "done?" method #f 1354 11 1354 16 ("done-backward?" "backward" "done-forward?" "forward" "direction" "case")}
        {Lisp-Entry "put-forward" method #f 1360 29 1360 40 ("error" "object")}
        {Lisp-Entry "put-backward" method #f 1364 29 1364 41 ("error" "object")}
        {Lisp-Entry "put" method #f 1368 11 1368 14 ("put-backward" "backward" "put-forward" "forward" "direction" "case" "object")}
        {Lisp-Entry "set-direction" method #f 1374 18 1374 31 ("direction" "set!" "dir")}}
      {Lisp-Entry "explore" definition #f 1378 20 1378 27 ("Sequence-Explorer" "new" "apply" "rest" "object")}
      {Lisp-Entry "Sequence-Class" class #f 1388 7 1388 21 ("Class")
        {Lisp-Entry "allocate-sequence" method #f 1391 35 1391 52 ("len")}
        {Lisp-Entry "coerce-object" method #f 1394 11 1394 24 ("element" "set-element!" "below" "0" "from" "n" "for" "loop" "allocate-sequence" "new-sequence" "cardinality" "len" "let" "seq")}}
      {Lisp-Entry "Sequence" class #f 1403 17 1403 25 ("Object" "Sequence-Class")
        {Lisp-Entry "compare-object" method #f 1406 11 1406 25 (":incompatible" "1" "+" "neq?" "element" "compare" "cmp" ":less" "else" ":greater" ">" ":equal" "=" "cond" ">=" "or" "0" "i" "iter" "l2" "self" "cardinality" "l1" "let" "Sequence" "is?" "if" "seq")}
        {Lisp-Entry "copy-object" method #f 1422 11 1422 22 ("1" "+" "element" "set-element!" "begin" "=" "0" "i" "iter" "let" "class-of" "allocate-sequence" "new-seq" "self" "cardinality" "len" "identity" "x" "function" "if" "subcopy" "let*" "deep?")}
        {Lisp-Entry "iterate-object" method #f 1434 11 1434 25 ("self" "Sequence-Explorer" "new")}
        {Lisp-Entry "object-alphabetic?" method #f 1438 11 1438 29 ("self" "alphabetic?" "every?")}
        {Lisp-Entry "object-numeric?" method #f 1442 11 1442 26 ("self" "numeric?" "every?")}
        {Lisp-Entry "object-alphanumeric?" method #f 1446 11 1446 31 ("self" "alphanumeric?" "every?")}
        {Lisp-Entry "object-whitespace?" method #f 1450 11 1450 29 ("self" "whitespace?" "every?")}
        {Lisp-Entry "object-upper-case?" method #f 1454 11 1454 29 ("self" "upper-case?" "every?")}
        {Lisp-Entry "object-lower-case?" method #f 1458 11 1458 29 ("self" "lower-case?" "every?")}
        {Lisp-Entry "object-upcase" method #f 1462 11 1462 24 ("class-of" "upcase" "self" "accumulate")}
        {Lisp-Entry "object-downcase" method #f 1466 11 1466 26 ("class-of" "downcase" "self" "accumulate")}
        {Lisp-Entry "object-capitalize" method #f 1470 11 1470 28 ("class-of" "upcase" "set!" "not" "alphanumeric?" "if" "object" "function" "self" "accumulate" "break?" "let")}
        {Lisp-Entry "sequence-element" method #f 1484 38 1484 54 ("n")}
        {Lisp-Entry "sequence-set-element!" method #f 1487 38 1487 59 ("obj" "n")}
        {Lisp-Entry "sequence-cardinality" method #f 1490 38 1490 58 ()}
        {Lisp-Entry "sequence-tail" method #f 1493 38 1493 51 ("start")}
        {Lisp-Entry "sequence-last" method #f 1496 38 1496 51 ()}
        {Lisp-Entry "sequence-butlast" method #f 1499 38 1499 54 ()}
        {Lisp-Entry "sequence-subseq!" method #f 1502 29 1502 45 ("cardinality" "-" "Subseq" "new" "self" "-1" "0" "=" "and" "if" "end" "start")}
        {Lisp-Entry "sequence-replace-subseq!" method #f 1508 29 1508 53 ("cardinality" "0" "self" "subseq" "concatenate!" "replacement" "end" "start")}}
      {Lisp-Entry "sequence?" definition #f 1514 27 1514 36 ("Sequence" "is?" "obj")}
      {Lisp-Entry "element" definition #f 1518 27 1518 34 ("sequence-element" "n" "seq")}
      {Lisp-Entry "set-element!" definition #f 1522 27 1522 39 ("sequence-set-element!" "obj" "n" "seq")}
      {Lisp-Entry "cardinality" definition #f 1526 27 1526 38 ("sequence-cardinality" "seq")}
      {Lisp-Entry "empty?" definition #f 1530 27 1530 33 ("cardinality" "0" "=" "seq")}
      {Lisp-Entry "tail" definition #f 1534 27 1534 31 ("sequence-tail" "start" "seq")}
      {Lisp-Entry "last" definition #f 1538 27 1538 31 ("sequence-last" "seq")}
      {Lisp-Entry "butlast" definition #f 1542 27 1542 34 ("sequence-butlast" "seq")}
      {Lisp-Entry "skip-whitespace" definition #f 1546 20 1546 35 ("else" "1" "+" "element" "eq?" "cardinality" "=" "cond" "0" "either" "i" "iter" "let" "start" "start:" "seq")}
      {Lisp-Entry "subseq" definition #f 1553 20 1553 26 ("1" "+" "set!" "element" "set-element!" "<" "while" "j" "0" "i" "allocate-sequence" "sub" "class-of" "cls" "cardinality" "either" "-" "len" "let*" "type" "end" "start" "seq")}
      {Lisp-Entry "replace-subseq!" definition #f 1566 27 1566 42 ("sequence-replace-subseq!" "replacement" "end" "start" "seq")}
      {Lisp-Entry "subseq!" definition #f 1570 20 1570 27 ("sequence-subseq!" "cardinality" "end" "start" "seq")}
      {Lisp-Entry "sort" definition #f 1574 20 1574 24 ("class-of" "List" "sort" "coerce" "null/pair?" "let*" "cddr" "or" "split" "cdr" "cons" "apply-key" "if" "e2" "car" "e1" "let" "else" "null?" "cond" "l2" "l1" "merge" "merge-sort" "smaller" "l" "sort-list" "define" "key" "key:" "seq" "test")}
      {Lisp-Entry "first" definition #f 1605 27 1605 32 ("0" "element" "seq")}
      {Lisp-Entry "second" definition #f 1606 27 1606 33 ("1" "element" "seq")}
      {Lisp-Entry "third" definition #f 1607 27 1607 32 ("2" "element" "seq")}
      {Lisp-Entry "fourth" definition #f 1608 27 1608 33 ("3" "element" "seq")}
      {Lisp-Entry "fifth" definition #f 1609 27 1609 32 ("4" "element" "seq")}
      {Lisp-Entry "sixth" definition #f 1610 27 1610 32 ("5" "element" "seq")}
      {Lisp-Entry "seventh" definition #f 1611 27 1611 34 ("6" "element" "seq")}
      {Lisp-Entry "eighth" definition #f 1612 27 1612 33 ("7" "element" "seq")}
      {Lisp-Entry "ninth" definition #f 1613 27 1613 32 ("8" "element" "seq")}
      {Lisp-Entry "tenth" definition #f 1614 27 1614 32 ("9" "element" "seq")}
      {Lisp-Entry "set-first!" definition #f 1616 27 1616 37 ("0" "set-element!" "value" "seq")}
      {Lisp-Entry "set-second!" definition #f 1617 27 1617 38 ("1" "set-element!" "value" "seq")}
      {Lisp-Entry "set-third!" definition #f 1618 27 1618 37 ("2" "set-element!" "value" "seq")}
      {Lisp-Entry "set-fourth!" definition #f 1619 27 1619 38 ("3" "set-element!" "value" "seq")}
      {Lisp-Entry "set-fifth!" definition #f 1620 27 1620 37 ("4" "set-element!" "value" "seq")}
      {Lisp-Entry "set-sixth!" definition #f 1621 27 1621 37 ("5" "set-element!" "value" "seq")}
      {Lisp-Entry "set-seventh!" definition #f 1622 27 1622 39 ("6" "set-element!" "value" "seq")}
      {Lisp-Entry "set-eighth!" definition #f 1623 27 1623 38 ("7" "set-element!" "value" "seq")}
      {Lisp-Entry "set-ninth!" definition #f 1624 27 1624 37 ("8" "set-element!" "value" "seq")}
      {Lisp-Entry "set-tenth!" definition #f 1625 27 1625 37 ("9" "set-element!" "value" "seq")}
      {Lisp-Entry "element-reversed" definition #f 1628 27 1628 43 ("1" "cardinality" "-" "element" "n" "seq")}
      {Lisp-Entry "iterate" definition #f 1632 20 1632 27 ("in-sequence" "obj" "for" "loop" "proc" "seq")}
      {Lisp-Entry "accumulate" definition #f 1637 20 1637 30 ("coerce" "not" "if" "collect" "in-sequence" "obj" "for" "loop" "lst" "let" "type" "proc" "seq")}
      {Lisp-Entry "apply-key" definition #f 1646 28 1646 37 ("not" "if" "object" "key")}
      {Lisp-Entry "apply-test" definition #f 1652 28 1652 38 ("eqv?" "not" "if" "y" "x" "test")}
      {Lisp-Entry "gather" definition #f 1658 20 1658 26 ("collect" "in-sequence" "obj" "for" "loop" "coerce" "List" "type" "type:" "iterable")}
      {Lisp-Entry "collect" definition #f 1664 20 1664 27 ("class-of" "either" "collect" "when" "apply-key" "val" "with" "in-sequence" "obj" "for" "loop" "coerce" "type" "type:" "key" "key:" "seq" "proc")}
      {Lisp-Entry "collect-if" definition #f 1672 20 1672 30 ("class-of" "collect" "apply-key" "when" "in-sequence" "obj" "for" "loop" "coerce" "key" "key:" "seq" "predicate")}
      {Lisp-Entry "collect-type" definition #f 1679 20 1679 32 ("class-of" "collect" "apply-key" "is?" "when" "in-sequence" "obj" "for" "loop" "coerce" "key" "key:" "seq" "type")}
      {Lisp-Entry "collect-sections" definition #f 1686 20 1686 36 ("reset" "get-output" "put" "begin" "apply-test" "if" "value" "function" "for-each" "section" "List-Factory" "new" "sections" "let" "test" "test:" "separator" "separator:" "lst")}
      {Lisp-Entry "count" definition #f 1700 20 1700 25 ("increase!" "apply-key" "apply-test" "when" "in-sequence" "object" "for" "loop" "0" "total" "let" "test" "test:" "key" "key:" "seq" "target")}
      {Lisp-Entry "count-if" definition #f 1708 20 1708 28 ("increase!" "apply-key" "when" "in-sequence" "object" "for" "loop" "0" "total" "let" "key" "key:" "seq" "predicate")}
      {Lisp-Entry "count-type" definition #f 1716 20 1716 30 ("increase!" "apply-key" "is?" "when" "in-sequence" "object" "for" "loop" "0" "total" "let" "key" "key:" "seq" "type")}
      {Lisp-Entry "find" definition #f 1724 20 1724 24 ("1" "-" "get-position" "continuation-return" "apply-key" "apply-test" "object" "iterate" "exit" "function" "continuation-capture" "set-position" "when" "iterate-sequence" "backward" "'backward" "direction:" "explore" "iterator" "let" "0" "either" "list-find" "not" "null/pair?" "and" "if" "reversed?" "reversed?:" "start" "start:" "test" "test:" "key" "key:" "target" "seq")}
      {Lisp-Entry "list-find" definition #f 1739 13 1739 22 ("1" "+" "cdr" "else" "car" "null?" "cond" "rank" "tail" "rest" "iter" "eqv?" "x" "function" "not" "if" "let" "start" "test" "key" "target" "list")}
      {Lisp-Entry "find-object" definition #f 1750 20 1750 31 ("finally" "return" "when" "apply-key" "val" "with" "in-sequence" "obj" "for" "loop" "key" "key:" "seq" "proc")}
      {Lisp-Entry "find-in" definition #f 1758 20 1758 27 ("continuation-return" "apply-key" "apply-test" "object" "iterate" "exit" "function" "continuation-capture" "set-position" "when" "iterate-sequence" "backward" "'backward" "direction:" "explore" "iterator" "let" "0" "either" "list-find-in" "not" "null/pair?" "and" "if" "reversed?" "reversed?:" "start" "start:" "test" "test:" "key" "key:" "target" "seq")}
      {Lisp-Entry "list-find-in" definition #f 1773 13 1773 25 ("1" "+" "cdr" "else" "car" "null?" "cond" "rank" "tail" "rest" "iter" "eqv?" "x" "function" "not" "if" "let" "start" "test" "key" "target" "list")}
      {Lisp-Entry "find-balanced" definition #f 1784 20 1784 33 ("error" "else" "1" "-" "get-position" "position" "continuation-return" "case" "<" "decrease!" "increase!" "apply-key" "apply-test" "cond" "object" "iterate" "exit" "function" "continuation-capture" "set-position" "when" "0" "count" "iterate-sequence" "backward" "'backward" "direction:" "explore" "if" "iterator" "let" "item" "'item" "return" "return:" "reversed?" "reversed?:" "start" "start:" "test" "test:" "key" "key:" "seq" "close" "open")}
      {Lisp-Entry "find-if" definition #f 1805 20 1805 27 ("error" "else" "1" "-" "get-position" "position" "continuation-return" "case" "apply-key" "object" "iterate" "set-position" "when" "iterate-sequence" "backward" "'backward" "direction:" "explore" "iterator" "let" "exit" "function" "continuation-capture" "0" "either" "find-if-list" "not" "null/pair?" "and" "if" "item" "'item" "return" "return:" "reversed?" "reversed?:" "start" "start:" "key" "key:" "seq" "predicate")}
      {Lisp-Entry "get-rank" definition #f 1823 20 1823 28 ("1" "-" "get-position" "continuation-return" "apply-key" "apply-test" "object" "iterate" "set-position" "when" "iterate-sequence" "backward" "'backward" "direction:" "explore" "iterator" "let" "exit" "function" "continuation-capture" "string-find" "string?" "0" "either" "list-find" "not" "null/pair?" "and" "if" "reversed?" "reversed?:" "start" "start:" "test" "test:" "key" "key:" "seq" "target")}
      {Lisp-Entry "skip" definition #f 1840 20 1840 24 ("1" "get-position" "-" "continuation-return" "apply-key" "not" "when" "object" "iterate" "set-position" "iterate-sequence" "iterator" "let" "return" "function" "continuation-capture" "0" "start" "start:" "key" "key:" "seq" "predicate")}
      {Lisp-Entry "some?" definition #f 1852 20 1852 25 ("continuation-return" "apply-key" "when" "object" "iterate-sequence" "iterate" "return" "function" "continuation-capture" "key" "key:" "seq" "predicate")}
      {Lisp-Entry "every?" definition #f 1862 20 1862 26 ("continuation-return" "apply-key" "not" "when" "object" "iterate-sequence" "iterate" "return" "function" "continuation-capture" "key" "key:" "seq" "predicate")}
      {Lisp-Entry "concatenate" definition #f 1872 20 1872 31 ("class-of" "coerce" "not" "get-output" "output" "put-sequence" "sequence" "function" "for-each" "null/pair?" "list?" "car" "first" "let*" "List-Factory" "new" "fact" "let" "null?" "if" "rest")}
      {Lisp-Entry "concatenate!" definition #f 1887 20 1887 32 ("concatenate" "apply" "rest")}
      {Lisp-Entry "subset?" definition #f 1891 20 1891 27 ("memv?" "element" "function" "every?" "null?" "or" "set2" "set1")}
      {Lisp-Entry "union" definition #f 1898 20 1898 25 ("apply-union" "rest")}
      {Lisp-Entry "apply-union" definition #f 1902 20 1902 31 ("class-of" "coerce" "cdr" "put" "get-output" "member?" "not" "when" "object" "iterate-sequence" "iterate" "set" "function" "for-each" "put-sequence" "List-Factory" "new" "dst" "car" "first" "let" "null?" "if" "test" "test:" "lst")}
      {Lisp-Entry "intersection" definition #f 1917 20 1917 32 ("cons" "apply-intersection" "rest" "first")}
      {Lisp-Entry "apply-intersection" definition #f 1921 20 1921 38 ("class-of" "get-output" "coerce" "put" "member?" "set" "every?" "when" "object" "function" "iterate-sequence" "iterate" "List-Factory" "new" "dst" "cdr" "car" "first" "let" "null?" "if" "test" "test:" "lst")}
      {Lisp-Entry "difference" definition #f 1936 20 1936 30 ("class-of" "get-output" "coerce" "put" "member?" "not" "when" "object" "function" "iterate-sequence" "iterate" "List-Factory" "new" "dst" "let" "null?" "if" "eqv?" "test" "test:" "y" "x")}
      {Lisp-Entry "set-xor" definition #f 1947 20 1947 27 ("difference" "union" "eqv?" "test" "test:" "y" "x")}
      {Lisp-Entry "remove" definition #f 1952 20 1952 26 ("class-of" "get-output" "coerce" "put" "apply-test" "not" "when" "object" "function" "iterate-sequence" "iterate" "List-Factory" "new" "dst" "let" "eqv?" "test" "test:" "seq" "target")}
      {Lisp-Entry "string-remove" specialize #f 1961 15 1961 28 ()}
      {Lisp-Entry "remove" specialize #f 1961 30 1961 36 ("get-output-string" "write-char" "eqv?" "not" "when" "element" "c" "cardinality" "below" "0" "from" "n" "for" "loop" "open-output-string" "output" "let" "str" "target")}
      {Lisp-Entry "remove-trailing" definition #f 1970 20 1970 35 ("reverse" "cons" "set!" "apply-test" "and" "unless" "element" "function" "for-each" "trailing?" "result" "let" "eqv?" "test" "test:" "list" "target")}
      {Lisp-Entry "remove-enclosing" definition #f 1981 20 1981 36 ("subseq" "decrease!" "1" "-" ">" "increase!" "element" "apply-test" "<" "and" "while" "tail" "head" "cardinality" "end" "0" "start" "let*" "eqv?" "test" "test:" "seq" "target")}
      {Lisp-Entry "remove-duplicates" definition #f 1993 20 1993 37 ("class-of" "coerce" "put" "get-output" "apply-key" "member?" "not" "when" "object" "function" "iterate-sequence" "iterate" "List-Factory" "new" "dst" "let" "eqv?" "test" "test:" "key" "key:" "seq")}
      {Lisp-Entry "remove-nils" definition #f 2002 20 2002 31 ("identity" "collect-if" "seq")}
      {Lisp-Entry "remove-empty-strings" definition #f 2006 20 2006 40 ("empty-string?" "not" "obj" "function" "collect-if" "seq")}
      {Lisp-Entry "trim-spaces" definition #f 2012 20 2012 31 ("remove-enclosing" "seq")}
      {Lisp-Entry "trim-whitespace" definition #f 2016 20 2016 35 ("whitespace?" "ignore" "c" "function" "test:" "remove-enclosing" "seq")}
      {Lisp-Entry "mismatch" definition #f 2022 20 2022 28 ("if" "increase!" "continuation-return" "get-next" "or" "when" "done?" "not" "while" "0" "pos" "targ" "iterate-sequence" "srce" "let" "return" "function" "continuation-capture" "equal?" "test" "test:" "seq" "target")}
      {Lisp-Entry "prefix" definition #f 2037 20 2037 26 ("0" "subseq" "cdr" "set!" "<" "not" "or" "and" "when" "mismatch" "n" "object" "function" "for-each" "min" "car" "ref" "let" "null?" "if" "equal?" "test" "test:" "sequences")}
      {Lisp-Entry "prefix?" definition #f 2052 20 2052 27 ("continuation-return" "get-next" "nu/=?" "when" "done?" "not" "and" "while" "iter" "iterate-sequence" "targ" "let" "return" "function" "continuation-capture" "seq" "target")}
      {Lisp-Entry "Search-Context" class #f 2063 15 2063 29 ("Object")
        {Lisp-Entry "target" slot #f 2066 8 2066 14 ()}
        {Lisp-Entry "get-target" accessor #f 2066 48 2066 56 ()}
        {Lisp-Entry "set-target" accessor #f 2066 48 2066 56 ()}
        {Lisp-Entry "whole-words?" slot #f 2067 8 2067 20 ()}
        {Lisp-Entry "get-whole-words?" accessor #f 2067 48 2067 56 ()}
        {Lisp-Entry "set-whole-words?" accessor #f 2067 48 2067 56 ()}
        {Lisp-Entry "ignore-case?" slot #f 2068 8 2068 20 ()}
        {Lisp-Entry "get-ignore-case?" accessor #f 2068 48 2068 56 ()}
        {Lisp-Entry "set-ignore-case?" accessor #f 2068 48 2068 56 ()}
        {Lisp-Entry "regexp?" slot #f 2069 8 2069 15 ()}
        {Lisp-Entry "get-regexp?" accessor #f 2069 48 2069 56 ()}
        {Lisp-Entry "set-regexp?" accessor #f 2069 48 2069 56 ()}
        {Lisp-Entry "constituent-test" slot #f 2070 8 2070 24 ()}
        {Lisp-Entry "get-constituent-test" accessor #f 2070 48 2070 56 ()}
        {Lisp-Entry "set-constituent-test" accessor #f 2070 48 2070 56 ()}
        {Lisp-Entry "regexp" slot #f 2071 8 2071 14 ()}
        {Lisp-Entry "get-regexp" accessor #f 2071 48 2071 56 ()}
        {Lisp-Entry "set-regexp" accessor #f 2071 48 2071 56 ()}
        {Lisp-Entry "user-data" slot #f 2072 8 2072 17 ()}
        {Lisp-Entry "get-user-data" accessor #f 2072 48 2072 56 ()}
        {Lisp-Entry "set-user-data" accessor #f 2072 48 2072 56 ()}}
      {Lisp-Entry "Multi-Search-Context" class #f 2075 15 2075 35 ("Object")
        {Lisp-Entry "regexp" slot #f 2076 8 2076 14 ()}
        {Lisp-Entry "get-regexp" accessor #f 2076 48 2076 56 ()}
        {Lisp-Entry "set-regexp" accessor #f 2076 48 2076 56 ()}
        {Lisp-Entry "contexts" slot #f 2077 8 2077 16 ()}
        {Lisp-Entry "get-contexts" accessor #f 2077 48 2077 56 ()}
        {Lisp-Entry "set-contexts" accessor #f 2077 48 2077 56 ()}}
      {Lisp-Entry "construct-search-context" definition #f 2080 20 2080 44 ("Search-Context" "construct" "user-data" "constituent-test" "regexp?" "ignore-case?" "whole-words?" "target")}
      {Lisp-Entry "make-search-context" definition #f 2084 20 2084 39 ("construct-search-context" "user-data" "user-data:" "constituent-test" "constituent-test:" "regexp?" "regexp?:" "ignore-case?" "ignore-case?:" "whole-words?" "whole-words?:" "target")}
      {Lisp-Entry "make-multi-search-context" definition #f 2092 20 2092 45 ("search-context->sre" "map" "or" "'or" "cons" "sre->irregex" "car" "search-context-regexp" "one-element?" "if" "Multi-Search-Context" "construct" "contexts")}
      {Lisp-Entry "maybe-make-multi-search-context" definition #f 2099 20 2099 51 ("else" "make-multi-search-context" "null/pair?" "cond" "contexts")}
      {Lisp-Entry "standardize-search-contexts" definition #f 2103 20 2103 47 ("list" "map" "null/pair?" "if" "error" "else" "make-search-context" "string?" "Search-Context" "is?" "cond" "standardize-context" "define" "obj")}
      {Lisp-Entry "search-context->sre" definition #f 2113 13 2113 32 ("get-target" "posix-string" "get-regexp?" "seq" "'seq" "w/nocase" "'w/nocase" "get-ignore-case?" "if" "list" "context")}
      {Lisp-Entry "search-context-regexp" definition #f 2119 13 2119 34 ("set-regexp" "search-context->sre" "sre->irregex" "rx" "let" "get-regexp" "or" "context")}
      {Lisp-Entry "matching-context" definition #f 2125 13 2125 29 ("car" "search-context-regexp" "irregex-match" "cdr" "null?" "or" "if" "ls" "lp" "let" "contexts" "str")}
      {Lisp-Entry "multisearch-impl" definition #f 2131 13 2131 29 ("else" "+" "cons" "res" "eqv?" ">=" "1" "-" "element" "=" ">" "cond" "irregex-match-end-index" "to" "irregex-match-start-index" "from" "if" "irregex-search" "m" "best" "0" "not" "i" "lp" "let" "cardinality" "and" "end" "get-whole-words?" "whole-words?" "word-constituent?" "get-contexts" "car" "get-constituent-test" "or" "get-regexp" "rx" "maybe-make-multi-search-context" "multi-search-context" "let*" "reversed?" "start" "constituent-test" "contexts" "seq")}
      {Lisp-Entry "multisearch" definition #f 2157 20 2157 31 ("multisearch-impl" "reversed?" "reversed?:" "start" "start:" "constituent-test" "constituent-test:" "contexts" "seq")}
      {Lisp-Entry "multisearch-all" definition #f 2164 20 2164 35 ("queue-list" "cdr" "car" "enqueue" "begin" "multisearch-impl" "found" "0" "if" "either" "pos" "iter" "maybe-make-multi-search-context" "multi-search-context" "new-queue" "queue" "cardinality" "len" "let" "reversed?" "reversed?:" "start" "start:" "constituent-test" "constituent-test:" "contexts" "seq")}
      {Lisp-Entry "search" definition #f 2180 20 2180 26 ("car" "if" "construct-search-context" "list" "multisearch-impl" "found" "let" "constituent-test" "constituent-test:" "regexp?" "regexp?:" "ignore-case?" "ignore-case?:" "whole-words?" "whole-words?:" "reversed?" "reversed?:" "start" "start:" "target" "seq")}
      {Lisp-Entry "search-all" definition #f 2193 20 2193 30 ("construct-search-context" "list" "multisearch-all" "car" "map" "constituent-test" "constituent-test:" "regexp?" "regexp?:" "ignore-case?" "ignore-case?:" "whole-words?" "whole-words?:" "reversed?" "reversed?:" "start" "start:" "target" "seq")}
      {Lisp-Entry "split" definition #f 2205 20 2205 25 ("when" "search" "iterate" "incr" "else" "get-output" "1" "+" "subseq" "put" "set!" "if" "position" "'position" "return:" "start:" "find-if" "pos" "not" "while" "done?" "List-Factory" "new" "result" "0" "previous" "let" "procedure?" "list" "cardinality" "zero?" "cond" "separator" "seq")}
      {Lisp-Entry "split-justified" definition #f 2234 20 2234 35 ("get-output" "increase!" "+" "set!" "subseq" "put" "begin" "<=" "if" "-" "effective-width" "not" "while" "done?" "List-Factory" "new" "result" "cardinality" "size" "pos" "let" "0" "column" "column:" "separators" "width" "seq")}
      {Lisp-Entry "join" definition #f 2251 20 2251 24 ("get-output" "concatenate" "apply" "seq" "function" "for-each" "put" "List-Factory" "new" "dst" "join-strings" "string?" "if" "first" "let" "else" "car" "cdr" "null?" "cond" "separator" "sequences")}
      {Lisp-Entry "inject" definition #f 2270 20 2270 26 ("get-output" "put" "put-sequence" "set!" "if" "element" "function" "for-each" "first?" "List-Factory" "new" "fact" "let" "inserted" "sequence")}
      {Lisp-Entry "substitute" definition #f 2282 20 2282 30 ("class-of" "get-output" "coerce" "put-sequence" "put" "apply-key" "apply-test" "if" "get-next" "object" "done?" "not" "while" "List-Factory" "new" "dst" "iterate-sequence" "src" "let" "sequence?" "sequence?:" "test" "test:" "key" "key:" "seq" "new-value" "old-value")}
      {Lisp-Entry "substitute-alist" definition #f 2295 20 2295 36 ("class-of" "get-output" "coerce" "put" "set!" "put-sequence" "apply-key" "apply-test" "when" "old" "bind" "unless" "replacement" "function" "for-each" "found?" "get-next" "object" "done?" "not" "while" "List-Factory" "new" "dst" "iterate-sequence" "src" "let" "test" "test:" "key" "key:" "seq" "replacements")}
      {Lisp-Entry "fill!" definition #f 2313 20 2313 25 ("next" "put" "done?" "not" "while" "set-position" "when" "iterate-sequence" "src" "let" "start" "start:" "object" "seq")}
      {Lisp-Entry "replace!" definition #f 2323 20 2323 28 ("next" "get-next" "put" "done?" "not" "and" "while" "set-position" "when" "rep" "iterate-sequence" "src" "let" "start" "start:" "replacement" "seq")}
      {Lisp-Entry "ordered-position" definition #f 2334 20 2334 36 ("find" "<=" "test" "test:" "key" "key:" "seq" "object")}
      {Lisp-Entry "insert-ordered!" definition #f 2338 20 2338 35 ("cardinality" "either" "insert!" "apply-key" "ordered-position" "n" "let" "<=" "test" "test:" "key" "key:" "seq" "object")}
      {Lisp-Entry "merge-ordered" definition #f 2343 20 2343 33 ("get-next" "expr" "error" "else" ":right" ":greater" ":left" ":less" "next" ":same" ":equal" "case" "ky" "apply-key" "kx" "ey" "peek" "ex" "let*" "done?" "not" "and" "while" "compare" "ci-compare" "if" "either" "compare-proc" "iy" "iterate-sequence" "ix" "let" "case-insensitive?" "case-insensitive?:" "test" "test:" "right-key" "right-key:" "left-key" "left-key:" "key" "key:" "y" "x" "proc")}
      {Lisp-Entry "merge" definition #f 2369 20 2369 25 ("get-output" "cdr" "set-car!" "put" ":equal" "neq?" "not" "or" "if" "object" "list" "pair" "function" "for-each-pair" "List-Factory" "new" "res" "apply-key" "min-key" ":compare" "remove-nils" "car" "map" "minimum" "min" "let*" "identity" "some?" "while" "copy" "scan" "let" "compare" "compare:" "key" "key:" "lists" "proc")}
      {Lisp-Entry "random-element" definition #f 2387 20 2387 34 ("cardinality" "random" "element" "seq")}
      {Lisp-Entry "partition" definition #f 2391 20 2391 29 ("elements" "bind" "partition" "map" "reverse!" "cdr" "set-cdr!" "list" "cons" "set!" "not" "if" "associate" "pair" "category" "let*" "element" "function" "for-each" "result" "let" "test" "test:" "identity" "key" "key:" "sequence")}
      {Lisp-Entry "partition-binary" definition #f 2406 20 2406 36 ("values" "cons" "set!" "if" "elem" "function" "for-each" "no" "yes" "let" "predicate" "lst")}
      {Lisp-Entry "starts-with?" definition #f 2417 20 2417 32 ("0" "subseq" ">=" "and" "string=?" "string-ci=?" "if" "test" "tl" "cardinality" "sl" "let" "ignore-case?" "ignore-case?:" "target" "seq")}
      {Lisp-Entry "ends-with?" definition #f 2427 20 2427 30 ("-" "subseq" ">=" "and" "string=?" "string-ci=?" "if" "test" "tl" "cardinality" "sl" "let" "ignore-case?" "ignore-case?:" "target" "seq")}
      {Lisp-Entry "for-each-reversed" definition #f 2437 20 2437 37 ("car" "cdr" "pair?" "when" "iterate" "let" "lst" "proc")}
      {Lisp-Entry "find-if-list" definition #f 2444 13 2444 25 ("1" "+" "cdr" "error" "else" "item" "'item" "position" "'position" "eq?" "car" "null?" "cond" "rank" "tail" "rest" "iter" "x" "function" "not" "if" "let" "returned" "start" "key" "list" "predicate")}
      {Lisp-Entry "insert-sequence!" definition #f 2456 27 2456 43 ("replace-subseq!" "seq" "pos" "sequence")}
      {Lisp-Entry "Sequence-Explorer" class #f 2465 15 2465 32 ("Explorer")
        {Lisp-Entry "sequence" slot #f 2468 8 2468 16 ()}
        {Lisp-Entry "sequence-cardinality" slot #f 2469 8 2469 28 ()}
        {Lisp-Entry "current" slot #f 2470 8 2470 15 ()}
        {Lisp-Entry "initialize" method #f 2473 11 2473 21 ("current" "goto-end" "backward" "goto-beginning" "case" "not" "if" "set-direction" "cardinality" "sequence-cardinality" "sequence" "set!" "nextmethod" "start" "start:" "forward" "'forward" "direction" "direction:" "seq")}
        {Lisp-Entry "peek-forward" method #f 2485 11 2485 23 ("current" "sequence" "element")}
        {Lisp-Entry "peek-backward" method #f 2489 11 2489 24 ("1" "current" "-" "sequence" "element")}
        {Lisp-Entry "goto-beginning" method #f 2493 11 2493 25 ("0" "current" "set!")}
        {Lisp-Entry "goto-end" method #f 2497 11 2497 19 ("sequence-cardinality" "current" "set!")}
        {Lisp-Entry "forward" method #f 2501 11 2501 18 ("1" "current" "increase!")}
        {Lisp-Entry "backward" method #f 2505 11 2505 19 ("1" "current" "decrease!")}
        {Lisp-Entry "done-forward?" method #f 2509 11 2509 24 ("sequence-cardinality" "current" ">=")}
        {Lisp-Entry "done-backward?" method #f 2513 11 2513 25 ("0" "current" "=")}
        {Lisp-Entry "put-forward" method #f 2517 11 2517 22 ("current" "sequence" "set-element!" "object")}
        {Lisp-Entry "put-backward" method #f 2521 11 2521 23 ("1" "current" "-" "sequence" "set-element!" "object")}
        {Lisp-Entry "get-position" method #f 2525 11 2525 23 ("current")}
        {Lisp-Entry "set-position" method #f 2529 11 2529 23 ("sequence-cardinality" "0" "between" "current" "set!" "pos")}
        {Lisp-Entry "get-state" method #f 2533 11 2533 20 ("current")}
        {Lisp-Entry "reset-state" method #f 2537 11 2537 22 ("current" "set!" "state")}}
      {Lisp-Entry "List-Class" class #f 2546 7 2546 17 ("Sequence-Class")
        {Lisp-Entry "allocate-sequence" method #f 2549 11 2549 28 ("make-list" "len")}}
      {Lisp-Entry "List" class #f 2553 17 2553 21 ("Sequence" "List-Class")
        {Lisp-Entry "initialize" method #f 2556 11 2556 21 ("native-class" "rest")}
        {Lisp-Entry "copy-object" method #f 2560 11 2560 22 ("self" "subcopy" "if" "x" "function" "map" "deep?")}
        {Lisp-Entry "iterate-object" method #f 2568 11 2568 25 ("self" "List-Iterator" "new")}
        {Lisp-Entry "sequence-element" method #f 2572 11 2572 27 ("self" "list-ref" "n")}
        {Lisp-Entry "sequence-set-element!" method #f 2576 11 2576 32 ("self" "list-set!" "obj" "n")}
        {Lisp-Entry "sequence-cardinality" method #f 2580 11 2580 31 ("self" "length")}
        {Lisp-Entry "sequence-tail" method #f 2584 11 2584 24 ("1" "-" "cdr" "tail" "0" "=" "self" "null?" "or" "if" "n")}
        {Lisp-Entry "sequence-last" method #f 2590 11 2590 24 ("last" "car" "self" "cdr" "null?" "if")}
        {Lisp-Entry "sequence-butlast" method #f 2596 11 2596 27 ("butlast" "car" "cons" "cdr" "self" "null?" "or" "if")}
        {Lisp-Entry "sequence-subseq!" method #f 2602 11 2602 27 ("subseq" "self" "-1" "0" "=" "or" "if" "end" "start")}
        {Lisp-Entry "replace-subseq!" method #f 2608 11 2608 26 ("+" "after" "1" "-" "before" "let*" "self" "tail" "last-tail" "set-cdr!" "begin" "0" "=" "if" "seq" "end" "start")}}
      {Lisp-Entry "Null-Class" class #f 2620 7 2620 17 ("List-Class")}
      {Lisp-Entry "Null" class #f 2623 17 2623 21 ("List" "Null-Class")
        {Lisp-Entry "compare-object" method #f 2626 11 2626 25 (":not-equal" ":equal" "null?" "if" "obj")}}
      {Lisp-Entry "Pair-Class" class #f 2632 7 2632 17 ("List-Class")}
      {Lisp-Entry "Pair" class #f 2635 17 2635 21 ("List" "Pair-Class")
        {Lisp-Entry "compare-object" method #f 2638 11 2638 25 (":not-equal" "else" "null?" "and" "cond" "right" "cdr" "left" "let" ":equal" ":greater" ":less" "self" "car" "compare" "case" "pair?" "if" "obj")}}
      {Lisp-Entry "element" specialize #f 2658 20 2658 27 ("list-ref" "n" "list")}
      {Lisp-Entry "cardinality" specialize #f 2662 20 2662 31 ("length" "list")}
      {Lisp-Entry "insert!" definition #f 2666 27 2666 34 ("class-of" "list" "coerce" "insert-sequence!" "obj" "pos" "seq")}
      {Lisp-Entry "atom?" definition #f 2670 27 2670 32 ("pair?" "not" "obj")}
      {Lisp-Entry "null/pair?" definition #f 2674 27 2674 37 ("pair?" "null?" "or" "obj")}
      {Lisp-Entry "one-element?" definition #f 2678 27 2678 39 ("cdr" "null?" "pair?" "and" "obj")}
      {Lisp-Entry "last-tail" definition #f 2682 20 2682 29 ("cdr" "pair?" "cur" "iter" "let" "null?" "if" "lst")}
      {Lisp-Entry "make-list" definition #f 2691 20 2691 29 ("1" "-" "cons" "set!" "0" ">" "while" "list" "car" "null?" "if" "fill" "let" "rest" "n")}
      {Lisp-Entry "list-set!" definition #f 2700 27 2700 36 ("list-tail" "set-car!" "value" "n" "list")}
      {Lisp-Entry "set-cadr!" definition #f 2704 27 2704 36 ("cdr" "set-car!" "value" "pair")}
      {Lisp-Entry "append!" definition #f 2708 20 2708 27 ("queue-list" "enqueue-list" "lst" "function" "for-each" "new-queue" "queue" "let" "rest")}
      {Lisp-Entry "position" definition #f 2716 20 2716 28 ("0" "1" "+" "cdr" "else" "car" "eqv?" "null?" "cond" "pos" "function" "position" "letrec" "lst" "element")}
      {Lisp-Entry "copy-tree" definition #f 2728 20 2728 29 ("cdr" "car" "copy-tree" "cons" "pair?" "if" "tree")}
      {Lisp-Entry "position-of" definition #f 2735 20 2735 31 ("1" "+" "cdr" "car" "eq?" "null?" "if" "0" "i" "rst" "iter" "let" "lst" "obj")}
      {Lisp-Entry "proper-list?" definition #f 2744 20 2744 32 ("cdr" "proper-list?" "else" "pair?" "not" "null?" "cond" "lst")}
      {Lisp-Entry "last-cdr" definition #f 2750 20 2750 28 ("cdr" "last-cdr" "pair?" "if" "lst")}
      {Lisp-Entry "but-last-cdr" definition #f 2756 20 2756 32 ("cdr" "but-last-cdr" "car" "cons" "pair?" "if" "lst")}
      {Lisp-Entry "move-to-head!" definition #f 2762 20 2762 33 ("else" "cons" "set-cdr!" "cond" "cdr" "scan" "previous" "iter" "let" "car" "eq?" "null?" "or" "if" "lst" "target")}
      {Lisp-Entry "move-to-tail!" definition #f 2773 20 2773 33 ("begin" "if" "scan" "previous" "iter" "let" "else" "cdr" "cons" "last-tail" "set-cdr!" "car" "eq?" "null?" "cond" "lst" "target")}
      {Lisp-Entry "augment" definition #f 2792 20 2792 27 ("get-output" "set!" "put" "car" "put-sequence" "cdr" "null?" "if" "not-null?" "while" "scan" "List-Factory" "new" "fact" "let" "rest")}
      {Lisp-Entry "memq?" definition #f 2803 27 2803 32 ("memq" "boolean" "list" "target")}
      {Lisp-Entry "memv?" definition #f 2807 27 2807 32 ("memv" "boolean" "list" "target")}
      {Lisp-Entry "member?" definition #f 2811 20 2811 27 ("cdr" "else" "car" "apply-key" "apply-test" "null?" "cond" "scan" "iter" "let" "equal?" "test" "test:" "key" "key:" "list" "target")}
      {Lisp-Entry "assq-value" definition #f 2821 20 2821 30 ("cdr" "if" "assq" "pair" "let" "default-value" "list" "key")}
      {Lisp-Entry "assv-value" definition #f 2828 20 2828 30 ("cdr" "if" "assv" "pair" "let" "default-value" "list" "key")}
      {Lisp-Entry "assoc-value" definition #f 2835 20 2835 31 ("cdr" "if" "assoc" "pair" "let" "default-value" "list" "key")}
      {Lisp-Entry "associate" definition #f 2842 20 2842 29 ("cdr" "apply-key" "apply-test" "car" "pair" "null?" "if" "scan" "iter" "let" "equal?" "test" "test:" "key" "key:" "list" "target")}
      {Lisp-Entry "rassociate" definition #f 2852 20 2852 30 ("cdr" "apply-key" "apply-test" "car" "pair" "null?" "if" "scan" "iter" "let" "equal?" "test" "test:" "key" "key:" "list" "target")}
      {Lisp-Entry "find-pair" definition #f 2862 20 2862 29 ("cdr" "else" "car" "eq?" "null?" "cond" "scan" "iter" "let" "list" "target")}
      {Lisp-Entry "reverse!" definition #f 2872 20 2872 28 ("set-cdr!" "cdr" "set!" "not-null?" "while" "ptr" "res" "let" "list")}
      {Lisp-Entry "remove!" definition #f 2883 20 2883 27 ("set-cdr!" "begin" "scan" "previous" "let" "null?" "if" "cdr" "set!" "car" "apply-key" "not-null?" "and" "while" "eqv?" "test" "test:" "key" "key:" "list" "target")}
      {Lisp-Entry "getprop" definition #f 2900 20 2900 27 ("cddr" "else" "car" "apply-key" "eqv?" "null?" "cond" "scan" "iter" "let" "key" "key:" "target" "plist")}
      {Lisp-Entry "getf" definition #f 2910 20 2910 24 ("cadr" "not" "if" "getprop" "pair" "let" "not-found" "not-found:" "key" "key:" "target" "plist")}
      {Lisp-Entry "setf" definition #f 2917 20 2917 24 ("getprop" "set-second!" "value" "target" "plist")}
      {Lisp-Entry "addf" definition #f 2921 20 2921 24 ("set-second!" "list" "append!" "not" "if" "getprop" "pair" "let" "value" "target" "plist")}
      {Lisp-Entry "for-each-pair" definition #f 2929 20 2929 33 ("cdr" "set!" "not-null?" "while" "lst" "proc")}
      {Lisp-Entry "for-each-property" definition #f 2935 20 2935 37 ("cddr" "set!" "cadr" "car" "not-null?" "while" "lst" "proc")}
      {Lisp-Entry "map-property" definition #f 2941 20 2941 32 ("queue-list" "enqueue" "value" "property" "function" "for-each-property" "new-queue" "queue" "let" "lst" "proc")}
      {Lisp-Entry "flatten" definition #f 2949 20 2949 27 ("append" "apply" "llist")}
      {Lisp-Entry "uniform" definition #f 2953 20 2953 27 ("cdr" "continuation-return" "apply-test" "unless" "value" "object" "for-each" "car" "apply-key" "first" "let" "return" "function" "continuation-capture" "null?" "if" "test" "test:" "key" "key:" "lst")}
      {Lisp-Entry "sort-property-list" definition #f 2967 20 2967 38 ("append" "apply" "car" "key:" "<" "sort" "sorted" "get-output" "for-each-property" "begin" "alist" "list" "put" "value" "property" "function" "proc" "List-Factory" "new" "factory" "let*" "prop-list")}
      {Lisp-Entry "List-Iterator" class #f 2983 15 2983 28 ("Iterator")
        {Lisp-Entry "current" slot #f 2986 8 2986 15 ()}
        {Lisp-Entry "position" slot #f 2987 8 2987 16 ()}
        {Lisp-Entry "initialize" method #f 2990 11 2990 21 ("0" "position" "current" "set!" "nextmethod" "list")}
        {Lisp-Entry "get-next!" method #f 2996 11 2996 20 ("1" "+" "position" "cdr" "set!" "car" "prog1" "eof-object" "current" "null?" "if")}
        {Lisp-Entry "done?" method #f 3004 11 3004 16 ("Empty" "peeked" "eq?" "current" "null?" "and")}
        {Lisp-Entry "put" method #f 3008 11 3008 14 ("current" "set-car!" "object")}
        {Lisp-Entry "get-position" method #f 3012 11 3012 23 ("position")}
        {Lisp-Entry "set-position" method #f 3016 11 3016 23 ("tail" "current" "set!" ">" "error" "0" "<" "cond" "position" "-" "delta" "let" "pos")}
        {Lisp-Entry "get-state" method #f 3024 11 3024 20 ("position" "current" "cons")}
        {Lisp-Entry "reset-state" method #f 3028 11 3028 22 ("cdr" "position" "car" "current" "set!" "state")}
        {Lisp-Entry "get-list" method #f 3033 18 3033 26 ("current")}}
      {Lisp-Entry "List-Factory" class #f 3042 7 3042 19 ("0" "initialize" "Object")
        {Lisp-Entry "list" slot #f 3045 8 3045 12 ()}
        {Lisp-Entry "last-list" slot #f 3046 8 3046 17 ()}
        {Lisp-Entry "last-anchor" slot #f 3047 8 3047 19 ()}
        {Lisp-Entry "current" slot #f 3048 8 3048 15 ()}
        {Lisp-Entry "size" slot #f 3049 8 3049 12 ()}
        {Lisp-Entry "put" method #f 3052 11 3052 14 ("increase!" "size" "prog1" "cdr" "set-cdr!" "copy-last-list" "last-list" "when" "else" "list" "cons" "set!" "current" "null?" "cond" "object")}
        {Lisp-Entry "put-unique" method #f 3065 11 3065 21 ("put" "list" "member?" "unless" "eqv?" "test" "test:" "object")}
        {Lisp-Entry "put-sequence" method #f 3070 11 3070 23 ("cardinality" "increase!" "size" "prog1" "set-cdr!" "last-anchor" "copy-last-list" "else" "list" "last-list" "set!" "current" "null?" "cond" "put" "iterate" "pair?" "not" "if" "when" "seq")}
        {Lisp-Entry "is-empty?" method #f 3088 18 3088 27 ("current" "null?")}
        {Lisp-Entry "get-size" method #f 3092 18 3092 26 ("size")}
        {Lisp-Entry "get-list" method #f 3096 18 3096 26 ("list")}
        {Lisp-Entry "get-last-element" method #f 3100 18 3100 34 ("current" "car")}
        {Lisp-Entry "get-output" method #f 3104 11 3104 21 ("list")}
        {Lisp-Entry "reset" method #f 3108 18 3108 23 ("0" "size" "current" "last-anchor" "last-list" "list" "set!")}
        {Lisp-Entry "copy-last-list" method #f 3116 19 3116 33 ("set-cdr!" "else" "last-tail" "current" "last-list" "copy" "list" "set!" "last-anchor" "not" "cond")}}
      {Lisp-Entry "Table" class #f 3132 17 3132 22 ("Object")
        {Lisp-Entry "initialize" method #f 3135 11 3135 21 ("native-class" "rest")}
        {Lisp-Entry "print" method #f 3139 11 3139 16 ("table-length" "system-format" "function" "self" "print-unreadable" "readably" "printer")}}
      {Lisp-Entry "table-add" definition #f 3146 20 3146 29 ("table-ref" "cons" "table-set!" "value" "key" "table")}
      {Lisp-Entry "table-remove!" definition #f 3150 20 3150 33 ("table-ref" "remove!" "table-set!" "value" "name" "table")}
      {Lisp-Entry "empty-table" definition #f 3154 20 3154 31 ("empty-table" "'empty-table" "unimplemented" "table")}
      {Lisp-Entry "table-keys" definition #f 3158 20 3158 30 ("cons" "set!" "value" "key" "function" "iterate-table" "list" "let" "table")}
      {Lisp-Entry "table-values" definition #f 3166 20 3166 32 ("cons" "set!" "value" "key" "function" "iterate-table" "list" "let" "table")}
      {Lisp-Entry "table-keys/values" definition #f 3174 20 3174 37 ("cons" "set!" "value" "key" "function" "iterate-table" "list" "let" "table")}
      {Lisp-Entry "table-load" definition #f 3182 20 3182 30 ("table-set!" "error" "table-ref" "if" "eof-object?" "not" "and" "when" "object" "read" "name" "iterate" "let" "reader" "function" "cr-lf" "'cr-lf" "eol-encoding:" "parse" "path:" "list" "call-with-input-file" "error-on-duplicates?" "file" "table")}
      {Lisp-Entry "Slot" class #f 3201 7 3201 11 ("Field")
        {Lisp-Entry "offset" slot #f 3204 8 3204 14 ()}
        {Lisp-Entry "get-offset" accessor #f 3204 26 3204 34 ()}
        {Lisp-Entry "initialize" slot #f 3205 8 3205 18 ()}
        {Lisp-Entry "get-initialize" accessor #f 3205 26 3205 34 ()}}
      {Lisp-Entry "Property" class #f 3213 7 3213 15 ("Slot")
        {Lisp-Entry "getter" slot #f 3216 8 3216 14 ()}
        {Lisp-Entry "get-getter" accessor #f 3216 22 3216 30 ()}
        {Lisp-Entry "setter" slot #f 3217 8 3217 14 ()}
        {Lisp-Entry "get-setter" accessor #f 3217 22 3217 30 ()}}
      {Lisp-Entry "property?" definition #f 3220 27 3220 36 ("Property" "is?" "obj")}
      {Lisp-Entry "symbolize-property" definition #f 3224 20 3224 38 ("else" "keyword->symbol" "keyword?" "get-name" "field?" "cond" "property")}
      {Lisp-Entry "symbolize-properties" definition #f 3230 20 3230 40 ("get-output" "symbolize-property" "put" "value" "property" "function" "for-each-property" "List-Factory" "new" "fact" "let" "properties")}
      {Lisp-Entry "keywordize-property" definition #f 3240 20 3240 39 ("else" "keyword?" "field-name" "symbol->keyword" "field?" "cond" "property")}
      {Lisp-Entry "keywordize-properties" definition #f 3246 20 3246 41 ("get-output" "keywordize-property" "put" "value" "property" "function" "for-each-property" "List-Factory" "new" "fact" "let" "properties")}
      {Lisp-Entry "read-property" definition #f 3256 20 3256 33 ("property-field" "property-getter" "getter" "let" "expr" "object")}
      {Lisp-Entry "write-property" definition #f 3261 20 3261 34 ("property-field" "property-setter" "setter" "let" "value" "expr" "object")}
      {Lisp-Entry "property-field" definition #f 3266 20 3266 34 ("error" "keyword->symbol" "keyword?" "class-of" "category-field" "field" "let" "property?" "if" "expr" "object")}
      {Lisp-Entry "String-Class" class #f 3280 7 3280 19 ("Sequence-Class")
        {Lisp-Entry "allocate-sequence" method #f 3283 11 3283 28 ("make-string" "len")}
        {Lisp-Entry "coerce-object" method #f 3287 11 3287 24 ("coerce-string" "nextmethod" "sequence?" "if" "obj")}}
      {Lisp-Entry "String" class #f 3293 17 3293 23 ("Sequence" "String-Class")
        {Lisp-Entry "initialize" method #f 3296 11 3296 21 ("native-class" "rest")}
        {Lisp-Entry "compare-object" method #f 3300 11 3300 25 (":incompatible" ":greater" "else" ":less" "string<?" ":equal" "self" "string=?" "cond" "string?" "if" "obj")}
        {Lisp-Entry "ci-compare-object" method #f 3312 11 3312 28 (":incompatible" ":greater" "else" ":less" "string-ci<?" ":equal" "self" "string-ci=?" "cond" "string?" "if" "obj")}
        {Lisp-Entry "sequence-element" method #f 3324 11 3324 27 ("self" "string-ref" "n")}
        {Lisp-Entry "sequence-set-element!" method #f 3328 11 3328 32 ("self" "string-set!" "obj" "n")}
        {Lisp-Entry "sequence-cardinality" method #f 3332 11 3332 31 ("self" "string-length")}
        {Lisp-Entry "sequence-tail" method #f 3336 11 3336 24 ("substring" ">=" "if" "self" "cardinality" "lgt" "let" "n")}
        {Lisp-Entry "sequence-last" method #f 3343 11 3343 24 ("1" "cardinality" "-" "self" "element")}
        {Lisp-Entry "sequence-butlast" method #f 3347 11 3347 27 ("1" "cardinality" "-" "0" "self" "substring")}}
      {Lisp-Entry "=" specialize #f 3351 20 3351 21 ("string=?" "s2" "s1")}
      {Lisp-Entry "element" specialize #f 3355 20 3355 27 ("string-ref" "n" "string")}
      {Lisp-Entry "set-element!" specialize #f 3359 20 3359 32 ("string-set!" "c" "n" "string")}
      {Lisp-Entry "cardinality" specialize #f 3363 20 3363 31 ("string-length" "string")}
      {Lisp-Entry "subseq" specialize #f 3367 20 3367 26 ("substring" "end" "start" "string")}
      {Lisp-Entry "replace-subseq!" specialize #f 3371 13 3371 28 ("cardinality" "0" "subseq" "string-append" "replacement" "end" "start" "string")}
      {Lisp-Entry "empty-string?" definition #f 3386 27 3386 40 ("string-length" "zero?" "string?" "and" "object")}
      {Lisp-Entry "->string" definition #f 3391 20 3391 28 ("get-output-string" "print" "open-output-string" "output" "let" ":human" "':human" "detail" "expr")}
      {Lisp-Entry "remove-trailing-char" definition #f 3397 20 3397 40 ("subseq" "1" "-" "element" "eqv?" "0" ">" "and" "if" "cardinality" "len" "let" "c" "string")}
      {Lisp-Entry "value-string?" definition #f 3405 20 3405 33 ("empty-string?" "not" "string?" "and" "object")}
      {Lisp-Entry "wi=" definition #f 3410 20 3410 23 ("else" "eqv?" "eq?" "continuation-return" "cond" "when" ">=" "increase!" "element" "whitechar?" "and" "set!" "not" "or" "while" "d2?" "=" "d1?" "w2?" "w1?" "s?" "l2" "cardinality" "l1" "n2" "0" "n1" "let*" "return" "function" "continuation-capture" "s2" "s1")}
      {Lisp-Entry "unique-domain-name" definition #f 3450 20 3450 38 ("increase!" "->string" "set!" "iterate" "let" "suffix" "1" "n" "subseq" "starts-with?" "when" "string" "function" "collect" "suffixes" "cardinality" "common-length" "append" "common-prefix" "let*" "member?" "not" "if" "separator" "separator:" "domain" "name")}
      {Lisp-Entry "remove-numeric-suffix" definition #f 3470 20 3470 41 ("1" "+" "0" "subseq" "if" "position" "'position" "return:" "reversed?:" "numeric?" "not" "c" "function" "find-if" "pos" "let" "string")}
      {Lisp-Entry "compare-n" definition #f 3477 20 3477 29 ("1" "+" "string-ref" "not" "or" ">=" "if" "0" "n" "iter" "ylen" "string-length" "xlen" "let" "eqv?" "test" "test:" "max" "y" "x")}
      {Lisp-Entry "string-checksum" definition #f 3488 20 3488 35 ("1" "+" "string-ref" "char->integer" "increase!" "<" "when" "n" "iter" "string-length" "len" "0" "sum" "let" "str")}
      {Lisp-Entry "primordial-thread-object" definition #f 3503 12 3503 36 ("current-thread")}
      {Lisp-Entry "primordial-thread" definition #f 3507 20 3507 37 ("primordial-thread-object")}
      {Lisp-Entry "primordial-thread?" definition #f 3511 20 3511 38 ("primordial-thread" "current-thread" "eq?")}
      {Lisp-Entry "new-thread" definition #f 3515 20 3515 30 ("make-root-thread" "apply" "rest" "thunk")}
      {Lisp-Entry "top-threads" definition #f 3521 20 3521 31 ("primordial-thread" "thread-thread-group" "thread-group->thread-list")}
      {Lisp-Entry "present-thread-name" definition #f 3525 20 3525 39 ("->string" "else" "unspecified?" "not" "or" "cond" "name")}
      {Lisp-Entry "present-thread-state" definition #f 3530 20 3530 40 ("get-output-string" "else" "when" "write" "thread-state-active-timeout" "thread-state-active-waiting-for" "wf" "thread-state-active?" "thread-state-abnormally-terminated?" "thread-state-normally-terminated?" "thread-state-initialized?" "system-format" "thread-state-uninitialized?" "cond" "10.0" "*" "round" "/" "current-systime" "systime->seconds" "-" "expiry" "display" "to" "write-timeout" "define" "open-output-string" "port" "let" "state")}
      {Lisp-Entry "present-object" definition #f 3568 20 3568 34 (":reader" "->string" "object->serial" "number->string" "class-of" "type-name" "identifier-name" "symbol->string" "string-append" "class-string" "let" "exc" "function" "with-exception-catcher" "object")}
      {Lisp-Entry "thread-loop?" definition #f 3583 21 3583 33 ("thread-specific" "thread")}
      {Lisp-Entry "thread-start-loop" definition #f 3586 21 3586 38 ("thread-specific-set!" "thread")}
      {Lisp-Entry "thread-stop-loop" definition #f 3589 21 3589 37 ("thread-specific-set!" "thread")}
      {Lisp-Entry "thread-loop" definition #f 3593 21 3593 32 ("current-thread" "thread-loop?" "when" "thread-read" "thunk" "loop" "let")}
      {Lisp-Entry "thread-ports" definition #f 3601 12 3601 24 ("weak-keys:" "eq?" "test:" "make-table")}
      {Lisp-Entry "thread-ports-mutex" definition #f 3604 12 3604 30 ("thread-ports" "'thread-ports" "make-mutex")}
      {Lisp-Entry "thread-has-port?" definition #f 3608 21 3608 37 ("thread-ports" "table-ref" "boolean" "thread")}
      {Lisp-Entry "get-thread-port" definition #f 3612 13 3612 28 ("mutex-unlock!" "table-set!" "open-vector" "port" "let" "thread-ports" "table-ref" "either" "prog1" "thread-ports-mutex" "mutex-lock!" "thread")}
      {Lisp-Entry "thread-write" definition #f 3621 21 3621 33 ("force-output" "write" "get-thread-port" "thread-port" "let" "value" "thread")}
      {Lisp-Entry "thread-read" definition #f 3627 21 3627 32 ("read" "+infinity" "input-port-timeout-set!" "current-thread" "get-thread-port" "thread-port" "let")}
      {Lisp-Entry "thread-read-non-blocking" definition #f 3633 21 3633 45 ("read" "0" "input-port-timeout-set!" "current-thread" "get-thread-port" "thread-port" "let")}
      {Lisp-Entry "thread-post" definition #f 3639 20 3639 31 ("thread-write" "current-thread" "eq?" "if" "thunk" "name" "thread")}
      {Lisp-Entry "thread-execute" definition #f 3645 20 3645 34 ("mutex-unlock!" "unwind-protect" "function" "thread-write" "mutex-lock!" "make-mutex" "mutex" "let" "current-thread" "eq?" "if" "thunk" "name" "thread")}
      {Lisp-Entry "thread-call-noresult" definition #f 3658 12 3658 32 ("thread-call-noresult" "'thread-call-noresult" "list")}
      {Lisp-Entry "thread-call-result?" definition #f 3662 21 3662 40 ("thread-call-noresult" "neq?" "result")}
      {Lisp-Entry "thread-call" definition #f 3666 20 3666 31 ("mutex-specific" "mutex-unlock!" "unwind-protect" "function" "thread-write" "thread-call-noresult" "mutex-specific-set!" "mutex-lock!" "make-mutex" "mutex" "eq?" "if" "current-thread" "delegator" "let" "thunk" "name" "thread")}
      {Lisp-Entry "thread-exit" definition #f 3682 20 3682 31 ("pristine-thread-continuation" "continuation-return")}
      {Lisp-Entry "is-not?" definition #f 3691 27 3691 34 ("is?" "not" "type" "object")}
      {Lisp-Entry "type-name" definition #f 3695 27 3695 36 ("get-category-name" "type")}
      {Lisp-Entry "type-ascendant" definition #f 3699 27 3699 41 ("get-class-ascendant" "type")}
      {Lisp-Entry "type-descendants" definition #f 3703 20 3703 36 ("get-category-descendants" "type")}
      {Lisp-Entry "Vector-Class" class #f 3712 7 3712 19 ("Sequence-Class")
        {Lisp-Entry "allocate-sequence" method #f 3715 11 3715 28 ("make-vector" "len")}}
      {Lisp-Entry "Vector" class #f 3719 17 3719 23 ("Sequence" "Vector-Class")
        {Lisp-Entry "initialize" method #f 3722 11 3722 21 ("native-class" "rest")}
        {Lisp-Entry "object-similar?" method #f 3727 11 3727 26 ("self" "cardinality" "zero?" "vector?" "and" "object")}
        {Lisp-Entry "sequence-element" method #f 3733 11 3733 27 ("self" "vector-ref" "n")}
        {Lisp-Entry "sequence-set-element!" method #f 3737 11 3737 32 ("self" "vector-set!" "obj" "n")}
        {Lisp-Entry "sequence-cardinality" method #f 3741 11 3741 31 ("self" "vector-length")}
        {Lisp-Entry "sequence-tail" method #f 3745 11 3745 24 ("self" "vector->list" "tail" "list->vector" "n")}
        {Lisp-Entry "sequence-last" method #f 3749 11 3749 24 ("1" "cardinality" "-" "self" "element")}
        {Lisp-Entry "sequence-butlast" method #f 3753 11 3753 27 ("self" "vector->list" "butlast" "list->vector")}}
      {Lisp-Entry "element" specialize #f 3757 20 3757 27 ("vector-ref" "n" "vector")}
      {Lisp-Entry "set-element!" specialize #f 3761 20 3761 32 ("vector-set!" "obj" "n" "vector")}
      {Lisp-Entry "cardinality" specialize #f 3765 20 3765 31 ("vector-length" "vector")}
      {Lisp-Entry "AXIS_MIN_SIZE" definition #f 3774 12 3774 25 ("8")}
      {Lisp-Entry "AXIS_GOLDEN_RATIO" definition #f 3775 12 3775 29 ("1.6")}
      {Lisp-Entry "Axis-Class" class #f 3778 7 3778 17 ("Sequence-Class")
        {Lisp-Entry "allocate-sequence" method #f 3781 11 3781 28 ("Axis" "new" "len")}}
      {Lisp-Entry "Axis" class #f 3785 7 3785 11 ("Sequence" "Axis-Class")
        {Lisp-Entry "size" slot #f 3788 8 3788 12 ()}
        {Lisp-Entry "get-size" accessor #f 3788 35 3788 43 ()}
        {Lisp-Entry "set-size" accessor #f 3788 35 3788 43 ()}
        {Lisp-Entry "content" slot #f 3789 8 3789 15 ()}
        {Lisp-Entry "get-content" accessor #f 3789 35 3789 43 ()}
        {Lisp-Entry "set-content" accessor #f 3789 35 3789 43 ()}
        {Lisp-Entry "initialize" method #f 3792 11 3792 21 ("make-vector" "content" "size" "set!" "s")}
        {Lisp-Entry "print" method #f 3797 11 3797 16 ("content" "size" "system-format" "function" "self" "print-unreadable" "detail" "output")}
        {Lisp-Entry "sequence-element" method #f 3803 11 3803 27 ("self" "element" "n")}
        {Lisp-Entry "sequence-set-element!" method #f 3807 11 3807 32 ("self" "set-element!" "obj" "n")}
        {Lisp-Entry "sequence-cardinality" method #f 3811 11 3811 31 ("self" "cardinality")}
        {Lisp-Entry "sequence-tail" method #f 3815 11 3815 24 ("self" "tail" "n")}
        {Lisp-Entry "sequence-last" method #f 3819 11 3819 24 ("self" "last")}}
      {Lisp-Entry "axis" definition #f 3823 20 3823 24 ("Axis" "coerce" "rest")}
      {Lisp-Entry "element" specialize #f 3827 20 3827 27 ("get-content" "vector-ref" "n" "axis")}
      {Lisp-Entry "set-element!" specialize #f 3831 20 3831 32 ("get-content" "vector-set!" "obj" "n" "axis")}
      {Lisp-Entry "cardinality" specialize #f 3835 20 3835 31 ("get-size" "axis")}
      {Lisp-Entry "tail" specialize #f 3839 13 3839 17 ("1" "+" "element" "set-element!" ">=" "if" "0" "i" "iter" "get-size" "-" "offset" "Axis" "new" "new-axis" "let" "n" "axis")}
      {Lisp-Entry "last" specialize #f 3849 13 3849 17 ("1" "get-size" "-" "element" "axis")}
      {Lisp-Entry "insert!" specialize #f 3853 13 3853 20 ("list" "replace-subseq!" "obj" "pos" "axis")}
      {Lisp-Entry "replace-subseq!" specialize #f 3857 13 3857 28 ("axis-grow" "1" "element" "set-element!" "0" ">" "when" "dst" "src" "n" "iter" "let" "<" "cond" "+" "new-size" "get-size" "old-size" "delta" "cardinality" "after" "-" "before" "let*" "replacement" "end" "start" "axis")}
      {Lisp-Entry "axis-remove!" definition #f 3887 20 3887 32 ("replace-subseq!" "1" "+" "end" "start" "let*" "when" "find" "n" "let" "element" "axis")}
      {Lisp-Entry "axis-grow" definition #f 3895 20 3895 29 ("1" "+" "element" "set-element!" "begin" "<" "when" "i" "iter" "AXIS_GOLDEN_RATIO" "*" "fxround" "old-content" "old-real-size" "let" "else" "AXIS_MIN_SIZE" "make-vector" "set-content" "0" "get-size" "=" "set-size" "get-content" "cardinality" "<=" "cond" "n" "axis")}
      {Lisp-Entry "axis-add" definition #f 3913 20 3913 28 ("set-element!" "1" "+" "axis-grow" "cardinality" "size" "let" "obj" "axis")}
      {Lisp-Entry "new-axis" definition #f 3919 27 3919 35 ("make-vector" "Axis" "construct" "size")}
      {Lisp-Entry "new" specialize #f 3922 20 3922 23 ("new-axis" "size" "class")}
      {Lisp-Entry "allocate" specialize #f 3926 13 3926 21 ("new-axis" "size" "class")}
      {Lisp-Entry "coerce" specialize #f 3930 13 3930 19 ("element" "set-element!" "below" "0" "from" "n" "for" "loop" "allocate" "new-sequence" "cardinality" "len" "let" "class" "seq")}
      {Lisp-Entry "axis-ref" specialize #f 3938 22 3938 30 ()}
      {Lisp-Entry "element" specialize #f 3938 32 3938 39 ("get-content" "vector-ref" "n" "axis")}
      {Lisp-Entry "axis-set!" specialize #f 3942 22 3942 31 ()}
      {Lisp-Entry "set-element!" specialize #f 3942 33 3942 45 ("get-content" "vector-set!" "obj" "n" "axis")}
      {Lisp-Entry "axis-cardinality" specialize #f 3946 22 3946 38 ()}
      {Lisp-Entry "cardinality" specialize #f 3946 40 3946 51 ("get-size" "axis")}
      {Lisp-Entry "Enumeration" class #f 3961 7 3961 18 ("Type")
        {Lisp-Entry "name" slot #f 3964 8 3964 12 ()}
        {Lisp-Entry "entries" slot #f 3965 8 3965 15 ()}
        {Lisp-Entry "construct-literal" method #f 3969 16 3969 33 ("self" "new" "entries" "name" "context")}
        {Lisp-Entry "initialize" method #f 3973 11 3973 21 ("entries~self" "name~self" "set!" "Enumeration" "nextmethod" "entries" "name")}
        {Lisp-Entry "print" method #f 3979 11 3979 16 ("entries" "name" "self" "class-of" "type-name" "system-format" "readably" "printer")}
        {Lisp-Entry "get-name" method #f 3986 18 3986 26 ("name")}
        {Lisp-Entry "get-entries" method #f 3990 18 3990 29 ("entries")}
        {Lisp-Entry "set-value" method #f 3994 18 3994 27 ("entry-from-name" "cdr" "set-car!" "value" "name")}
        {Lisp-Entry "get-size" method #f 3998 11 3998 19 ("int" "size-of")}
        {Lisp-Entry "read-content" method #f 4002 11 4002 23 ("%read-int" "address")}
        {Lisp-Entry "write-content" method #f 4006 11 4006 24 ("%write-int" "object" "address")}
        {Lisp-Entry "entry-from-name" method #f 4010 11 4010 26 ("self" "error" "eq?" "test:" "first" "key:" "entries" "find-in" "either" "name")}
        {Lisp-Entry "entry-from-value" method #f 4015 11 4015 27 ("self" "error" "eqv?" "test:" "second" "key:" "entries" "find-in" "either" "value")}
        {Lisp-Entry "value->name" method #f 4020 18 4020 29 ("entry-from-value" "car" "value")}
        {Lisp-Entry "name->value" method #f 4024 18 4024 29 ("entry-from-name" "cadr" "name")}
        {Lisp-Entry "get-rank" method #f 4028 18 4028 26 ("eq?" "test:" "first" "key:" "entries" "find" "1" "+" "0" "name" "=" "if" "target")}}
      {Lisp-Entry "enumeration?" definition #f 4034 27 4034 39 ("enumeration?" "'enumeration?" "unimplemented" "object")}
      {Lisp-Entry "set-enumeration!" definition #f 4038 20 4038 36 ("set-value" "set-enumeration!" "'set-enumeration!" "unimplemented" "value" "name" "enumeration")}
      {Lisp-Entry "nil" definition #f 4049 19 4049 22 ("nil" "'nil" "list")}
      {Lisp-Entry "nil?" definition #f 4053 27 4053 31 ("nil" "eq?" "obj")}
      {Lisp-Entry "not-nil?" definition #f 4057 27 4057 35 ("nil" "eq?" "not" "obj")}
      {Lisp-Entry "parse-file" definition #f 4066 20 4066 30 ("parse" "string?" "if" "file")}
      {Lisp-Entry "Chunk-Size" definition #f 4072 12 4072 22 ("1024")}
      {Lisp-Entry "make-u8-content" definition #f 4076 33 4076 48 ("cons" "content" "size")}
      {Lisp-Entry "u8-content-size" definition #f 4079 33 4079 48 ("car" "content")}
      {Lisp-Entry "iterate-u8-content" definition #f 4082 33 4082 51 ("cdr" "size" "u8vector" "bind" "chunk" "function" "for-each" "proc" "content")}
      {Lisp-Entry "read-u8-content" definition #f 4089 33 4089 48 ("cons" "put" "increase!" "get-output" "make-u8-content" "=" "if" "read-subu8vector" "read" "Chunk-Size" "make-u8vector" "u8vector" "loop" "List-Factory" "new" "fact" "0" "size" "let" "port")}
      {Lisp-Entry "write-u8-content" definition #f 4102 33 4102 49 ("0" "write-subu8vector" "size" "u8vector" "function" "iterate-u8-content" "port" "content")}
      {Lisp-Entry "start-pump" definition #f 4108 33 4108 43 ("substring" ">" "if" "1" "0" "read-substring" "n" "iterate" "make-string" "buffer" "1000" "size" "let" "proper-tail-calls" "declare" "proc" "port")}
      {Lisp-Entry "read-until" definition #f 4126 20 4126 30 ("enqueue" "queue-list" "if" "read" "expr" "iterate" "new-queue" "queue" "let" "reader" "test")}
      {Lisp-Entry "read-string-element" definition #f 4136 20 4136 39 ("read" "call-with-input-string" "string")}
      {Lisp-Entry "read-string-content" definition #f 4141 20 4141 39 ("eof-object?" "read-until" "reader" "function" "call-with-input-string" "string")}
      {Lisp-Entry "read-delimited-string" definition #f 4147 20 4147 41 ("get-output" "peek-char" "eof-object?" "if" "skip-whites" "put" "read-delimited" "lst" "iterate" "List-Factory" "new" "fact" "let" "reader" "function" "call-with-input-string" "char" "string")}
      {Lisp-Entry "require-char" definition #f 4160 20 4160 32 ("error" "eof-object?" "if" "read-char" "c" "let" "reader")}
      {Lisp-Entry "skip-line" definition #f 4167 20 4167 29 ("eqv?" "eof-object?" "not" "and" "if" "read-char" "c" "iterate" "let" "reader")}
      {Lisp-Entry "skip-whites" definition #f 4178 20 4178 31 ("read-char" "whitespace?" "when" "skip-line" "eqv?" "if" "eof-object?" "unless" "peek-char" "c" "iterate" "let" "reader")}
      {Lisp-Entry "read-delimited" definition #f 4189 20 4189 34 ("enqueue" "else" "read" "enqueue-list" "read-char" "eqv?" "error" "queue-list" "if" "eof-object?" "cond" "peek-char" "c" "skip-whites" "iterate" "new-queue" "queue" "let" "allow-eof?" "delimiter" "kind" "reader")}
      {Lisp-Entry "string-delimiter?" definition #f 4209 27 4209 44 ("eqv?" "c")}
      {Lisp-Entry "read-lines" definition #f 4213 20 4213 30 ("queue-list" "when" "enqueue" "begin" "if" "read-proper-line" "proper?" "line" "receive" "last-proper?" "iterate" "new-queue" "queue" "let" "proper-tail-calls" "declare" "reader")}
      {Lisp-Entry "read-content-string" definition #f 4227 20 4227 39 ("eof-object?" "if" "read-line" "line" "let" "reader")}
      {Lisp-Entry "pipe" definition #f 4236 20 4236 24 ("write-char" "begin" "eof-object?" "not" "if" "read-char" "c" "iterate" "let" "output" "input")}
      {Lisp-Entry "textual" definition #f 4250 20 4250 27 (":text" "print" "write" "current-output-port" "printer" "expr")}
      {Lisp-Entry "describe" definition #f 4256 20 4256 28 (":describe" "print" "current-output-port" "printer" "expr")}
      {Lisp-Entry "print-expr" definition #f 4260 13 4260 23 ("print" "current-output-port" "printer" "detail" "expr")}
      {Lisp-Entry "print-unsigned" definition #f 4264 13 4264 27 ("print-unsigned" "'print-unsigned" "unimplemented" "current-output-port" "printer" "n")}
      {Lisp-Entry "print-binary" definition #f 4268 13 4268 25 ("2" "number->string" "display" "current-output-port" "printer" "n")}
      {Lisp-Entry "print-hexadecimal" definition #f 4272 13 4272 30 ("16" "number->string" "display" "current-output-port" "printer" "n")}
      {Lisp-Entry "print-real" definition #f 4276 13 4276 23 ("new-frac" ">" "and" "carry?" "dot-pos" "or" "if" "len" "string->number" "round" "temp-str" "last-part" "first-part" "else" "-" "make-string" "string-append" "<" "display" "=" "cond" "frac-len" "string-length" "1" "+" "frac-str" "0" "substring" "pre-str" "find" "dot-index" "exact->inexact" "number->string" "str" "let*" "current-output-port" "printer" "precision" "r")}
      {Lisp-Entry "print-list" definition #f 4315 13 4315 23 ("null?" "pair?" "if" "cdr" "next" "print" "car" "expr" "scan" "iter" "let" "display" "not-null?" "when" "current-output-port" "printer" "detail" "after" "before" "last-separator" "separator" "list")}
      {Lisp-Entry "fresh-line" definition #f 4333 20 4333 30 ("newline" "at-fresh-line?" "unless" "current-output-port" "printer")}
      {Lisp-Entry "at-fresh-line?" definition #f 4338 20 4338 34 ("current-output-port" "printer")}
      {Lisp-Entry "*printers*" definition #f 4348 12 4348 22 ("eq?" "test:" "make-table")}
      {Lisp-Entry "register-printer" definition #f 4352 21 4352 37 ("*printers*" "table-set!" "proc" "name")}
      {Lisp-Entry "with-printer" definition #f 4356 20 4356 32 ("*printers*" "table-ref" "printer-proc" "get-output-string" "open-output-string" "let" ":string" "eq?" "if" "proc" "printer")}
      {Lisp-Entry "pp" definition #f 4376 19 4376 21 ("pretty-print")}
      {Lisp-Entry "present-identifier" definition #f 4380 20 4380 38 ("0" "1" "element" "system-format" "reverse!" "reversed" "car" "cdr" "null?" "if" "symbol->string" "split" "names" "let" "identifier")}
      {Lisp-Entry "write-line" definition #f 4388 20 4388 30 ("newline" "display" "car" "null?" "if" "port" "let" "rest" "line")}
      {Lisp-Entry "write-lines" definition #f 4394 20 4394 31 ("newline" "null?" "unless" "display" "do" "remain" "remainder" "in" "line" "for" "loop" "lines" "printer")}
      {Lisp-Entry "identity" definition #f 4406 27 4406 35 ("x")}
      {Lisp-Entry "compose" definition #f 4410 27 4410 34 ("x" "function" "g" "f")}
      {Lisp-Entry "Subseq-Class" class #f 4420 7 4420 19 ("Sequence-Class")}
      {Lisp-Entry "Subseq" class #f 4423 7 4423 13 ("Sequence" "Subseq-Class")
        {Lisp-Entry "sequence" slot #f 4426 8 4426 16 ()}
        {Lisp-Entry "get-sequence" accessor #f 4426 32 4426 40 ()}
        {Lisp-Entry "start" slot #f 4427 8 4427 13 ()}
        {Lisp-Entry "get-start" accessor #f 4427 32 4427 40 ()}
        {Lisp-Entry "set-start" accessor #f 4427 32 4427 40 ()}
        {Lisp-Entry "size" slot #f 4428 8 4428 12 ()}
        {Lisp-Entry "get-size" accessor #f 4428 32 4428 40 ()}
        {Lisp-Entry "set-size" accessor #f 4428 32 4428 40 ()}
        {Lisp-Entry "initialize" method #f 4431 11 4431 21 ("size~self" "start~self" "sequence~self" "set!" "nextmethod" "size" "start" "sequence")}
        {Lisp-Entry "print" method #f 4438 11 4438 16 ("system-format" "function" "self" "print-unreadable" "string-ref" "write-char" "do" "size" "+" "below" "start" "from" "n" "for" "loop" "sequence" "string?" "if" "detail" "output")}
        {Lisp-Entry "coerce-string" method #f 4448 11 4448 24 ("error" "size" "+" "start" "substring" "sequence" "string?" "if")}
        {Lisp-Entry "sequence-element" method #f 4454 11 4454 27 ("start" "+" "sequence" "element" "n")}
        {Lisp-Entry "sequence-set-element!" method #f 4458 11 4458 32 ("start" "+" "sequence" "set-element!" "obj" "n")}
        {Lisp-Entry "sequence-cardinality" method #f 4462 11 4462 31 ("size")}
        {Lisp-Entry "sequence-subseq!" method #f 4466 11 4466 27 ("cardinality" "-" "start" "+" "sequence" "Subseq" "new" "self" "-1" "0" "=" "or" "if" "e" "s")}}
      {Lisp-Entry "offset-subseq!" definition #f 4472 20 4472 34 ("get-start" "+" "set-start" "offset" "subseq")}
      {Lisp-Entry "grow-subseq!" definition #f 4476 20 4476 32 ("get-size" "+" "set-size" "n" "subseq")}
      {Lisp-Entry "subseq-ref" specialize #f 4480 22 4480 32 ()}
      {Lisp-Entry "element" specialize #f 4480 34 4480 41 ("get-start" "+" "get-sequence" "element" "n" "subseq")}
      {Lisp-Entry "subseq-set!" specialize #f 4484 22 4484 33 ()}
      {Lisp-Entry "set-element!" specialize #f 4484 35 4484 47 ("get-start" "+" "get-sequence" "set-element!" "obj" "n" "subseq")}
      {Lisp-Entry "subseq-cardinality" specialize #f 4488 22 4488 40 ()}
      {Lisp-Entry "cardinality" specialize #f 4488 42 4488 53 ("get-size" "subseq")}
      {Lisp-Entry "Subseq$string$-Class" class #f 4497 7 4497 27 ("Sequence-Class")}
      {Lisp-Entry "Subseq$string$" class #f 4500 7 4500 21 ("Sequence" "Subseq$string$-Class")
        {Lisp-Entry "sequence" slot #f 4503 8 4503 16 ()}
        {Lisp-Entry "get-sequence" accessor #f 4503 36 4503 44 ()}
        {Lisp-Entry "start" slot #f 4504 8 4504 13 ()}
        {Lisp-Entry "get-start" accessor #f 4504 36 4504 44 ()}
        {Lisp-Entry "set-start" accessor #f 4504 36 4504 44 ()}
        {Lisp-Entry "size" slot #f 4505 8 4505 12 ()}
        {Lisp-Entry "get-size" accessor #f 4505 36 4505 44 ()}
        {Lisp-Entry "set-size" accessor #f 4505 36 4505 44 ()}
        {Lisp-Entry "initialize" method #f 4508 11 4508 21 ("size~self" "start~self" "sequence~self" "set!" "nextmethod" "size" "start" "sequence")}
        {Lisp-Entry "print" method #f 4515 11 4515 16 ("size" "+" "start" "sequence" "substring" "display" "detail" "output")}
        {Lisp-Entry "sequence-element" method #f 4520 11 4520 27 ("start" "+" "sequence" "element" "n")}
        {Lisp-Entry "sequence-set-element!" method #f 4524 11 4524 32 ("start" "+" "sequence" "set-element!" "obj" "n")}
        {Lisp-Entry "sequence-cardinality" method #f 4528 11 4528 31 ("size")}
        {Lisp-Entry "sequence-subseq!" method #f 4532 11 4532 27 ("cardinality" "-" "start" "+" "sequence" "Subseq$string$" "new" "self" "-1" "0" "=" "or" "if" "e" "s")}}
      {Lisp-Entry "new" specialize #f 4538 20 4538 23 ("Subseq$string$" "construct" "size" "start" "sequence" "class")}
      {Lisp-Entry "element" specialize #f 4542 20 4542 27 ("get-start" "+" "get-sequence" "element" "n" "subseq")}
      {Lisp-Entry "set-element!" specialize #f 4546 20 4546 32 ("get-start" "+" "get-sequence" "set-element!" "obj" "n" "subseq")}
      {Lisp-Entry "cardinality" specialize #f 4550 20 4550 31 ("get-size" "subseq")}
      {Lisp-Entry "subseq!" specialize #f 4554 13 4554 20 ("-" "Subseq$string$" "new" "e" "s" "seq")}
      {Lisp-Entry "subseq!" specialize #f 4558 13 4558 20 ("-" "get-start" "+" "get-sequence" "Subseq$string$" "new" "e" "s" "subseq")}
      {Lisp-Entry "offset-subseq!" specialize #f 4562 13 4562 27 ("get-start" "+" "set-start" "offset" "subseq")}
      {Lisp-Entry "grow-subseq!" specialize #f 4566 13 4566 25 ("get-size" "+" "set-size" "n" "subseq")}}})
"geometry"
 ({Lisp-File-Entry {File jazz "src" "jazz" "dialect" "language" "geometry.jazz"} 1253368908
    {Lisp-Entry "jazz.dialect.language.geometry" library #f 37 19 37 49 ("jazz.dialect")
      {Lisp-Entry "private" native #f 49 8 49 15 ("jazz.error")}
      {Lisp-Entry "Cell" class #f 57 7 57 11 ("Numeric")
        {Lisp-Entry "row" slot #f 60 8 60 11 ()}
        {Lisp-Entry "get-row" accessor #f 60 27 60 35 ()}
        {Lisp-Entry "set-row" accessor #f 60 27 60 35 ()}
        {Lisp-Entry "col" slot #f 61 8 61 11 ()}
        {Lisp-Entry "get-col" accessor #f 61 27 61 35 ()}
        {Lisp-Entry "set-col" accessor #f 61 27 61 35 ()}
        {Lisp-Entry "initialize" method #f 64 11 64 21 ("col" "row" "set!" "c" "r")}
        {Lisp-Entry "copy-object" method #f 69 11 69 22 ("col" "row" "Cell" "new" "deep?")}
        {Lisp-Entry "compare-object" method #f 73 11 73 25 ("get-col" "col" ":equal" "eq?" "not" "get-row" "row" "compare" "compared" "let" ":incompatible" "Cell" "is-not?" "if" "target")}
        {Lisp-Entry "print" method #f 82 11 82 16 ("col" "row" "self" "class-of" "type-name" "identifier-name" "format" "readably" "printer")}
        {Lisp-Entry "numeric-norm" method #f 89 11 89 23 ("self" "error")}
        {Lisp-Entry "numeric-add" method #f 93 11 93 22 ("self" "error" "else" "integer?" "get-col" "col" "get-row" "row" "+" "new" "Cell" "is?" "cond" "n")}
        {Lisp-Entry "numeric-negate" method #f 99 11 99 25 ("col" "row" "-" "Cell" "new")}
        {Lisp-Entry "numeric-multiply" method #f 103 11 103 27 ("self" "error" "col" "row" "*" "Cell" "new" "integer?" "if" "n")}
        {Lisp-Entry "numeric-inverse" method #f 109 11 109 26 ("self" "error")}
        {Lisp-Entry "increase-row" method #f 113 18 113 30 ("+" "row" "set!" "1" "delta")}
        {Lisp-Entry "increase-col" method #f 117 18 117 30 ("+" "col" "set!" "1" "delta")}}
      {Lisp-Entry "new-cell" definition #f 121 27 121 35 ("Cell" "construct" "col" "row")}
      {Lisp-Entry "new" specialize #f 124 20 124 23 ("new-cell" "col" "row" "class")}
      {Lisp-Entry "copy-cell" specialize #f 128 22 128 31 ()}
      {Lisp-Entry "copy" specialize #f 128 33 128 37 ("get-col" "get-row" "Cell" "new" "c")}
      {Lisp-Entry "cell=" specialize #f 132 22 132 27 ()}
      {Lisp-Entry "=" specialize #f 132 29 132 30 ("get-col" "get-row" "=" "and" "c2" "c1")}
      {Lisp-Entry "cell<" specialize #f 137 15 137 20 ()}
      {Lisp-Entry "<" specialize #f 137 22 137 23 ("get-col" "=" "and" "<" "or" "r2" "get-row" "r1" "let" "c2" "c1")}
      {Lisp-Entry "cell<=" specialize #f 145 15 145 21 ()}
      {Lisp-Entry "<=" specialize #f 145 23 145 25 ("get-col" "<=" "=" "and" "<" "or" "r2" "get-row" "r1" "let" "c2" "c1")}
      {Lisp-Entry "cell>" specialize #f 153 15 153 20 ()}
      {Lisp-Entry ">" specialize #f 153 22 153 23 ("get-col" "=" "and" ">" "or" "r2" "get-row" "r1" "let" "c2" "c1")}
      {Lisp-Entry "cell>=" specialize #f 161 15 161 21 ()}
      {Lisp-Entry ">=" specialize #f 161 23 161 25 ("get-col" ">=" "=" "and" ">" "or" "r2" "get-row" "r1" "let" "c2" "c1")}
      {Lisp-Entry "cell+" specialize #f 169 22 169 27 ()}
      {Lisp-Entry "+" specialize #f 169 29 169 30 ("get-col" "get-row" "+" "Cell" "new" "c2" "c1")}
      {Lisp-Entry "+" specialize #f 175 20 175 21 ("get-col" "+" "get-row" "Cell" "new" "n" "c")}
      {Lisp-Entry "cell-" specialize #f 181 22 181 27 ()}
      {Lisp-Entry "-" specialize #f 181 29 181 30 ("get-col" "get-row" "-" "Cell" "new" "c2" "c1")}
      {Lisp-Entry "-" specialize #f 187 20 187 21 ("get-col" "-" "get-row" "Cell" "new" "n" "c")}
      {Lisp-Entry "Range" class #f 198 7 198 12 ("Object")
        {Lisp-Entry "start" slot #f 201 8 201 13 ()}
        {Lisp-Entry "end" slot #f 202 8 202 11 ()}
        {Lisp-Entry "initialize" method #f 205 11 205 21 ("end" "start" "set!" "nextmethod" "e" "s")}
        {Lisp-Entry "copy-object" method #f 211 11 211 22 ("end" "start" "Range" "new" "deep?")}
        {Lisp-Entry "compare-object" method #f 215 11 215 25 (":not-equal" "else" ":equal" "get-end" "end" "get-start" "start" "=" "and" ":incompatible" "Range" "is-not?" "cond" "target")}
        {Lisp-Entry "print" method #f 224 11 224 16 ("end" "start" "self" "class-of" "type-name" "identifier-name" "format" "readably" "printer")}
        {Lisp-Entry "get-start" method #f 231 25 231 34 ("start")}
        {Lisp-Entry "get-end" method #f 235 25 235 32 ("end")}
        {Lisp-Entry "extent" method #f 239 26 239 32 ("start" "end" "-")}
        {Lisp-Entry "extended?" method #f 243 26 243 35 ("end" "start" "=" "not")}
        {Lisp-Entry "empty?" method #f 247 26 247 32 ("end" "start" "=")}
        {Lisp-Entry "inside?" method #f 251 18 251 25 ("end" "<" "start" ">=" "and" "n")}
        {Lisp-Entry "before?" method #f 256 18 256 25 ("start" "<" "n")}
        {Lisp-Entry "after?" method #f 260 18 260 24 ("end" ">" "n")}
        {Lisp-Entry "intersect?" method #f 264 18 264 28 ("start" "get-end" ">=" "end" "get-start" "<" "and" "range")}
        {Lisp-Entry "intersect" method #f 269 18 269 27 ("get-end" "end" "min" "get-start" "start" "max" "self" "class-of" "new" "intersect?" "when" "range")}}
      {Lisp-Entry "new-range" definition #f 274 27 274 36 ("Range" "construct" "end" "start")}
      {Lisp-Entry "new" specialize #f 277 20 277 23 ("new-range" "end" "start" "class")}
      {Lisp-Entry "range=" specialize #f 281 22 281 28 ()}
      {Lisp-Entry "=" specialize #f 281 30 281 31 ("get-end" "get-start" "=" "and" "r2" "r1")}
      {Lisp-Entry "Range$Cell$" class #f 291 7 291 18 ("Object")
        {Lisp-Entry "start" slot #f 294 8 294 13 ()}
        {Lisp-Entry "get-start" accessor #f 294 28 294 36 ()}
        {Lisp-Entry "end" slot #f 295 8 295 11 ()}
        {Lisp-Entry "get-end" accessor #f 295 28 295 36 ()}
        {Lisp-Entry "initialize" method #f 298 11 298 21 ("end" "start" "set!" "nextmethod" "e" "s")}
        {Lisp-Entry "copy-object" method #f 304 11 304 22 ("end" "start" "Range$Cell$" "new" "deep?")}
        {Lisp-Entry "compare-object" method #f 308 11 308 25 (":not-equal" "else" ":equal" "get-end" "end" "get-start" "start" "=" "and" ":incompatible" "Range$Cell$" "is-not?" "cond" "target")}
        {Lisp-Entry "print" method #f 317 11 317 16 ("end" "start" "self" "class-of" "type-name" "identifier-name" "format" "readably" "printer")}
        {Lisp-Entry "extent" method #f 324 26 324 32 ("start" "end" "-")}
        {Lisp-Entry "extended?" method #f 328 26 328 35 ("end" "start" "=" "not")}
        {Lisp-Entry "empty?" method #f 332 26 332 32 ("end" "start" "=")}
        {Lisp-Entry "inside?" method #f 336 18 336 25 ("end" "<" "start" ">=" "and" "n")}
        {Lisp-Entry "before?" method #f 341 18 341 25 ("start" "<" "n")}
        {Lisp-Entry "after?" method #f 345 18 345 24 ("end" ">" "n")}
        {Lisp-Entry "intersect?" method #f 349 18 349 28 ("start" "get-end" ">=" "end" "get-start" "<" "and" "range")}
        {Lisp-Entry "intersect" method #f 354 18 354 27 ("get-end" "end" "min" "get-start" "start" "max" "self" "class-of" "new" "intersect?" "when" "range")}}
      {Lisp-Entry "new" specialize #f 359 20 359 23 ("Range$Cell$" "construct" "end" "start" "class")}
      {Lisp-Entry "=" specialize #f 363 20 363 21 ("get-end" "get-start" "=" "and" "r2" "r1")}
      {Lisp-Entry "Point" class #f 373 7 373 12 ("Numeric")
        {Lisp-Entry "h" slot #f 376 8 376 9 ()}
        {Lisp-Entry "get-h" accessor #f 376 22 376 30 ()}
        {Lisp-Entry "v" slot #f 377 8 377 9 ()}
        {Lisp-Entry "get-v" accessor #f 377 22 377 30 ()}
        {Lisp-Entry "initialize" method #f 380 11 380 21 ("v~self" "h~self" "set!" "nextmethod" "v" "h")}
        {Lisp-Entry "copy-object" method #f 386 11 386 22 ("v" "h" "Point" "new" "deep?")}
        {Lisp-Entry "compare-object" method #f 390 11 390 25 (":not-equal" "else" ":equal" "get-v" "v" "get-h" "h" "=" "and" "target-point" "let" ":incompatible" "Point" "is-not?" "cond" "target")}
        {Lisp-Entry "print" method #f 400 11 400 16 ("v" "h" "format" "readably" "printer")}
        {Lisp-Entry "numeric-norm" method #f 406 11 406 23 ("v" "2" "h" "expt" "+" "sqrt")}
        {Lisp-Entry "numeric-add" method #f 410 11 410 22 ("self" "error" "else" "integer?" "get-height" "get-width" "Dimension" "get-v" "v" "get-h" "h" "+" "new" "Point" "is?" "cond" "n")}
        {Lisp-Entry "numeric-negate" method #f 417 11 417 25 ("v" "h" "-" "Point" "new")}
        {Lisp-Entry "numeric-multiply" method #f 421 11 421 27 ("self" "error" "v" "h" "*" "Point" "new" "integer?" "if" "n")}
        {Lisp-Entry "numeric-inverse" method #f 427 11 427 26 ("self" "error")}}
      {Lisp-Entry "new-point" definition #f 431 27 431 36 ("Point" "construct" "v" "h")}
      {Lisp-Entry "new" specialize #f 434 20 434 23 ("new-point" "v" "h" "class")}
      {Lisp-Entry "point=" specialize #f 438 22 438 28 ()}
      {Lisp-Entry "=" specialize #f 438 30 438 31 ("get-v" "get-h" "=" "and" "p2" "p1")}
      {Lisp-Entry "point+" specialize #f 443 22 443 28 ()}
      {Lisp-Entry "+" specialize #f 443 30 443 31 ("get-v" "get-h" "+" "Point" "new" "p2" "p1")}
      {Lisp-Entry "+" specialize #f 449 20 449 21 ("get-v" "get-h" "+" "Point" "new" "n" "p")}
      {Lisp-Entry "point-" specialize #f 455 22 455 28 ()}
      {Lisp-Entry "-" specialize #f 455 30 455 31 ("get-v" "get-h" "-" "Point" "new" "p2" "p1")}
      {Lisp-Entry "-" specialize #f 461 20 461 21 ("get-v" "get-h" "-" "Point" "new" "n" "p")}
      {Lisp-Entry "-" specialize #f 467 20 467 21 ("get-v" "get-h" "-" "Point" "new" "p")}
      {Lisp-Entry "point*" specialize #f 473 22 473 28 ()}
      {Lisp-Entry "*" specialize #f 473 30 473 31 ("get-v" "get-h" "*" "Point" "new" "n" "p")}
      {Lisp-Entry "Dimension" class #f 484 7 484 16 ("Numeric")
        {Lisp-Entry "width" slot #f 487 8 487 13 ()}
        {Lisp-Entry "get-width" accessor #f 487 27 487 35 ()}
        {Lisp-Entry "height" slot #f 488 8 488 14 ()}
        {Lisp-Entry "get-height" accessor #f 488 27 488 35 ()}
        {Lisp-Entry "initialize" method #f 491 11 491 21 ("height" "width" "set!" "nextmethod" "h" "w")}
        {Lisp-Entry "copy-object" method #f 497 11 497 22 ("height" "width" "Dimension" "new" "deep?")}
        {Lisp-Entry "compare-object" method #f 501 11 501 25 ("get-height" "height" ":equal" "neq?" "get-width" "width" "compare" "compared" "let" ":incompatible" "Dimension" "is-not?" "if" "target")}
        {Lisp-Entry "print" method #f 510 11 510 16 ("height" "width" "format" "readably" "printer")}
        {Lisp-Entry "numeric-norm" method #f 516 11 516 23 ("self" "error")}
        {Lisp-Entry "numeric-add" method #f 520 11 520 22 ("self" "error" "else" "integer?" "get-v" "get-h" "Point" "get-height" "height" "get-width" "width" "+" "new" "Dimension" "is?" "cond" "n")}
        {Lisp-Entry "numeric-negate" method #f 527 11 527 25 ("height" "width" "-" "Dimension" "new")}
        {Lisp-Entry "numeric-multiply" method #f 531 11 531 27 ("self" "error" "height" "width" "*" "Dimension" "new" "integer?" "if" "n")}
        {Lisp-Entry "numeric-inverse" method #f 537 11 537 26 ("self" "error")}}
      {Lisp-Entry "new-dimension" definition #f 541 27 541 40 ("Dimension" "construct" "height" "width")}
      {Lisp-Entry "new" specialize #f 544 20 544 23 ("new-dimension" "height" "width" "class")}
      {Lisp-Entry "dimension=" specialize #f 548 22 548 32 ()}
      {Lisp-Entry "=" specialize #f 548 34 548 35 ("get-height" "get-width" "=" "and" "d2" "d1")}
      {Lisp-Entry "dimension+" specialize #f 553 22 553 32 ()}
      {Lisp-Entry "+" specialize #f 553 34 553 35 ("get-height" "get-width" "+" "Dimension" "new" "d2" "d1")}
      {Lisp-Entry "dimension-" specialize #f 559 22 559 32 ()}
      {Lisp-Entry "-" specialize #f 559 34 559 35 ("get-height" "get-width" "-" "Dimension" "new" "d2" "d1")}
      {Lisp-Entry "dimension*" specialize #f 565 22 565 32 ()}
      {Lisp-Entry "*" specialize #f 565 34 565 35 ("get-height" "get-width" "*" "Dimension" "new" "n" "d")}
      {Lisp-Entry "Rect-Class" class #f 576 7 576 17 ("Class")
        {Lisp-Entry "coerce-object" method #f 579 11 579 24 ("nextmethod" "else" "0" "get-v" "get-h" "Rect" "new" "Point" "typecase" "object")}}
      {Lisp-Entry "Rect" class #f 585 7 585 11 ("Object" "Rect-Class")
        {Lisp-Entry "left" slot #f 589 8 589 12 ()}
        {Lisp-Entry "get-left" accessor #f 589 34 589 42 ()}
        {Lisp-Entry "set-left" accessor #f 589 34 589 42 ()}
        {Lisp-Entry "top" slot #f 590 8 590 11 ()}
        {Lisp-Entry "get-top" accessor #f 590 34 590 42 ()}
        {Lisp-Entry "set-top" accessor #f 590 34 590 42 ()}
        {Lisp-Entry "right" slot #f 591 8 591 13 ()}
        {Lisp-Entry "get-right" accessor #f 591 34 591 42 ()}
        {Lisp-Entry "set-right" accessor #f 591 34 591 42 ()}
        {Lisp-Entry "bottom" slot #f 592 8 592 14 ()}
        {Lisp-Entry "get-bottom" accessor #f 592 34 592 42 ()}
        {Lisp-Entry "set-bottom" accessor #f 592 34 592 42 ()}
        {Lisp-Entry "initialize" method #f 595 11 595 21 ("bottom" "right" "top" "left" "set!" "nextmethod" "b" "r" "t" "l")}
        {Lisp-Entry "copy-object" method #f 603 11 603 22 ("bottom" "right" "top" "left" "Rect" "new" "deep?")}
        {Lisp-Entry "compare-object" method #f 607 11 607 25 (":not-equal" "else" ":equal" "get-bottom" "bottom" "get-right" "right" "get-top" "top" "get-left" "left" "=" "and" ":incompatible" "Rect" "is-not?" "cond" "target")}
        {Lisp-Entry "print" method #f 616 11 616 16 ("bottom" "right" "top" "left" "self" "class-of" "type-name" "identifier-name" "format" "readably" "printer")}}
      {Lisp-Entry "new-rect" definition #f 625 27 625 35 ("Rect" "construct" "bottom" "right" "top" "left")}
      {Lisp-Entry "new" specialize #f 628 20 628 23 ("new-rect" "bottom" "right" "top" "left" "class")}
      {Lisp-Entry "rect=" specialize #f 632 22 632 27 ()}
      {Lisp-Entry "=" specialize #f 632 29 632 30 ("get-bottom" "get-right" "get-top" "get-left" "=" "and" "r2" "r1")}}})
"homogeneous"
 ({Lisp-File-Entry {File jazz "src" "jazz" "dialect" "language" "homogeneous.jazz"} 1250720196
    {Lisp-Entry "jazz.dialect.language.homogeneous" library #f 37 19 37 52 ("jazz.dialect")
      {Lisp-Entry "S8Vector-Class" class #f 53 7 53 21 ("Sequence-Class")
        {Lisp-Entry "allocate-sequence" method #f 56 11 56 28 ("make-s8vector" "len")}}
      {Lisp-Entry "S8Vector" class #f 60 17 60 25 ("Sequence" "S8Vector-Class")
        {Lisp-Entry "initialize" method #f 63 11 63 21 ("native-class" "rest")}
        {Lisp-Entry "object-similar?" method #f 68 11 68 26 ("self" "cardinality" "zero?" "vector?" "and" "object")}
        {Lisp-Entry "sequence-element" method #f 74 11 74 27 ("self" "s8vector-ref" "n")}
        {Lisp-Entry "sequence-set-element!" method #f 78 11 78 32 ("self" "s8vector-set!" "obj" "n")}
        {Lisp-Entry "sequence-cardinality" method #f 82 11 82 31 ("self" "s8vector-length")}
        {Lisp-Entry "sequence-tail" method #f 86 11 86 24 ("self" "s8vector->list" "tail" "list->s8vector" "n")}
        {Lisp-Entry "sequence-last" method #f 90 11 90 24 ("1" "cardinality" "-" "self" "element")}
        {Lisp-Entry "sequence-butlast" method #f 94 11 94 27 ("self" "s8vector->list" "butlast" "list->s8vector")}}
      {Lisp-Entry "element" specialize #f 98 20 98 27 ("s8vector-ref" "n" "vector")}
      {Lisp-Entry "set-element!" specialize #f 102 20 102 32 ("s8vector-set!" "obj" "n" "vector")}
      {Lisp-Entry "cardinality" specialize #f 106 20 106 31 ("s8vector-length" "vector")}
      {Lisp-Entry "U8Vector-Class" class #f 115 7 115 21 ("Sequence-Class")
        {Lisp-Entry "allocate-sequence" method #f 118 11 118 28 ("make-u8vector" "len")}}
      {Lisp-Entry "U8Vector" class #f 122 17 122 25 ("Sequence" "U8Vector-Class")
        {Lisp-Entry "initialize" method #f 125 11 125 21 ("native-class" "rest")}
        {Lisp-Entry "object-similar?" method #f 130 11 130 26 ("self" "cardinality" "zero?" "vector?" "and" "object")}
        {Lisp-Entry "sequence-element" method #f 136 11 136 27 ("self" "u8vector-ref" "n")}
        {Lisp-Entry "sequence-set-element!" method #f 140 11 140 32 ("self" "u8vector-set!" "obj" "n")}
        {Lisp-Entry "sequence-cardinality" method #f 144 11 144 31 ("self" "u8vector-length")}
        {Lisp-Entry "sequence-tail" method #f 148 11 148 24 ("self" "u8vector->list" "tail" "list->u8vector" "n")}
        {Lisp-Entry "sequence-last" method #f 152 11 152 24 ("1" "cardinality" "-" "self" "element")}
        {Lisp-Entry "sequence-butlast" method #f 156 11 156 27 ("self" "u8vector->list" "butlast" "list->u8vector")}}
      {Lisp-Entry "element" specialize #f 160 20 160 27 ("u8vector-ref" "n" "vector")}
      {Lisp-Entry "set-element!" specialize #f 164 20 164 32 ("u8vector-set!" "obj" "n" "vector")}
      {Lisp-Entry "cardinality" specialize #f 168 20 168 31 ("u8vector-length" "vector")}
      {Lisp-Entry "S16Vector-Class" class #f 177 7 177 22 ("Sequence-Class")
        {Lisp-Entry "allocate-sequence" method #f 180 11 180 28 ("make-s16vector" "len")}}
      {Lisp-Entry "S16Vector" class #f 184 17 184 26 ("Sequence" "S16Vector-Class")
        {Lisp-Entry "initialize" method #f 187 11 187 21 ("native-class" "rest")}
        {Lisp-Entry "object-similar?" method #f 192 11 192 26 ("self" "cardinality" "zero?" "vector?" "and" "object")}
        {Lisp-Entry "sequence-element" method #f 198 11 198 27 ("self" "s16vector-ref" "n")}
        {Lisp-Entry "sequence-set-element!" method #f 202 11 202 32 ("self" "s16vector-set!" "obj" "n")}
        {Lisp-Entry "sequence-cardinality" method #f 206 11 206 31 ("self" "s16vector-length")}
        {Lisp-Entry "sequence-tail" method #f 210 11 210 24 ("self" "s16vector->list" "tail" "list->s16vector" "n")}
        {Lisp-Entry "sequence-last" method #f 214 11 214 24 ("1" "cardinality" "-" "self" "element")}
        {Lisp-Entry "sequence-butlast" method #f 218 11 218 27 ("self" "s16vector->list" "butlast" "list->s16vector")}}
      {Lisp-Entry "element" specialize #f 222 20 222 27 ("s16vector-ref" "n" "vector")}
      {Lisp-Entry "set-element!" specialize #f 226 20 226 32 ("s16vector-set!" "obj" "n" "vector")}
      {Lisp-Entry "cardinality" specialize #f 230 20 230 31 ("s16vector-length" "vector")}
      {Lisp-Entry "U16Vector-Class" class #f 239 7 239 22 ("Sequence-Class")
        {Lisp-Entry "allocate-sequence" method #f 242 11 242 28 ("make-u16vector" "len")}}
      {Lisp-Entry "U16Vector" class #f 246 17 246 26 ("Sequence" "U16Vector-Class")
        {Lisp-Entry "initialize" method #f 249 11 249 21 ("native-class" "rest")}
        {Lisp-Entry "object-similar?" method #f 254 11 254 26 ("self" "cardinality" "zero?" "vector?" "and" "object")}
        {Lisp-Entry "sequence-element" method #f 260 11 260 27 ("self" "u16vector-ref" "n")}
        {Lisp-Entry "sequence-set-element!" method #f 264 11 264 32 ("self" "u16vector-set!" "obj" "n")}
        {Lisp-Entry "sequence-cardinality" method #f 268 11 268 31 ("self" "u16vector-length")}
        {Lisp-Entry "sequence-tail" method #f 272 11 272 24 ("self" "u16vector->list" "tail" "list->u16vector" "n")}
        {Lisp-Entry "sequence-last" method #f 276 11 276 24 ("1" "cardinality" "-" "self" "element")}
        {Lisp-Entry "sequence-butlast" method #f 280 11 280 27 ("self" "u16vector->list" "butlast" "list->u16vector")}}
      {Lisp-Entry "element" specialize #f 284 20 284 27 ("u16vector-ref" "n" "vector")}
      {Lisp-Entry "set-element!" specialize #f 288 20 288 32 ("u16vector-set!" "obj" "n" "vector")}
      {Lisp-Entry "cardinality" specialize #f 292 20 292 31 ("u16vector-length" "vector")}
      {Lisp-Entry "S32Vector-Class" class #f 301 7 301 22 ("Sequence-Class")
        {Lisp-Entry "allocate-sequence" method #f 304 11 304 28 ("make-s32vector" "len")}}
      {Lisp-Entry "S32Vector" class #f 308 17 308 26 ("Sequence" "S32Vector-Class")
        {Lisp-Entry "initialize" method #f 311 11 311 21 ("native-class" "rest")}
        {Lisp-Entry "object-similar?" method #f 316 11 316 26 ("self" "cardinality" "zero?" "vector?" "and" "object")}
        {Lisp-Entry "sequence-element" method #f 322 11 322 27 ("self" "s32vector-ref" "n")}
        {Lisp-Entry "sequence-set-element!" method #f 326 11 326 32 ("self" "s32vector-set!" "obj" "n")}
        {Lisp-Entry "sequence-cardinality" method #f 330 11 330 31 ("self" "s32vector-length")}
        {Lisp-Entry "sequence-tail" method #f 334 11 334 24 ("self" "s32vector->list" "tail" "list->s32vector" "n")}
        {Lisp-Entry "sequence-last" method #f 338 11 338 24 ("1" "cardinality" "-" "self" "element")}
        {Lisp-Entry "sequence-butlast" method #f 342 11 342 27 ("self" "s32vector->list" "butlast" "list->s32vector")}}
      {Lisp-Entry "element" specialize #f 346 20 346 27 ("s32vector-ref" "n" "vector")}
      {Lisp-Entry "set-element!" specialize #f 350 20 350 32 ("s32vector-set!" "obj" "n" "vector")}
      {Lisp-Entry "cardinality" specialize #f 354 20 354 31 ("s32vector-length" "vector")}
      {Lisp-Entry "U32Vector-Class" class #f 363 7 363 22 ("Sequence-Class")
        {Lisp-Entry "allocate-sequence" method #f 366 11 366 28 ("make-u32vector" "len")}}
      {Lisp-Entry "U32Vector" class #f 370 17 370 26 ("Sequence" "U32Vector-Class")
        {Lisp-Entry "initialize" method #f 373 11 373 21 ("native-class" "rest")}
        {Lisp-Entry "object-similar?" method #f 378 11 378 26 ("self" "cardinality" "zero?" "vector?" "and" "object")}
        {Lisp-Entry "sequence-element" method #f 384 11 384 27 ("self" "u32vector-ref" "n")}
        {Lisp-Entry "sequence-set-element!" method #f 388 11 388 32 ("self" "u32vector-set!" "obj" "n")}
        {Lisp-Entry "sequence-cardinality" method #f 392 11 392 31 ("self" "u32vector-length")}
        {Lisp-Entry "sequence-tail" method #f 396 11 396 24 ("self" "u32vector->list" "tail" "list->u32vector" "n")}
        {Lisp-Entry "sequence-last" method #f 400 11 400 24 ("1" "cardinality" "-" "self" "element")}
        {Lisp-Entry "sequence-butlast" method #f 404 11 404 27 ("self" "u32vector->list" "butlast" "list->u32vector")}}
      {Lisp-Entry "element" specialize #f 408 20 408 27 ("u32vector-ref" "n" "vector")}
      {Lisp-Entry "set-element!" specialize #f 412 20 412 32 ("u32vector-set!" "obj" "n" "vector")}
      {Lisp-Entry "cardinality" specialize #f 416 20 416 31 ("u32vector-length" "vector")}
      {Lisp-Entry "S64Vector-Class" class #f 425 7 425 22 ("Sequence-Class")
        {Lisp-Entry "allocate-sequence" method #f 428 11 428 28 ("make-s64vector" "len")}}
      {Lisp-Entry "S64Vector" class #f 432 17 432 26 ("Sequence" "S64Vector-Class")
        {Lisp-Entry "initialize" method #f 435 11 435 21 ("native-class" "rest")}
        {Lisp-Entry "object-similar?" method #f 440 11 440 26 ("self" "cardinality" "zero?" "vector?" "and" "object")}
        {Lisp-Entry "sequence-element" method #f 446 11 446 27 ("self" "s64vector-ref" "n")}
        {Lisp-Entry "sequence-set-element!" method #f 450 11 450 32 ("self" "s64vector-set!" "obj" "n")}
        {Lisp-Entry "sequence-cardinality" method #f 454 11 454 31 ("self" "s64vector-length")}
        {Lisp-Entry "sequence-tail" method #f 458 11 458 24 ("self" "s64vector->list" "tail" "list->s64vector" "n")}
        {Lisp-Entry "sequence-last" method #f 462 11 462 24 ("1" "cardinality" "-" "self" "element")}
        {Lisp-Entry "sequence-butlast" method #f 466 11 466 27 ("self" "s64vector->list" "butlast" "list->s64vector")}}
      {Lisp-Entry "element" specialize #f 470 20 470 27 ("s64vector-ref" "n" "vector")}
      {Lisp-Entry "set-element!" specialize #f 474 20 474 32 ("s64vector-set!" "obj" "n" "vector")}
      {Lisp-Entry "cardinality" specialize #f 478 20 478 31 ("s64vector-length" "vector")}
      {Lisp-Entry "U64Vector-Class" class #f 487 7 487 22 ("Sequence-Class")
        {Lisp-Entry "allocate-sequence" method #f 490 11 490 28 ("make-u64vector" "len")}}
      {Lisp-Entry "U64Vector" class #f 494 17 494 26 ("Sequence" "U64Vector-Class")
        {Lisp-Entry "initialize" method #f 497 11 497 21 ("native-class" "rest")}
        {Lisp-Entry "object-similar?" method #f 502 11 502 26 ("self" "cardinality" "zero?" "vector?" "and" "object")}
        {Lisp-Entry "sequence-element" method #f 508 11 508 27 ("self" "u64vector-ref" "n")}
        {Lisp-Entry "sequence-set-element!" method #f 512 11 512 32 ("self" "u64vector-set!" "obj" "n")}
        {Lisp-Entry "sequence-cardinality" method #f 516 11 516 31 ("self" "u64vector-length")}
        {Lisp-Entry "sequence-tail" method #f 520 11 520 24 ("self" "u64vector->list" "tail" "list->u64vector" "n")}
        {Lisp-Entry "sequence-last" method #f 524 11 524 24 ("1" "cardinality" "-" "self" "element")}
        {Lisp-Entry "sequence-butlast" method #f 528 11 528 27 ("self" "u64vector->list" "butlast" "list->u64vector")}}
      {Lisp-Entry "element" specialize #f 532 20 532 27 ("u64vector-ref" "n" "vector")}
      {Lisp-Entry "set-element!" specialize #f 536 20 536 32 ("u64vector-set!" "obj" "n" "vector")}
      {Lisp-Entry "cardinality" specialize #f 540 20 540 31 ("u64vector-length" "vector")}
      {Lisp-Entry "F32Vector-Class" class #f 549 7 549 22 ("Sequence-Class")
        {Lisp-Entry "allocate-sequence" method #f 552 11 552 28 ("make-f32vector" "len")}}
      {Lisp-Entry "F32Vector" class #f 556 17 556 26 ("Sequence" "F32Vector-Class")
        {Lisp-Entry "initialize" method #f 559 11 559 21 ("native-class" "rest")}
        {Lisp-Entry "object-similar?" method #f 564 11 564 26 ("self" "cardinality" "zero?" "vector?" "and" "object")}
        {Lisp-Entry "sequence-element" method #f 570 11 570 27 ("self" "f32vector-ref" "n")}
        {Lisp-Entry "sequence-set-element!" method #f 574 11 574 32 ("self" "f32vector-set!" "obj" "n")}
        {Lisp-Entry "sequence-cardinality" method #f 578 11 578 31 ("self" "f32vector-length")}
        {Lisp-Entry "sequence-tail" method #f 582 11 582 24 ("self" "f32vector->list" "tail" "list->f32vector" "n")}
        {Lisp-Entry "sequence-last" method #f 586 11 586 24 ("1" "cardinality" "-" "self" "element")}
        {Lisp-Entry "sequence-butlast" method #f 590 11 590 27 ("self" "f32vector->list" "butlast" "list->f32vector")}}
      {Lisp-Entry "element" specialize #f 594 20 594 27 ("f32vector-ref" "n" "vector")}
      {Lisp-Entry "set-element!" specialize #f 598 20 598 32 ("f32vector-set!" "obj" "n" "vector")}
      {Lisp-Entry "cardinality" specialize #f 602 20 602 31 ("f32vector-length" "vector")}
      {Lisp-Entry "F64Vector-Class" class #f 611 7 611 22 ("Sequence-Class")
        {Lisp-Entry "allocate-sequence" method #f 614 11 614 28 ("make-f64vector" "len")}}
      {Lisp-Entry "F64Vector" class #f 618 17 618 26 ("Sequence" "F64Vector-Class")
        {Lisp-Entry "initialize" method #f 621 11 621 21 ("native-class" "rest")}
        {Lisp-Entry "object-similar?" method #f 626 11 626 26 ("self" "cardinality" "zero?" "vector?" "and" "object")}
        {Lisp-Entry "sequence-element" method #f 632 11 632 27 ("self" "f64vector-ref" "n")}
        {Lisp-Entry "sequence-set-element!" method #f 636 11 636 32 ("self" "f64vector-set!" "obj" "n")}
        {Lisp-Entry "sequence-cardinality" method #f 640 11 640 31 ("self" "f64vector-length")}
        {Lisp-Entry "sequence-tail" method #f 644 11 644 24 ("self" "f64vector->list" "tail" "list->f64vector" "n")}
        {Lisp-Entry "sequence-last" method #f 648 11 648 24 ("1" "cardinality" "-" "self" "element")}
        {Lisp-Entry "sequence-butlast" method #f 652 11 652 27 ("self" "f64vector->list" "butlast" "list->f64vector")}}
      {Lisp-Entry "element" specialize #f 656 20 656 27 ("f64vector-ref" "n" "vector")}
      {Lisp-Entry "set-element!" specialize #f 660 20 660 32 ("f64vector-set!" "obj" "n" "vector")}
      {Lisp-Entry "cardinality" specialize #f 664 20 664 31 ("f64vector-length" "vector")}}})
"increase"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "dialect" "syntax" "increase.scm"} 1252768922
    {Lisp-Entry "jazz.dialect.syntax.increase" library #f 37 19 37 47 ("scheme")
      {Lisp-Entry "increase!" macro #f 46 16 46 25 (",increment" "+" ",location" "set!" "car" "1" "null?" "if" "increment" "cddr" "rest" "source-code" "cadr" "location" "let" "form-src")}
      {Lisp-Entry "decrease!" macro #f 56 16 56 25 (",increment" "-" ",location" "set!" "car" "1" "null?" "if" "increment" "cddr" "rest" "source-code" "cadr" "location" "let" "form-src")}}})
"install"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "install.scm"} 1249913822
    {Lisp-Entry "jazz.install" module #f 37 8 37 20 ("jazz.jazz-readtable" "'jazz.jazz-readtable" "jazz.global-value" "jazz.dialect" "'jazz.dialect" "core.library" "'core.library" "jazz.load-module" "lambda" "jazz.register-reader-extension")
      {Lisp-Entry "Point" define #f 45 21 45 26 ("jazz.literals.construct-point")}
      {Lisp-Entry "Dimension" define #f 46 21 46 30 ("jazz.literals.construct-dimension")}
      {Lisp-Entry "Cell" define #f 47 21 47 25 ("jazz.literals.construct-cell")}
      {Lisp-Entry "Rect" define #f 48 21 48 25 ("jazz.literals.construct-rect")}
      {Lisp-Entry "Range" define #f 49 21 49 26 ("jazz.literals.construct-range")}
      {Lisp-Entry "Exception-Detail" define #f 50 21 50 37 ("jazz.literals.construct-exception-detail")}
      {Lisp-Entry "Walk-Location" define #f 51 21 51 34 ("jazz.literals.construct-walk-location")}}})
"jazz"
 ({Lisp-File-Entry {File jazz "src" "jazz" "dialect" "walker" "jazz.jazz"} 1252768922
    {Lisp-Entry "jazz.dialect.walker.jazz" library #f 37 19 37 43 ("jazz.dialect")
      {Lisp-Entry "Definition-Declaration" class #f 49 7 49 29 ("Declaration")
        {Lisp-Entry "expansion" slot #f 52 8 52 17 ()}
        {Lisp-Entry "get-expansion" accessor #f 52 25 52 33 ()}
        {Lisp-Entry "signature" slot #f 53 8 53 17 ()}
        {Lisp-Entry "get-signature" accessor #f 53 25 53 33 ()}
        {Lisp-Entry "value" slot #f 54 8 54 13 ()}
        {Lisp-Entry "get-value" accessor #f 54 25 54 33 ()}}
      {Lisp-Entry "Specialize" class #f 62 7 62 17 ("Expression")}
      {Lisp-Entry "Generic-Declaration" class #f 70 7 70 26 ("Declaration")
        {Lisp-Entry "dispatch-types" slot #f 73 8 73 22 ()}
        {Lisp-Entry "get-dispatch-types" accessor #f 73 30 73 38 ()}
        {Lisp-Entry "signature" slot #f 74 8 74 17 ()}
        {Lisp-Entry "get-signature" accessor #f 74 30 74 38 ()}
        {Lisp-Entry "body" slot #f 75 8 75 12 ()}
        {Lisp-Entry "get-body" accessor #f 75 30 75 38 ()}}
      {Lisp-Entry "Specific-Declaration" class #f 83 7 83 27 ("Declaration")
        {Lisp-Entry "generic" slot #f 86 8 86 15 ()}
        {Lisp-Entry "get-generic" accessor #f 86 25 86 33 ()}
        {Lisp-Entry "signature" slot #f 87 8 87 17 ()}
        {Lisp-Entry "get-signature" accessor #f 87 25 87 33 ()}
        {Lisp-Entry "body" slot #f 88 8 88 12 ()}
        {Lisp-Entry "get-body" accessor #f 88 25 88 33 ()}
        {Lisp-Entry "root?" slot #f 89 8 89 13 ()}
        {Lisp-Entry "get-root?" accessor #f 89 25 89 33 ()}}
      {Lisp-Entry "Category-Declaration" class #f 97 7 97 27 ("Namespace-Declaration")
        {Lisp-Entry "implementor" slot #f 100 8 100 19 ()}
        {Lisp-Entry "get-implementor" accessor #f 100 27 100 35 ()}
        {Lisp-Entry "metaclass" slot #f 101 8 101 17 ()}
        {Lisp-Entry "get-metaclass" accessor #f 101 27 101 35 ()}}
      {Lisp-Entry "Class-Declaration" class #f 109 7 109 24 ("Category-Declaration")
        {Lisp-Entry "ascendant" slot #f 112 8 112 17 ()}
        {Lisp-Entry "get-ascendant" accessor #f 112 34 112 42 ()}
        {Lisp-Entry "ascendant-relation" slot #f 113 8 113 26 ()}
        {Lisp-Entry "get-ascendant-relation" accessor #f 113 34 113 42 ()}
        {Lisp-Entry "ascendant-base" slot #f 114 8 114 22 ()}
        {Lisp-Entry "get-ascendant-base" accessor #f 114 34 114 42 ()}
        {Lisp-Entry "interfaces" slot #f 115 8 115 18 ()}
        {Lisp-Entry "get-interfaces" accessor #f 115 34 115 42 ()}}
      {Lisp-Entry "Interface-Declaration" class #f 123 7 123 28 ("Category-Declaration")
        {Lisp-Entry "ascendants" slot #f 126 8 126 18 ()}
        {Lisp-Entry "get-ascendants" accessor #f 126 26 126 34 ()}}
      {Lisp-Entry "Field-Declaration" class #f 134 7 134 24 ("Declaration")}
      {Lisp-Entry "Slot-Declaration" class #f 142 7 142 23 ("Field-Declaration")
        {Lisp-Entry "initialize" slot #f 145 8 145 18 ()}
        {Lisp-Entry "get-initialize" accessor #f 145 27 145 35 ()}
        {Lisp-Entry "getter-name" slot #f 146 8 146 19 ()}
        {Lisp-Entry "get-getter-name" accessor #f 146 27 146 35 ()}
        {Lisp-Entry "setter-name" slot #f 147 8 147 19 ()}
        {Lisp-Entry "get-setter-name" accessor #f 147 27 147 35 ()}}
      {Lisp-Entry "Property-Declaration" class #f 155 7 155 27 ("Slot-Declaration")
        {Lisp-Entry "getter" slot #f 158 8 158 14 ()}
        {Lisp-Entry "get-getter" accessor #f 158 22 158 30 ()}
        {Lisp-Entry "setter" slot #f 159 8 159 14 ()}
        {Lisp-Entry "get-setter" accessor #f 159 22 159 30 ()}}
      {Lisp-Entry "Method-Declaration" class #f 167 7 167 25 ("Field-Declaration")
        {Lisp-Entry "root" slot #f 170 8 170 12 ()}
        {Lisp-Entry "get-root" accessor #f 170 28 170 36 ()}
        {Lisp-Entry "propagation" slot #f 171 8 171 19 ()}
        {Lisp-Entry "get-propagation" accessor #f 171 28 171 36 ()}
        {Lisp-Entry "abstraction" slot #f 172 8 172 19 ()}
        {Lisp-Entry "get-abstraction" accessor #f 172 28 172 36 ()}
        {Lisp-Entry "expansion" slot #f 173 8 173 17 ()}
        {Lisp-Entry "get-expansion" accessor #f 173 28 173 36 ()}
        {Lisp-Entry "remote" slot #f 174 8 174 14 ()}
        {Lisp-Entry "get-remote" accessor #f 174 28 174 36 ()}
        {Lisp-Entry "synchronized" slot #f 175 8 175 20 ()}
        {Lisp-Entry "get-synchronized" accessor #f 175 28 175 36 ()}
        {Lisp-Entry "signature" slot #f 176 8 176 17 ()}
        {Lisp-Entry "get-signature" accessor #f 176 28 176 36 ()}
        {Lisp-Entry "body" slot #f 177 8 177 12 ()}
        {Lisp-Entry "get-body" accessor #f 177 28 177 36 ()}}
      {Lisp-Entry "With-Self" class #f 185 7 185 16 ("Expression")
        {Lisp-Entry "body" slot #f 188 8 188 12 ()}
        {Lisp-Entry "get-body" accessor #f 188 20 188 28 ()}}
      {Lisp-Entry "With-Dynamic-Self" class #f 196 7 196 24 ("Expression")
        {Lisp-Entry "code" slot #f 199 8 199 12 ()}
        {Lisp-Entry "get-code" accessor #f 199 20 199 28 ()}
        {Lisp-Entry "body" slot #f 200 8 200 12 ()}
        {Lisp-Entry "get-body" accessor #f 200 20 200 28 ()}}
      {Lisp-Entry "Cast" class #f 208 7 208 11 ("Expression")
        {Lisp-Entry "expression" slot #f 211 8 211 18 ()}
        {Lisp-Entry "get-expression" accessor #f 211 26 211 34 ()}}
      {Lisp-Entry "Construct" class #f 219 7 219 16 ("Expression")
        {Lisp-Entry "class" slot #f 222 8 222 13 ()}
        {Lisp-Entry "get-class" accessor #f 222 22 222 30 ()}
        {Lisp-Entry "values" slot #f 223 8 223 14 ()}
        {Lisp-Entry "get-values" accessor #f 223 22 223 30 ()}}
      {Lisp-Entry "Dispatch" class #f 231 7 231 15 ("Expression")
        {Lisp-Entry "name" slot #f 234 8 234 12 ()}
        {Lisp-Entry "get-name" accessor #f 234 25 234 33 ()}
        {Lisp-Entry "arguments" slot #f 235 8 235 17 ()}
        {Lisp-Entry "get-arguments" accessor #f 235 25 235 33 ()}}
      {Lisp-Entry "Jazz-Dialect" class #f 243 7 243 19 ("Dialect")}
      {Lisp-Entry "Jazz-Walker" class #f 251 7 251 18 ("Scheme-Walker")}}})
"list"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "dialect" "core" "list.scm"} 1238328026
    {Lisp-Entry "jazz.dialect.core.list" module #f 37 18 37 40 ()
      {Lisp-Entry "jazz.proper-list" define #f 40 9 40 25 ("jazz.queue-list" "%%cdr" "set!" "%%car" "jazz.enqueue" "%%pair?" "%%while" "jazz.new-queue" "proper" "let" "lst")}}})
"literals"
 ({Lisp-File-Entry {File jazz "src" "jazz" "literals.jazz"} 1249913822
    {Lisp-Entry "jazz.literals" library #f 37 9 37 22 ("jazz")
      {Lisp-Entry "construct-point" definition #f 45 21 45 36 ("Point" "new" "v" "h")}
      {Lisp-Entry "construct-dimension" definition #f 49 21 49 40 ("Dimension" "new" "height" "width")}
      {Lisp-Entry "construct-cell" definition #f 53 21 53 35 ("Cell" "new" "col" "row")}
      {Lisp-Entry "construct-rect" definition #f 57 21 57 35 ("Rect" "new" "bottom" "right" "top" "left")}
      {Lisp-Entry "construct-range" definition #f 61 21 61 36 ("Range" "new" "end" "start")}
      {Lisp-Entry "construct-exception-detail" definition #f 70 21 70 47 ("Exception-Detail" "new" "children" "location" "title" "icon")}
      {Lisp-Entry "construct-walk-location" definition #f 79 21 79 44 ("Walk-Location" "new" "locat" "declaration-locator" "module-locator")}}})
"loop"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "dialect" "syntax" "loop.scm"} 1252768922
    {Lisp-Entry "jazz.dialect.syntax.loop" library #f 37 19 37 43 ("scheme")
      {Lisp-Entry "private" native #f 47 8 47 15 ("jazz.->string")}
      {Lisp-Entry "private" native #f 48 8 48 15 ("jazz.error")}
      {Lisp-Entry "loop" macro #f 135 16 135 20 ("expand-loop" "sourcify-if" "source-code" "cdr" "clauses" "let" "form-src")}
      {Lisp-Entry "noobject" define #f 142 8 142 16 ("noobject" "'noobject" "list")}
      {Lisp-Entry "expand-loop" define #f 146 9 146 20 ("set-cdr!" "'set-cdr!" "'begin" "jazz.null?" "'jazz.null?" "'cons" "'<list+>" "'<list>" "cns" "ptr" ",@unless-actions" "unless-actions" ",@when-actions" ",test" "when-actions" "body" "'when" "res" "what" ">" "'>" "rpt" "count" "specifier?" "then" "then-key" "first" "symbol?" "end" "decrease!" "'decrease!" ">=" "'>=" "downto" "below" "cddr" "<=" "'<=" "cadr" "scan" "by" "'increase!" "update" "to" "from" "in-properties" "get-next" "'get-next" "done?" "'done?" "iterate-sequence" "'iterate-sequence" "Iterator" "'Iterator" "is?" "'is?" "'if" "'<Iterator>" "itr" "val" "iterator" "in-sequence" "1" "+" "'+" "element" "'element" "<" "'<" "length" "'length" "'<fx>" "'<vector>" "len" "vec" "vector" "in-vector" "error" "remainder" "keyword" "'cdr" "'car" "'set!" "'null?" "either" "'<Object>" "in" "parse-for" "receive" "lst" "set-finally" "expr" "add-epilogue" "after" "add-after" "enqueue-list" "action-list" "add-actions" "action" "before" "add-before" "test" "add-test" "exit-safe" "values" "'not" "add-initial-test" "'<bool>" "'<Object+>" "ext" "ret" "get-return/exit" "add-with" "append" "list" "binding" "null?" "value" "type" "variable" "add-binding" "cons" "Unbound" "increase!" "->string" "string-append" "string->symbol" "symbol" "prefix" "unique" ",@finally" "begin" ",return" ",exit" "eq?" ",@epilogue" ",@afters" ",@actions" ",withs" ",@befores" ",@tests" "and" ",bindings" "let*" "queue-list" "cdr" "else" "process-finally" "process-return" "process-collect" "collect" "process-sum" "sum" "process-do" "do" "process-unless" "unless" "process-when" "when" "process-every" "every" "process-some" "some" "process-repeat" "repeat" "process-for" "for" "process-with" "with" "case" "rest" "key" "bind" "add-action" "source-code" "pair?" "not" "if" "car" "clause" "not-null?" "while" "new-queue" "expand-loop" "process-clauses" "set!" "expand" "define" "0" "unique-rank" "finally" "epilogue" "afters" "actions" "befores" "withs" "tests" "exit" "noobject" "return" "bindings" "let" "clauses")}}})
"macros"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "dialect" "syntax" "macros.scm"} 1252768922
    {Lisp-Entry "jazz.dialect.syntax.macros" library #f 37 19 37 45 ("scheme")
      {Lisp-Entry "private" native #f 43 8 43 15 ("jazz.->string")}
      {Lisp-Entry "private" native #f 44 8 44 15 ("jazz.error")}
      {Lisp-Entry "constant" macro #f 47 16 47 24 (",value" ",name" "public" "definition" "sourcify-if" "caddr" "value" "source-code" "cadr" "name" "let" "form-src")}
      {Lisp-Entry "enumeration" macro #f 55 16 55 27 (",@definitions" "begin" "public" "definition" "declaration" "lambda" "map" "definitions" "sourcify-if" "cddr" "declarations" "source-code" "cadr" "name" "let" "form-src")}
      {Lisp-Entry "when" macro #f 64 16 64 20 ("unspecified" "'unspecified" "list" "null?" "begin" ",test" "if" "sourcify-if" "cddr" "body" "source-code" "cadr" "test" "let" "form-src")}
      {Lisp-Entry "unless" macro #f 77 16 77 22 (",@body" "begin" ",test" "not" "if" "sourcify-if" "cddr" "body" "source-code" "cadr" "test" "let" "form-src")}
      {Lisp-Entry "prog1" macro #f 87 16 87 21 (",@body" "begin" ",returned" ",value" "sourcify-if" "generate-symbol" "value" "cddr" "body" "source-code" "cadr" "returned" "let" "form-src")}
      {Lisp-Entry "while" macro #f 98 16 98 21 (",@body" "begin" ",test" "if" ",iter" "sourcify-if" "generate-symbol" "iter" "cddr" "body" "source-code" "cadr" "test" "let" "form-src")}
      {Lisp-Entry "unwind-protect" macro #f 111 16 111 30 (",@protection" ",body" "function" "dynamic-wind" "sourcify-if" "cddr" "protection" "source-code" "cadr" "body" "let" "form-src")}
      {Lisp-Entry "catch" macro #f 124 16 124 21 ("desourcify" "error" "else" "car" "pair?" ",@body" "exc" "lambda" ",predicate/type" "call-with-catch" "symbol?" "cond" "sourcify-if" "cddr" "body" "source-code" "cadr" "predicate/type" "let" "form-src")}
      {Lisp-Entry "~" macro #f 141 16 141 17 (",name" "',name" ",obj" "dispatch" "apply" "rest" "obj" "lambda" "with-uniqueness" "sourcify-if" "cddr" "car" "object" "cadr" "source-code" "name" "let" "form-src")}
      {Lisp-Entry "form>>" macro #f 152 15 152 21 (",form" "',form" "jml->form" "form")}
      {Lisp-Entry "expand-push!" define #f 158 9 158 21 ("cons" "'cons" "set!" "'set!" "list" "value" "location")}
      {Lisp-Entry "expand-pop!" define #f 164 9 164 20 ("cdr" "'cdr" "set!" "'set!" "list" "location")}
      {Lisp-Entry "expand-assert" define #f 168 9 168 22 ("proc" "car" "error" "'error" "unless" "'unless" "list" ":text" "->string" "string-append" "message" "expr" "let*" "null?" "if" "rest" "first")}
      {Lisp-Entry "expand-assert-type" define #f 179 9 179 27 ("type-name" "'type-name" "error" "'error" "is-not?" "'is-not?" "when" "'when" "list" "let*" "'let*" "cons" "generate-symbol" "value" "let" "type" "expr")}
      {Lisp-Entry "expand-error?" define #f 187 9 187 22 ("begin" "'begin" "cons" "Error" "'Error" "catch" "'catch" "list" "generate-symbol" "err" "let" "body")}
      {Lisp-Entry "c-constant" macro #f 200 16 200 26 (",value" ",name" "public" "definition" "sourcify-if" "caddr" "value" "source-code" "cadr" "name" "let" "form-src")}
      {Lisp-Entry "c-enumeration" macro #f 208 16 208 29 (",@definitions" "begin" "public" "definition" "declaration" "lambda" "map" "definitions" "sourcify-if" "cddr" "declarations" "source-code" "cadr" "name" "let" "form-src")}}})
"memory"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "dialect" "core" "memory.scm"} 1252923643
    {Lisp-Entry "jazz.dialect.core.memory" module #f 37 18 37 42 ()
      {Lisp-Entry "jazz.gc" define #f 40 9 40 16 ("%%gc")}
      {Lisp-Entry "jazz.process-memory" define #f 49 9 49 28 ("inexact->exact" "values" "19" "nonmovable" "18" "movable" "17" "live" "16" "alloc" "15" "f64vector-ref" "heap" "##process-statistics" "vec" "let")}
      {Lisp-Entry "jazz.symbols-memory" define #f 62 9 62 28 ("values" "##symbol-table" "%%vector->list" "%%reverse" "%%cons" "2" "%%vector-ref" "%%symbol?" "if" "loop" "map" "%%symbol->string" "%%string-length" "s" "%%length" "%%fx+" "set!" "lst" "lambda" "for-each" "chars" "0" "count" "let")}
      {Lisp-Entry "jazz.classes-statistics" define #f 84 9 84 32 ("values" "jazz.Object" "method" "slot" "for-each" "process-method" "jazz.Method" "process-slot" "jazz.Slot" "jazz.is?" "cond" "field" "name" "lambda" "%%iterate-table" "%%get-class-interface-table" "%%get-class-class-table" "jazz.vector-vector-size" "%%get-class-core-vtable" "%%get-class-instance-slots" "%%get-class-interfaces" "%%get-category-descendants" "jazz.list-size" "%%get-category-ancestors" "%%get-category-fields" "jazz.table-size" "jazz.vector-size" "fx+" "1" "%%fx+" "set!" "class" "process-class" "define" "sz-methods" "nb-methods" "sz-slots" "nb-slots" "sz-interfaces" "nb-interfaces" "sz-classes" "0" "nb-classes" "let")}
      {Lisp-Entry "jazz.class-instances-count" define #f 128 9 128 35 ("%%get-category-descendants" "for-each" "%%get-category-name" "jazz.instances-statistics" "%%table-ref" "%%fx+" "set!" "iter" "0" "count" "let" "class")}
      {Lisp-Entry "jazz.class-instances-size" define #f 136 9 136 34 ("%%get-category-descendants" "for-each" "%%get-class-instance-size" "%%get-category-name" "jazz.instances-statistics" "%%table-ref" "%%fx*" "%%fx+" "set!" "iter" "0" "size" "let" "class")}
      {Lisp-Entry "jazz.word-bytes" define #f 150 8 150 23 ("4")}
      {Lisp-Entry "jazz.f64-bytes" define #f 151 8 151 22 ("8")}
      {Lisp-Entry "jazz.pair-bytes" define #f 152 8 152 23 ("12")}
      {Lisp-Entry "jazz.table-bytes" define #f 153 8 153 24 ("32")}
      {Lisp-Entry "jazz.vector-size" define #f 156 9 156 25 ("%%vector-length" "%%fx*" "jazz.word-bytes" "%%fx+" "v")}
      {Lisp-Entry "jazz.safe-vector-size" define #f 159 9 159 30 ("0" "jazz.vector-size" "%%vector?" "if" "v")}
      {Lisp-Entry "jazz.f64vector-size" define #f 164 9 164 28 ("f64vector-length" "jazz.f64-bytes" "%%fx*" "jazz.word-bytes" "%%fx+" "v")}
      {Lisp-Entry "jazz.vector-vector-size" define #f 167 9 167 32 ("1" "%%vector-ref" "%%vector-length" "%%fx<" "size" "n" "iter" "let" "jazz.vector-size" "%%fx+" "0" "%%not" "if" "v")}
      {Lisp-Entry "jazz.list-size" define #f 177 9 177 23 ("%%length" "jazz.pair-bytes" "%%fx*" "l")}
      {Lisp-Entry "jazz.table-size" define #f 180 9 180 24 ("0" "%%fx+" "##gc-hash-table?" "if" "%%vector-length" "1" "fx+" "jazz.word-bytes" "%%fx*" "4" "floats" "5" "gcht2" "3" "%%vector-ref" "gcht1" "let" "t")}}})
"network"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "dialect" "core" "network.scm"} 1238328026
    {Lisp-Entry "jazz.dialect.core.network" module #f 37 18 37 43 ()
      {Lisp-Entry "jazz.open-tcp-client" define #f 42 12 42 32 ("open-tcp-client")}
      {Lisp-Entry "jazz.open-tcp-server" define #f 43 12 43 32 ("open-tcp-server")}
      {Lisp-Entry "jazz.tcp-server-socket-info" define #f 44 12 44 39 ("tcp-server-socket-info")}
      {Lisp-Entry "jazz.call-with-tcp-client" define #f 46 13 46 38 ("close-port" "if" "open-tcp-client" "set!" "lambda" "dynamic-wind" "port" "let" "proc" "settings")}
      {Lisp-Entry "jazz.socket-info-address" define #f 57 12 57 36 ("socket-info-address")}
      {Lisp-Entry "jazz.socket-info-port-number" define #f 58 12 58 40 ("socket-info-port-number")}}})
"number"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "dialect" "core" "number.scm"} 1238328026
    {Lisp-Entry "jazz.dialect.core.number" module #f 37 18 37 42 ()
      {Lisp-Entry "jazz.fixnum->flonum" define #f 47 9 47 28 ("jazz.Fixnum" "jazz.type-error" "##fixnum->flonum" "%%fixnum?" "if" "n")}
      {Lisp-Entry "jazz.flonum->fixnum" define #f 52 9 52 28 ("jazz.Flonum" "jazz.type-error" "##flonum->fixnum" "%%flonum?" "if" "n")}
      {Lisp-Entry "jazz.+infinity" define #f 63 8 63 22 ("+inf.0")}
      {Lisp-Entry "jazz.-infinity" define #f 66 8 66 22 ("-inf.0")}
      {Lisp-Entry "jazz.random-integer" define #f 77 12 77 31 ("random-integer")}
      {Lisp-Entry "jazz.random-real" define #f 78 12 78 28 ("random-real")}
      {Lisp-Entry "jazz.random-source-randomize!" define #f 79 12 79 41 ("random-source-randomize!")}
      {Lisp-Entry "jazz.random-source-pseudo-randomize!" define #f 80 12 80 48 ("random-source-pseudo-randomize!")}
      {Lisp-Entry "jazz.default-random-source" define #f 81 12 81 38 ("default-random-source")}}})
"object"
 ({Lisp-File-Entry {File jazz "src" "jazz" "dialect" "language" "object.jazz"} 1250272407
    {Lisp-Entry "jazz.dialect.language.object" library #f 37 19 37 47 ("jazz.dialect")
      {Lisp-Entry "private" native #f 46 8 46 15 ("jazz.error")}
      {Lisp-Entry "Object" class #f 54 17 54 23 ("Object-Class")
        {Lisp-Entry "initialize" method #f 57 19 57 29 ()}
        {Lisp-Entry "destroy" method #f 61 19 61 26 ()}
        {Lisp-Entry "print" method #f 65 26 65 31 ("print-detail" "function" "print-unreadable" "self" "object?" "if" "detail" "output")}
        {Lisp-Entry "print-detail" method #f 74 21 74 33 ("write" "self" "display" ":human" "eq?" "if" "detail" "output")}
        {Lisp-Entry "class-actions" method #f 80 26 80 39 ()}
        {Lisp-Entry "focus-actions" method #f 84 26 84 39 ()}
        {Lisp-Entry "guest-actions" method #f 88 26 88 39 ()}
        {Lisp-Entry "initialized?" method #f 92 18 92 30 ("self" "object-initialized?")}
        {Lisp-Entry "hash-object" method #f 96 26 96 37 ("self" "error")}
        {Lisp-Entry "copy-object" method #f 100 29 100 40 ("self" "error" "deep?")}
        {Lisp-Entry "compare-object" method #f 104 29 104 43 (":incompatible" "object")}
        {Lisp-Entry "ci-compare-object" method #f 108 29 108 46 (":incompatible" "object")}
        {Lisp-Entry "describe-object" method #f 112 29 112 44 ("print" "printer")}
        {Lisp-Entry "release" method #f 116 26 116 33 ()}
        {Lisp-Entry "close" method #f 120 26 120 31 ("self" "call-destroy")}
        {Lisp-Entry "destroy-mandatory" method #f 124 21 124 38 ("self" "set-must-destroy")}
        {Lisp-Entry "destroyed?" method #f 128 18 128 28 ("self" "object-destroyed?")}
        {Lisp-Entry "get-sort-value" method #f 132 26 132 40 ()}
        {Lisp-Entry "redirect-handler" method #f 136 29 136 45 ("self" "sender" "handler")}
        {Lisp-Entry "coerce-string" method #f 140 29 140 42 ("self" "error")}
        {Lisp-Entry "iterate-object" method #f 144 29 144 43 ("self" "error")}
        {Lisp-Entry "object-similar?" method #f 153 29 153 44 ("self" "eq?" "object")}
        {Lisp-Entry "object-alphabetic?" method #f 157 29 157 47 ("self" "error")}
        {Lisp-Entry "object-numeric?" method #f 161 29 161 44 ("self" "error")}
        {Lisp-Entry "object-alphanumeric?" method #f 165 29 165 49 ("self" "error")}
        {Lisp-Entry "object-whitespace?" method #f 169 29 169 47 ("self" "error")}
        {Lisp-Entry "object-upper-case?" method #f 173 29 173 47 ("self" "error")}
        {Lisp-Entry "object-lower-case?" method #f 177 29 177 47 ("self" "error")}
        {Lisp-Entry "object-upcase" method #f 181 29 181 42 ("self" "error")}
        {Lisp-Entry "object-downcase" method #f 185 29 185 44 ("self" "error")}
        {Lisp-Entry "object-capitalize" method #f 189 29 189 46 ("self" "error")}}
      {Lisp-Entry "compare" definition #f 193 27 193 34 ("compare-object" ":equal" "eqv?" "if" "b" "a")}
      {Lisp-Entry "ci-compare" definition #f 199 27 199 37 ("ci-compare-object" ":equal" "eqv?" "if" "b" "a")}
      {Lisp-Entry "copy" definition #f 205 20 205 24 ("subcopy" "obj")}
      {Lisp-Entry "subcopy" definition #f 209 20 209 27 ("copy-object" "deep?" "obj")}
      {Lisp-Entry "print-unreadable" definition #f 213 20 213 36 ("string=?" "unless" "display" "object->serial" "serial" "get-output-string" "open-output-string" "string" "class-of" "get-name" "identifier-name" "class-name" "let" "proc" "output" "object")}
      {Lisp-Entry "native-class" definition #f 229 21 229 33 ("error" "name")}
      {Lisp-Entry "=-hash" definition #f 233 13 233 19 ("hash-object" "obj")}
      {Lisp-Entry "object-initialized?" definition #f 237 13 237 32 ("obj")}
      {Lisp-Entry "get-must-destroy" definition #f 242 13 242 29 ("obj")}
      {Lisp-Entry "set-must-destroy" definition #f 246 13 246 29 ("obj")}
      {Lisp-Entry "set-was-destroyed" definition #f 251 13 251 30 ("obj")}
      {Lisp-Entry "object-destroyed?" definition #f 256 21 256 38 ("obj")}
      {Lisp-Entry "destroy-mandatory" definition #f 261 21 261 38 ()}
      {Lisp-Entry "call-destroy" definition #f 266 21 266 33 ("set-was-destroyed" "destroy" "obj")}}})
"parse"
 ({Lisp-File-Entry {File jazz "src" "jazz" "dialect" "language" "parse.jazz"} 1248708411
    {Lisp-Entry "jazz.dialect.language.parse" library #f 37 19 37 46 ("jazz.dialect")
      {Lisp-Entry "parse-integer" definition #f 49 20 49 33 ("type:" "object:" "Convertion-Error" "new" "signal" "read-string-element" "numeric?" "empty-string?" "not" "and" "if" "string")}
      {Lisp-Entry "parse-hexadecimal" definition #f 55 20 55 37 ("format" "read-string-element" "string")}
      {Lisp-Entry "parse-boolean" definition #f 59 20 59 33 ("type:" "object:" "Convertion-Error" "new" "signal" "else" "ci=?" "or" "not" "cond" "string")}
      {Lisp-Entry "parse-strings" definition #f 66 20 66 33 ("split" "trim-spaces" "function" "map" "string=?" "empty-string?" "or" "if" "separator" "separator:" "string")}
      {Lisp-Entry "parse-delimited-string" definition #f 74 20 74 42 ("parse-strings" "function" "map" "separator" "separator:" "string")}}})
"pathname"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "dialect" "core" "pathname.scm"} 1238328026
    {Lisp-Entry "jazz.dialect.core.pathname" module #f 37 18 37 44 ()
      {Lisp-Entry "jazz.pathname-expand" define #f 42 12 42 32 ("path-expand")}
      {Lisp-Entry "jazz.file-rename" define #f 43 12 43 28 ("rename-file")}
      {Lisp-Entry "jazz.directory-delete" define #f 44 12 44 33 ("delete-directory")}
      {Lisp-Entry "jazz.current-directory" define #f 46 13 46 35 ("jazz.pathname-exists?" "if" "jazz.pathname-normalize" "current-directory" "dir" "let")}
      {Lisp-Entry "jazz.current-directory-set!" define #f 53 13 53 40 ("current-directory" "dir")}
      {Lisp-Entry "jazz.with-current-directory" define #f 56 13 56 40 ("current-directory" "parameterize" "thunk" "dir")}}})
"port"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "dialect" "core" "port.scm"} 1248214776
    {Lisp-Entry "jazz.dialect.core.port" module #f 37 18 37 40 ("jazz.dialect.language.debug.get-console-port" "set!")
      {Lisp-Entry "jazz.system-format" define #f 45 8 45 26 ("jazz.format")}
      {Lisp-Entry "jazz.close-port" define #f 56 12 56 27 ("close-port")}
      {Lisp-Entry "jazz.input-port-timeout-set!" define #f 57 12 57 40 ("input-port-timeout-set!")}
      {Lisp-Entry "jazz.output-port-timeout-set!" define #f 58 12 58 41 ("output-port-timeout-set!")}
      {Lisp-Entry "jazz.dialect.language.debug.get-console-port" define #f 68 8 68 52 ()}
      {Lisp-Entry "jazz.get-console-port" define #f 74 9 74 30 ("jazz.dialect.language.debug.get-console-port" "if")}}})
"profile"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "dialect" "core" "profile.scm"} 1248276859
    {Lisp-Entry "jazz.dialect.core.profile" module #f 37 18 37 43 ()
      {Lisp-Entry "active-profile" define-macro #f 40 22 40 36 ()}
      {Lisp-Entry "profile-total" define-macro #f 41 22 41 35 ()}
      {Lisp-Entry "profile-unknown" define-macro #f 42 22 42 37 ()}
      {Lisp-Entry "profile-calls" define-macro #f 43 22 43 35 ()}
      {Lisp-Entry "profile-new" define-macro #f 44 22 44 33 ()}
      {Lisp-Entry "profile-reset!" define-macro #f 45 22 45 36 ()}
      {Lisp-Entry "profile-start!" define-macro #f 46 22 46 36 ()}
      {Lisp-Entry "profile-stop!" define-macro #f 47 22 47 35 ()}
      {Lisp-Entry "profile-running?" define-macro #f 48 22 48 38 ()}
      {Lisp-Entry "jazz.statprof-loaded?" define #f 56 8 56 29 ()}
      {Lisp-Entry "jazz.load-statprof" define #f 60 9 60 27 ("set!" "statprof" "'statprof" "jazz.load-module" "begin" "jazz.statprof-loaded?" "%%not" "if")}
      {Lisp-Entry "jazz.active-profile" define #f 67 9 67 28 ("active-profile" "jazz.load-statprof")}
      {Lisp-Entry "jazz.profile-total" define #f 72 9 72 27 ("profile-total" "jazz.load-statprof" "profile")}
      {Lisp-Entry "jazz.profile-unknown" define #f 77 9 77 29 ("profile-unknown" "jazz.load-statprof" "profile")}
      {Lisp-Entry "jazz.profile-calls" define #f 82 9 82 27 ("profile-calls" "jazz.load-statprof" "profile")}
      {Lisp-Entry "jazz.new-profile" define #f 87 9 87 25 ("profile-new" "%%apply" "jazz.load-statprof" "rest")}
      {Lisp-Entry "jazz.reset-profile" define #f 92 9 92 27 ("profile-reset!" "jazz.load-statprof")}
      {Lisp-Entry "jazz.start-profile" define #f 97 9 97 27 ("profile-start!" "jazz.load-statprof")}
      {Lisp-Entry "jazz.stop-profile" define #f 102 9 102 26 ("profile-stop!" "jazz.load-statprof")}
      {Lisp-Entry "jazz.profile-running?" define #f 107 9 107 30 ("profile-running?" "jazz.load-statprof")}}})
"reader"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "dialect" "core" "reader.scm"} 1252768922
    {Lisp-Entry "jazz.dialect.core.reader" module #f 37 18 37 42 ()
      {Lisp-Entry "jazz.make-jazz-readtable" define #f 47 13 47 37 ("jazz.jazzify-readtable!" "##main-readtable" "%%readtable-copy" "readtable-max-unescaped-char-set" "readtable" "let")}
      {Lisp-Entry "jazz.jazzify-readtable!" define #f 53 13 53 36 ("jazz.read-delimited-string" "%%readtable-char-sharp-handler-set!" "jazz.read-comment" "jazz.read-literal" "%%readtable-char-class-set!" "jazz.named-chars" "jazz.readtable-named-char-table" "%%append" "jazz.readtable-named-char-table-set!" "readtable")}
      {Lisp-Entry "jazz.named-chars" define #f 60 12 60 28 ()}
      {Lisp-Entry "jazz.in-expression-comment?" define #f 108 12 108 39 ("make-parameter")}
      {Lisp-Entry "jazz.read-literal" define #f 112 13 112 30 ("jazz.construct-literal" "else" "%%cdr" "%%car" "jazz.new-literal" "jazz.walk-for" "%%null?" "jazz.in-expression-comment?" "jazz.read-literals?" "%%not" "or" "cond" "jazz.readenv-wrap" "%%build-list" "lst" "jazz.error" "peek-char" "%%eqv?" "if" "read-char" "%%readenv-current-filepos" "start-pos" "jazz.readenv-port" "port" "let" "c" "re")}
      {Lisp-Entry "jazz.read-comment" define #f 134 13 134 30 ("%%read-datum-or-label-or-none-or-dot" "read" "read-char" "jazz.in-expression-comment?" "parameterize" "jazz.readenv-port" "port" "let" "c" "re")}
      {Lisp-Entry "jazz.read-delimited-string" define #f 143 13 143 39 ("get-output-string" "jazz.readenv-wrap" "peek-char" "and" "else" "write-char" "case" "escaped" "%%eqv?" "%%eof-object?" "cond" "c" "iter" "open-output-string" "output" "read-char" "jazz.readenv-port" "port" "let" "start-pos" "next" "re")}
      {Lisp-Entry "jazz.jazz-readtable" define #f 172 12 172 31 ("jazz.make-jazz-readtable")}
      {Lisp-Entry "jazz.with-jazz-readtable" define #f 176 13 176 37 ("jazz.jazz-readtable" "current-readtable" "parameterize" "thunk")}
      {Lisp-Entry "jazz.char-symbol" define #f 181 13 181 29 ("%%car" "and" "jazz.rassq" "res" "jazz.jazz-readtable" "jazz.readtable-named-char-table" "table" "let" "char")}
      {Lisp-Entry "jazz.eof-object" define #f 197 13 197 28 ("#!eof")}
      {Lisp-Entry "jazz.read-u8" define #f 200 12 200 24 ("read-u8")}
      {Lisp-Entry "jazz.write-u8" define #f 201 12 201 25 ("write-u8")}
      {Lisp-Entry "jazz.read-subu8vector" define #f 202 12 202 33 ("read-subu8vector")}
      {Lisp-Entry "jazz.write-subu8vector" define #f 203 12 203 34 ("write-subu8vector")}
      {Lisp-Entry "jazz.read-line" define #f 205 12 205 26 ("read-line")}
      {Lisp-Entry "jazz.read-proper-line" define #f 208 13 208 34 ("%%string-shrink!" "1" "%%fx-" "%%string-ref" "%%eqv?" "0" "%%fx>" "and" "%%string-length" "len" "values" "eof-object?" "if" "read-line" "line" "let" "port")}
      {Lisp-Entry "jazz.read-all" define #f 217 12 217 25 ("read-all")}
      {Lisp-Entry "jazz.with-readtable" define #f 220 13 220 32 ("current-readtable" "parameterize" "thunk" "readtable")}
      {Lisp-Entry "jazz.skip-whitespace" define #f 227 9 227 29 ("read-char" "peek-char" "char-whitespace?" "%%while" "port")}
      {Lisp-Entry "jazz.read-delimited" define #f 232 9 232 28 ("jazz.queue-list" "read-char" "read" "jazz.enqueue" "peek-char" "%%eqv?" "%%not" "%%while" "jazz.skip-whitespace" "jazz.new-queue" "queue" "let" "delimiter" "port")}
      {Lisp-Entry "jazz.read-until" define #f 242 9 242 24 ("jazz.queue-list" "jazz.enqueue" "set!" "if" "read" "%%not" "%%while" "done?" "jazz.new-queue" "queue" "expr" "let" "port" "test")}
      {Lisp-Entry "jazz.read-content" define #f 254 9 254 26 ("eof-object?" "jazz.read-until" "port")}}})
"repository"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "dialect" "core" "repository.scm"} 1238328026
    {Lisp-Entry "jazz.dialect.core.repository" module #f 37 18 37 46 ()
      {Lisp-Entry "jazz.repository-name" define #f 45 9 45 29 ("%%repository-name" "repository")}
      {Lisp-Entry "jazz.repository-directory" define #f 48 9 48 34 ("%%repository-directory" "repository")}
      {Lisp-Entry "jazz.repository-library-root" define #f 51 9 51 37 ("%%repository-library-root" "repository")}
      {Lisp-Entry "jazz.repository-library-directory" define #f 54 9 54 42 ("%%repository-library-directory" "repository")}
      {Lisp-Entry "jazz.repository-binary?" define #f 57 9 57 32 ("%%repository-binary?" "repository")}
      {Lisp-Entry "jazz.package-repository" define #f 66 9 66 32 ("%%package-repository" "package")}
      {Lisp-Entry "jazz.package-name" define #f 69 9 69 26 ("%%package-name" "package")}
      {Lisp-Entry "jazz.package-directory" define #f 72 9 72 31 ("jazz.package-pathname" "package")}
      {Lisp-Entry "jazz.package-products" define #f 75 9 75 30 ("%%package-products" "package")}
      {Lisp-Entry "jazz.package-project" define #f 78 9 78 29 ("%%package-project" "package")}}})
"scheme"
 ({Lisp-File-Entry {File jazz "src" "jazz" "dialect" "walker" "scheme.jazz"} 1252768922
    {Lisp-Entry "jazz.dialect.walker.scheme" library #f 37 19 37 45 ("jazz.dialect")
      {Lisp-Entry "Define-Declaration" class #f 49 7 49 25 ("Declaration")
        {Lisp-Entry "signature" slot #f 52 8 52 17 ()}
        {Lisp-Entry "get-signature" accessor #f 52 25 52 33 ()}
        {Lisp-Entry "value" slot #f 53 8 53 13 ()}
        {Lisp-Entry "get-value" accessor #f 53 25 53 33 ()}}
      {Lisp-Entry "Define-Special-Form-Declaration" class #f 61 7 61 38 ("Declaration")
        {Lisp-Entry "signature" slot #f 64 8 64 17 ()}
        {Lisp-Entry "get-signature" accessor #f 64 25 64 33 ()}
        {Lisp-Entry "body" slot #f 65 8 65 12 ()}
        {Lisp-Entry "get-body" accessor #f 65 25 65 33 ()}}
      {Lisp-Entry "Define-Macro-Declaration" class #f 73 7 73 31 ("Declaration")
        {Lisp-Entry "signature" slot #f 76 8 76 17 ()}
        {Lisp-Entry "get-signature" accessor #f 76 25 76 33 ()}
        {Lisp-Entry "body" slot #f 77 8 77 12 ()}
        {Lisp-Entry "get-body" accessor #f 77 25 77 33 ()}}
      {Lisp-Entry "Scheme-Dialect" class #f 85 7 85 21 ("Dialect")}
      {Lisp-Entry "Scheme-Walker" class #f 93 7 93 20 ("Walker")}}})
"stack"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "dialect" "core" "stack.scm"} 1252923643
    {Lisp-Entry "jazz.dialect.core.stack" module #f 37 18 37 41 ()
      {Lisp-Entry "jazz.get-procedure-name" define #f 47 13 47 36 ("%%procedure-name" "if" "procedure")}
      {Lisp-Entry "jazz.get-continuation-stack" define #f 53 13 53 40 ("jazz.queue-list" "%%continuation-next-frame" "1" "%%fx+" "jazz.enqueue" "begin" "and" "%%fx<" "%%not" "or" "if" "0" "d" "iter" "jazz.new-queue" "queue" "let" "depth" "cont")}
      {Lisp-Entry "jazz.get-continuation-name" define #f 66 13 66 39 ("%%continuation-creator" "jazz.get-procedure-name" "cont")}
      {Lisp-Entry "jazz.collect-var-val" define #f 70 13 70 33 ("else" "##unbox" "##var-c-name" "##var-c-boxed?" "##var-i-name" "collect-var-val" "##var-i?" "cond" "queue" "cte" "val-or-box" "var")
        {Lisp-Entry "collect-var-val" define #f 71 15 71 30 ("else" "##cte-parent-cte" "##inverse-eval-in-env" "##cte-top?" "if" "remove-quote" "##procedure?" "'<absent>" "jazz.absent-object?" "cond" "##object->string" "%%list" "jazz.enqueue" "queue" "cte" "mutable?" "val" "var")}
        {Lisp-Entry "remove-quote" define #f 85 15 85 27 ("##cadr" "##cdr" "##null?" "##not" "quote" "'quote" "##car" "eq?" "pair?" "and" "if" "val")}}
      {Lisp-Entry "jazz.get-continuation-dynamic-environment" define #f 112 13 112 54 ("jazz.queue-list" "##interaction-cte" "jazz.code-cte" "##interp-continuation-rte" "rte" "##interp-continuation-code" "$code" "%%interp-continuation?" "if" "jazz.continuation-denv" "##dynamic-env->list" "collect-parameters" "and" "jazz.new-queue" "queue" "let" "cont")
        {Lisp-Entry "collect-parameters" define #f 114 15 114 33 ("%%list" "jazz.collect-var-val" "##inverse-eval-in-env" "x" "##hidden-parameter?" "%%not" "%%cdr" "val" "param" "%%car" "param-val" "let*" "%%pair?" "if" "iter" "let" "queue" "cte" "lst")}}
      {Lisp-Entry "jazz.get-continuation-lexical-environment" define #f 139 13 139 54 ("jazz.queue-list" "##interaction-cte" "%%continuation-locals" "collect-locals" "begin" "jazz.code-cte" "collect-rte" "##interp-continuation-rte" "rte" "##interp-continuation-code" "$code" "%%interp-continuation?" "if" "and" "jazz.new-queue" "queue" "let" "cont")
        {Lisp-Entry "collect-rte" define #f 141 15 141 26 ("else" "jazz.rte-up" "##cte-parent-cte" "jazz.collect-var-val" "##hidden-local-var?" "%%not" "%%car" "var" "%%pair?" "if" "%%vector->list" "%%cdr" "vals" "##cte-frame-vars" "vars" "loop2" "##cte-frame?" "##cte-top?" "cond" "r" "c" "loop1" "let" "queue" "rte" "cte")}
        {Lisp-Entry "collect-vars" define #f 160 15 160 27 ("jazz.collect-var-val" "%%cdr" "val" "var" "%%car" "var-val" "let*" "%%pair?" "if" "iter" "let" "queue" "cte" "lst")}
        {Lisp-Entry "collect-locals" define #f 169 15 169 29 ("collect-vars" "and" "queue" "cte" "lst")}}
      {Lisp-Entry "jazz.get-continuation-location" define #f 186 13 186 43 ("%%continuation-locat" "jazz.locat->file/line/col" "cont")}
      {Lisp-Entry "jazz.interpreted-continuation?" define #f 190 13 190 43 ("%%interp-continuation?" "cont")}
      {Lisp-Entry "jazz.with-repl-context" define #f 194 13 194 35 ("jazz.repl-context-bind" "0" "1" "jazz.repl-context-level" "%%fx+" "jazz.make-repl-context" "context" "%%thread-repl-context-get!" "prev-context" "let" "thunk" "cont")}
      {Lisp-Entry "jazz.repl" define #f 210 13 210 22 ("%%repl")}
      {Lisp-Entry "eval-within-no-winding" define #f 222 13 222 35 ("##cdr" "macro-make-rte-from-list" "##car" "##map" "##cte-top-cte" "##cte-frame" "##continuation-locals" "locals" "else" "##interaction-cte" "##compile-top" "##with-no-result-expected-toplevel-continuation?" "##compile-inner" "run" "##interp-continuation-rte" "rte" "jazz.code-cte" "cte" "##interp-continuation-code" "$code" "let*" "##interp-continuation?" "cond" "##make-source" "##sourcify" "src2" "let" "receiver" "repl-context" "cont" "src" "runner")
        {Lisp-Entry "run" define #f 224 15 224 18 ("jazz.code-run" "runner" "let" "receiver" "repl-context" "jazz.repl-context-bind" "lambda" "cont" "%%continuation-graft-no-winding" "rte" "c")}
        {Lisp-Entry "macro-make-rte-from-list" define-macro #f 237 23 237 47 ("lst" "rte")}}
      {Lisp-Entry "jazz.eval-within-no-winding" define #f 256 13 256 40 ("%%car" "%%continuation-return-no-winding" "call-with-values" "results" "jazz.current-repl-context" "eval-within-no-winding" "return" "lambda" "continuation-capture" "cont" "expr" "runner")}
      {Lisp-Entry "jazz.repl-result-history-add" define #f 272 13 272 41 ("%%repl-channel-result-history-add" "%%current-thread" "%%thread-repl-channel-get!" "channel" "let" "result")}
      {Lisp-Entry "jazz.inspect-repl-context" define #f 282 13 282 38 ("context")}}})
"structure"
 ({Lisp-File-Entry {File jazz "src" "jazz" "dialect" "core" "structure.scm"} 1250720196
    {Lisp-Entry "jazz.dialect.core.structure" module #f 37 18 37 45 ()
      {Lisp-Entry "jazz.kind?" define #f 40 9 40 19 ("##type?" "obj")}
      {Lisp-Entry "jazz.kind-id" define #f 43 9 43 21 ("##type-id" "type")}
      {Lisp-Entry "jazz.kind-name" define #f 46 9 46 23 ("##type-name" "type")}
      {Lisp-Entry "jazz.kind-flags" define #f 49 9 49 24 ("##type-flags" "type")}
      {Lisp-Entry "jazz.kind-super" define #f 52 9 52 24 ("##type-super" "type")}
      {Lisp-Entry "jazz.kind-length" define #f 55 9 55 25 ("##type-field-count" "type")}
      {Lisp-Entry "jazz.kind-fields" define #f 58 9 58 25 ("jazz.reverse!" "%%list" "%%cons" "%%fx+" "val" "options" "%%cdr" "rest" "%%car" "name" "let*" "%%pair?" "if" "alist" "##type-fields" "%%vector->list" "lst" "1" "i" "loop" "let" "type")}
      {Lisp-Entry "jazz.structure?" define #f 76 9 76 24 ("##structure?" "obj")}
      {Lisp-Entry "jazz.structure-kind" define #f 79 9 79 28 ("##structure-type" "obj")}
      {Lisp-Entry "jazz.structure-ref" define #f 82 9 82 27 ("##structure-ref" "type" "i" "obj")}
      {Lisp-Entry "jazz.structure-set!" define #f 85 9 85 28 ("##structure-set!" "type" "i" "val" "obj")}}})
"syntax"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "test" "performance" "syntax.scm"} 1237033585
    {Lisp-Entry "test.performance.syntax" module #f 0 8 0 31 ()
      {Lisp-Entry "Z" define-class #f 3 19 3 20 ("allocate-z" "jazz.Object-Class" "jazz.Object")}
      {Lisp-Entry "f-vtable" define-generic/specific ("Z~virtual") 7 22 7 30 ("n")}
      {Lisp-Entry "g-vtable" define-generic/specific ("Z~virtual") 8 22 8 30 ("n")}
      {Lisp-Entry "W" define-class #f 11 19 11 20 ("allocate-w" "jazz.Object-Class" "Z")}
      {Lisp-Entry "h" define-generic/specific ("W~virtual") 15 22 15 23 ()}}})
"system"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "dialect" "core" "system.scm"} 1252768922
    {Lisp-Entry "jazz.dialect.core.system" module #f 37 18 37 42 ()
      {Lisp-Entry "jazz.open-process" define #f 42 12 42 29 ("open-process")}
      {Lisp-Entry "jazz.process-status" define #f 43 12 43 31 ("process-status")}
      {Lisp-Entry "jazz.exit" define #f 44 12 44 21 ("exit")}
      {Lisp-Entry "jazz.switch?" define #f 49 9 49 21 ("0" "%%string-ref" "%%eqv?" "or" "2" "%%string-length" "%%fx>=" "and" "arg")}
      {Lisp-Entry "jazz.switch-name" define #f 55 9 55 25 ("%%string-length" "1" "%%substring" "arg")}
      {Lisp-Entry "jazz.command-argument" define #f 59 9 59 30 ("%%cddr" "else" "%%cadr" "jazz.switch-name" "%%equal?" "jazz.error" "jazz.switch?" "%%not" "or" "cond" "%%car" "arg" "%%null?" "arguments" "iter" "command-line" "%%cdr" "all" "let" "executable" "'executable" "jazz.image" "eq?" "if" "name")}}})
"table"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "dialect" "core" "table.scm"} 1250272407
    {Lisp-Entry "jazz.dialect.core.table" module #f 37 18 37 41 ()
      {Lisp-Entry "jazz.table-clear" define #f 40 9 40 25 ("%%table-clear" "%%table?" "%%debug-assert" "key" "table")}
      {Lisp-Entry "jazz.table-keys" define #f 45 9 45 24 ("%%table-keys" "%%table?" "%%debug-assert" "table")}
      {Lisp-Entry "jazz.table-length" define #f 50 9 50 26 ("%%table-length" "%%table?" "%%debug-assert" "table")}
      {Lisp-Entry "jazz.iterate-table" define #f 55 9 55 27 ("%%iterate-table" "%%table?" "%%debug-assert" "proc" "table")}
      {Lisp-Entry "jazz.map-table" define #f 60 9 60 23 ("jazz.queue-list" "jazz.enqueue" "value" "key" "lambda" "%%iterate-table" "jazz.new-queue" "queue" "let" "%%table?" "%%debug-assert" "proc" "table")}
      {Lisp-Entry "jazz.list->table" define #f 69 9 69 25 ("test:" "%%list->table" "equal?" "test" "#!key" "alist")}
      {Lisp-Entry "jazz.table->list" define #f 73 9 73 25 ("%%table->list" "%%table?" "%%debug-assert" "table")}
      {Lisp-Entry "jazz.table-entries" define #f 78 9 78 27 ("%%table-entries" "%%table?" "%%debug-assert" "table")}
      {Lisp-Entry "jazz.eq-hash" define #f 85 12 85 24 ("eq?-hash")}
      {Lisp-Entry "jazz.eqv-hash" define #f 86 12 86 25 ("eqv?-hash")}
      {Lisp-Entry "jazz.equal-hash" define #f 87 12 87 27 ("equal?-hash")}}})
"template"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "dialect" "syntax" "template.scm"} 1248708411
    {Lisp-Entry "jazz.dialect.syntax.template" library #f 37 19 37 47 ("scheme")}})
"templates"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "dialect" "syntax" "templates.scm"} 1253029898
    {Lisp-Entry "jazz.dialect.syntax.templates" library #f 37 19 37 48 ("scheme")
      {Lisp-Entry "instantiate-for-each" macro #f 44 15 44 35 ("+" "element" "<=" "when" "0" "n" "iterate" "1" "cardinality" "-" "end" "let" ",T" "seq" "proc" "for-each" ",name" "as" "specialize" "T" "name")}
      {Lisp-Entry "instantiate-butlast" macro #f 53 15 53 34 ("1" "cardinality" "-" "0" "subseq" ",T" "seq" "butlast" "specialize" "T")}
      {Lisp-Entry "instantiate-find" macro #f 60 15 60 31 ("element" "obj" "n" "iterate" "1" "0" "-" "+" "next" ">=" "<=" "not" "if" "inside" "eqv?" "or" "cardinality" "len" "let" "reversed?" "reversed?:" "end" "end:" "start" "start:" "test" "test:" "key" "key:" "target" ",T" "seq" "find" ",name" "as" "specialize" "T" "name")}
      {Lisp-Entry "instantiate-find-in" macro #f 79 15 79 34 ("element" "obj" "n" "iterate" "1" "0" "-" "+" "next" ">=" "<=" "not" "if" "inside" "eqv?" "or" "cardinality" "len" "let" "reversed?" "reversed?:" "end" "end:" "start" "start:" "test" "test:" "key" "key:" "target" ",T" "seq" "find-in" ",name" "as" "specialize" "T" "name")}
      {Lisp-Entry "instantiate-starts-with?" macro #f 96 15 96 39 ("0" "subseq" "=" ">=" "and" "tlen" "cardinality" "slen" "let" "target" ",T" "seq" "starts-with?" "specialize" "T")}
      {Lisp-Entry "instantiate-ends-with?" macro #f 104 15 104 37 ("-" "subseq" "=" ">=" "and" "tlen" "cardinality" "slen" "let" "target" ",T" "seq" "ends-with?" "specialize" "T")}}})
"thread"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "dialect" "core" "thread.scm"} 1238328026
    {Lisp-Entry "jazz.dialect.core.thread" module #f 37 18 37 42 ()
      {Lisp-Entry "jazz.current-thread" define #f 47 12 47 31 ("current-thread")}
      {Lisp-Entry "jazz.thread?" define #f 48 12 48 24 ("thread?")}
      {Lisp-Entry "jazz.make-thread" define #f 49 12 49 28 ("make-thread")}
      {Lisp-Entry "jazz.make-root-thread" define #f 50 12 50 33 ("make-root-thread")}
      {Lisp-Entry "jazz.thread-name" define #f 51 12 51 28 ("thread-name")}
      {Lisp-Entry "jazz.thread-specific" define #f 52 12 52 32 ("thread-specific")}
      {Lisp-Entry "jazz.thread-specific-set!" define #f 53 12 53 37 ("thread-specific-set!")}
      {Lisp-Entry "jazz.thread-base-priority" define #f 54 12 54 37 ("thread-base-priority")}
      {Lisp-Entry "jazz.thread-base-priority-set!" define #f 55 12 55 42 ("thread-base-priority-set!")}
      {Lisp-Entry "jazz.thread-priority-boost" define #f 56 12 56 38 ("thread-priority-boost")}
      {Lisp-Entry "jazz.thread-priority-boost-set!" define #f 57 12 57 43 ("thread-priority-boost-set!")}
      {Lisp-Entry "jazz.thread-start!" define #f 58 12 58 30 ("thread-start!")}
      {Lisp-Entry "jazz.thread-yield!" define #f 59 12 59 30 ("thread-yield!")}
      {Lisp-Entry "jazz.thread-sleep!" define #f 60 12 60 30 ("thread-sleep!")}
      {Lisp-Entry "jazz.thread-terminate!" define #f 61 12 61 34 ("thread-terminate!")}
      {Lisp-Entry "jazz.thread-join!" define #f 62 12 62 29 ("thread-join!")}
      {Lisp-Entry "jazz.thread-send" define #f 63 12 63 28 ("thread-send")}
      {Lisp-Entry "jazz.thread-receive" define #f 64 12 64 31 ("thread-receive")}
      {Lisp-Entry "jazz.thread-interrupt!" define #f 65 12 65 34 ("thread-interrupt!")}
      {Lisp-Entry "jazz.thread-thread-group" define #f 66 12 66 36 ("thread-thread-group")}
      {Lisp-Entry "jazz.thread-group->thread-group-list" define #f 67 12 67 48 ("thread-group->thread-group-list")}
      {Lisp-Entry "jazz.thread-group->thread-group-vector" define #f 68 12 68 50 ("thread-group->thread-group-vector")}
      {Lisp-Entry "jazz.thread-group->thread-list" define #f 69 12 69 42 ("thread-group->thread-list")}
      {Lisp-Entry "jazz.thread-group->thread-vector" define #f 70 12 70 44 ("thread-group->thread-vector")}
      {Lisp-Entry "jazz.thread-state" define #f 71 12 71 29 ("thread-state")}
      {Lisp-Entry "jazz.thread-state-abnormally-terminated-reason" define #f 72 12 72 58 ("thread-state-abnormally-terminated-reason")}
      {Lisp-Entry "jazz.thread-state-abnormally-terminated?" define #f 73 12 73 52 ("thread-state-abnormally-terminated?")}
      {Lisp-Entry "jazz.thread-state-active-timeout" define #f 74 12 74 44 ("thread-state-active-timeout")}
      {Lisp-Entry "jazz.thread-state-active-waiting-for" define #f 75 12 75 48 ("thread-state-active-waiting-for")}
      {Lisp-Entry "jazz.thread-state-active?" define #f 76 12 76 37 ("thread-state-active?")}
      {Lisp-Entry "jazz.thread-state-initialized?" define #f 77 12 77 42 ("thread-state-initialized?")}
      {Lisp-Entry "jazz.thread-state-normally-terminated-result" define #f 78 12 78 56 ("thread-state-normally-terminated-result")}
      {Lisp-Entry "jazz.thread-state-normally-terminated?" define #f 79 12 79 50 ("thread-state-normally-terminated?")}
      {Lisp-Entry "jazz.thread-state-uninitialized?" define #f 80 12 80 44 ("thread-state-uninitialized?")}
      {Lisp-Entry "jazz.mutex?" define #f 92 12 92 23 ("mutex?")}
      {Lisp-Entry "jazz.make-mutex" define #f 93 12 93 27 ("make-mutex")}
      {Lisp-Entry "jazz.mutex-name" define #f 94 12 94 27 ("mutex-name")}
      {Lisp-Entry "jazz.mutex-specific" define #f 95 12 95 31 ("mutex-specific")}
      {Lisp-Entry "jazz.mutex-specific-set!" define #f 96 12 96 36 ("mutex-specific-set!")}
      {Lisp-Entry "jazz.mutex-state" define #f 97 12 97 28 ("mutex-state")}
      {Lisp-Entry "jazz.mutex-lock!" define #f 98 12 98 28 ("mutex-lock!")}
      {Lisp-Entry "jazz.mutex-unlock!" define #f 99 12 99 30 ("mutex-unlock!")}
      {Lisp-Entry "jazz.mutex-owner" define #f 101 13 101 29 ("jazz.btq-owner" "mutex")}
      {Lisp-Entry "jazz.mutex-wait" define #f 104 13 104 28 ("mutex-unlock!" "mutex-lock!" "mutex")}
      {Lisp-Entry "jazz.condition?" define #f 118 12 118 27 ("condition-variable?")}
      {Lisp-Entry "jazz.make-condition" define #f 119 12 119 31 ("make-condition-variable")}
      {Lisp-Entry "jazz.condition-name" define #f 120 12 120 31 ("condition-variable-name")}
      {Lisp-Entry "jazz.condition-specific" define #f 121 12 121 35 ("condition-variable-specific")}
      {Lisp-Entry "jazz.condition-specific-set!" define #f 122 12 122 40 ("condition-variable-specific-set!")}
      {Lisp-Entry "jazz.condition-signal!" define #f 123 12 123 34 ("condition-variable-signal!")}
      {Lisp-Entry "jazz.condition-broadcast!" define #f 124 12 124 37 ("condition-variable-broadcast!")}}})
"time"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "test" "performance" "time.scm"} 1237033585
    {Lisp-Entry "test.performance.time" module #f 0 8 0 29 ("new-z" "f-vtable" "f-generic" "f-separate" "iterations" "new-x" "f-module" "time")
      {Lisp-Entry "iterations" define #f 3 8 3 18 ("100000000")}}}
  {Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "dialect" "core" "time.scm"} 1238328026
    {Lisp-Entry "jazz.dialect.core.time" module #f 37 18 37 40 ()
      {Lisp-Entry "jazz.current-systime" define #f 40 8 40 28 ("current-time")}
      {Lisp-Entry "jazz.systime?" define #f 41 8 41 21 ("time?")}
      {Lisp-Entry "jazz.systime->seconds" define #f 42 8 42 29 ("time->seconds")}
      {Lisp-Entry "jazz.seconds->systime" define #f 43 8 43 29 ("seconds->time")}
      {Lisp-Entry "jazz.process-times" define #f 44 8 44 26 ("process-times")}
      {Lisp-Entry "jazz.cpu-time" define #f 45 8 45 21 ("cpu-time")}
      {Lisp-Entry "jazz.real-time" define #f 46 8 46 22 ("real-time")}}})
"typecase"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "dialect" "syntax" "typecase.scm"} 1252768922
    {Lisp-Entry "jazz.dialect.syntax.typecase" library #f 38 19 38 47 ("scheme")
      {Lisp-Entry "private" native #f 44 8 44 15 ("jazz.error")}
      {Lisp-Entry "typecase" macro #f 54 16 54 24 ("desourcify" "error" ",value" ",variable" "is?" "value" "or" "pair?" ",@body" "else" "'else" "eq?" "cdr" "body" "car" "selector" "clause" "map" "cond" "variable" "lambda" "with-uniqueness" "sourcify-if" "cddr" "clauses" "source-code" "cadr" "target" "let" "form-src")}}})
"variables"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "test" "performance" "variables.scm"} 1237033585
    {Lisp-Entry "SEPARATE" define #f 4 8 4 16 ("2")}
    {Lisp-Entry "inc-separate" define #f 7 9 7 21 ("-" "1" "+" "SEPARATE" "set!" "begin" "0" ">" "if" "n" "iter" "let" "cnt")}
    {Lisp-Entry "BLOCK" define #f 19 8 19 13 ("3")}
    {Lisp-Entry "inc-block" define #f 22 9 22 18 ("-" "1" "+" "BLOCK" "set!" "begin" "0" ">" "if" "n" "iter" "let" "cnt")}})
"vb"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "test" "performance" "vb.scm"} 1237033585
    {Lisp-Entry "VAR" define #f 5 8 5 11 ("2")}
    {Lisp-Entry "inc" define #f 8 9 8 12 ("##fixnum.-" "1" "##fixnum.+" "VAR" "set!" "begin" "0" "##fixnum.>" "if" "n" "iter" "let" "cnt")}})
"vector"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "dialect" "core" "vector.scm"} 1238328026
    {Lisp-Entry "jazz.dialect.core.vector" module #f 37 18 37 42 ()
      {Lisp-Entry "jazz.vector-copy" define #f 45 8 45 24 ("vector-copy")}}})
"vs"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "test" "performance" "vs.scm"} 1237033585
    {Lisp-Entry "VAR" define #f 4 8 4 11 ("2")}
    {Lisp-Entry "inc" define #f 7 9 7 12 ("##fixnum.-" "1" "##fixnum.+" "VAR" "set!" "begin" "0" "##fixnum.>" "if" "n" "iter" "let" "cnt")}})
"with"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "dialect" "syntax" "with.scm"} 1248708411
    {Lisp-Entry "jazz.dialect.syntax.with" library #f 37 19 37 43 ("scheme")
      {Lisp-Entry "with" macro #f 44 16 44 20 ("reverse" "car" "release" "binding" "lambda" "map" ",@body" "begin" "prog1" ",bindings" "let*" "sourcify-if" "cddr" "body" "cadr" "source-code" "bindings" "let" "form-src")}
      {Lisp-Entry "with-closed" macro #f 58 16 58 27 ("close" ",@body" "function" "dynamic-wind" "caddr" ",variable" "set!" "if" "variable" ",specifier" "car" "'<Object>" "binding-specifier" "or" "specifier" "binding" "lambda" "map" "sourcify-if" "cddr" "body" "cadr" "source-code" "bindings" "let" "form-src")}}})
