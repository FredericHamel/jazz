"Core-Project"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "project" "jazz" "Core-Project.jazz"} 1238328026
    {Lisp-Entry "project.jazz.Core-Project" #f 37 9 37 34 ("Core-Project" "register-autoclass" "jazz")
      {Lisp-Entry "Core-Project" #f 48 7 48 19 ("project.jazz.Core-Project" "module-name:" "core" "product:" "title:" "Jazz-Project")}}})
"Dialect-Project"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "project" "jazz" "Dialect-Project.jazz"} 1238328026
    {Lisp-Entry "project.jazz.Dialect-Project" #f 37 9 37 37 ("Dialect-Project" "register-autoclass" "jazz")
      {Lisp-Entry "Dialect-Project" #f 48 7 48 22 ("project.jazz.Dialect-Project" "module-name:" "jazz" "product:" "title:" "Jazz-Project")}}})
"Jazz-Manifest"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "project" "jazz" "Jazz-Manifest.jazz"} 1238328026
    {Lisp-Entry "project.jazz.Jazz-Manifest" #f 37 9 37 35 ("Jazz-Manifest" "register-autoclass" "jazz")
      {Lisp-Entry "Jazz-Manifest" #f 47 7 47 20 ("Test-Project" "Platform-Project" "Jazz-Manifest" "Dialect-Project" "Core-Project" "Y" "X" "cffi" "b" "autoload" "a" "_test" "constructors" "_literals" "_language" "name:" "source:" "Directory" "directory:" "project.jazz.Test-Project" "project.jazz.Platform-Project" "project.jazz.Dialect-Project" "project.jazz.Core-Project" "tag-module:" "project.jazz.Jazz-Manifest" "module-name:" "Jazz" "File" "documentation:" "include-extensions:" ":jazz" "catalog-extensions:" "catalog?:" "title:" "Project")}}})
"Platform-Project"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "project" "jazz" "Platform-Project.jazz"} 1238328026
    {Lisp-Entry "project.jazz.Platform-Project" #f 37 9 37 38 ("Platform-Project" "register-autoclass" "jazz")
      {Lisp-Entry "Platform-Project" #f 48 7 48 23 ("project.jazz.Platform-Project" "module-name:" "jazz.platform" "product:" "title:" "Jazz-Project")}}})
"Test-Project"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "project" "jazz" "Test-Project.jazz"} 1238328026
    {Lisp-Entry "project.jazz.Test-Project" #f 37 9 37 34 ("Test-Project" "register-autoclass" "jazz")
      {Lisp-Entry "Test-Project" #f 48 7 48 19 ("project.jazz.Test-Project" "module-name:" "jazz.test" "product:" "title:" "Jazz-Project")}}})
"X"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "test" "X.jazz"} 1237033585
    {Lisp-Entry "jazz.test.X" #f 0 9 0 20 ("jazz")
      {Lisp-Entry "X" #f 3 7 3 8 ("Object")
        {Lisp-Entry "foo" #f 6 19 6 22 ("X.foo" "'X.foo" "terminal")}}}})
"Y"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "test" "Y.jazz"} 1237033585
    {Lisp-Entry "jazz.test.Y" #f 0 9 0 20 ("jazz")
      {Lisp-Entry "Y" #f 6 7 6 8 ("Object")
        {Lisp-Entry "foo" #f 9 11 9 14 ("Y.foo" "'Y.foo" "terminal")}}}})
"_core"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "dialect" "core" "_core.scm"} 1238328026
    {Lisp-Entry "jazz.dialect.core" #f 37 19 37 36 ("scheme")}})
"_dialect"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "dialect" "_dialect.scm"} 1238328026
    {Lisp-Entry "jazz.dialect" #f 37 19 37 31 ("scheme")}})
"_jazz"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "_jazz.scm"} 1236190774
    {Lisp-Entry "jazz" #f 37 9 37 13 ("scheme")}})
"_kernel"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "dialect" "kernel" "_kernel.scm"} 1245777538
    {Lisp-Entry "jazz.dialect.kernel" #f 38 19 38 38 ("scheme")
      {Lisp-Entry "get-autoload" #f 46 8 46 25 ()}
      {Lisp-Entry "autoload" #f 47 8 47 21 ()}
      {Lisp-Entry "autoreload" #f 48 8 48 23 ()}
      {Lisp-Entry "boolean" #f 56 8 56 20 ()}
      {Lisp-Entry "box?" #f 64 8 64 12 ()}
      {Lisp-Entry "box" #f 65 8 65 11 ()}
      {Lisp-Entry "unbox" #f 66 8 66 13 ()}
      {Lisp-Entry "set-box!" #f 67 8 67 16 ()}
      {Lisp-Entry "compile-module" #f 75 8 75 27 ()}
      {Lisp-Entry "build-module" #f 76 8 76 25 ()}
      {Lisp-Entry "build-executable" #f 77 8 77 29 ()}
      {Lisp-Entry "for-each-submodule" #f 78 8 78 31 ()}
      {Lisp-Entry "get-category-name" #f 86 8 86 30 ()}
      {Lisp-Entry "get-category-descendants" #f 87 8 87 37 ()}
      {Lisp-Entry "get-class-ascendant" #f 88 8 88 32 ()}
      {Lisp-Entry "symbolic-char" #f 96 8 96 26 ()}
      {Lisp-Entry "char-symbol" #f 97 8 97 24 ()}
      {Lisp-Entry "continuation?" #f 105 8 105 26 ()}
      {Lisp-Entry "continuation-capture" #f 106 8 106 33 ()}
      {Lisp-Entry "continuation-graft" #f 107 8 107 31 ()}
      {Lisp-Entry "continuation-return" #f 108 8 108 32 ()}
      {Lisp-Entry "run-loop?" #f 116 8 116 22 ()}
      {Lisp-Entry "terminal" #f 117 8 117 21 ()}
      {Lisp-Entry "terminal-string" #f 118 8 118 28 ()}
      {Lisp-Entry "terminal-port" #f 119 8 119 26 ()}
      {Lisp-Entry "error" #f 120 8 120 18 ()}
      {Lisp-Entry "unimplemented" #f 121 8 121 26 ()}
      {Lisp-Entry "dump-stack" #f 122 8 122 23 ()}
      {Lisp-Entry "log-object" #f 123 8 123 23 ()}
      {Lisp-Entry "log-string" #f 124 8 124 23 ()}
      {Lisp-Entry "log-newline" #f 125 8 125 24 ()}
      {Lisp-Entry "close-log" #f 126 8 126 22 ()}
      {Lisp-Entry "inspect-object" #f 127 8 127 27 ()}
      {Lisp-Entry "generate-proper-tail-calls" #f 128 8 128 34 ()}
      {Lisp-Entry "?" #f 140 8 140 9 ()}
      {Lisp-Entry "get-?" #f 140 19 140 24 ()}
      {Lisp-Entry "set-?" #f 140 34 140 39 ()}
      {Lisp-Entry "%" #f 141 8 141 9 ()}
      {Lisp-Entry "get-%" #f 141 19 141 24 ()}
      {Lisp-Entry "set-%" #f 141 34 141 39 ()}
      {Lisp-Entry "?a" #f 144 8 144 10 ()}
      {Lisp-Entry "get-?a" #f 144 20 144 26 ()}
      {Lisp-Entry "set-?a" #f 144 36 144 42 ()}
      {Lisp-Entry "?b" #f 145 8 145 10 ()}
      {Lisp-Entry "get-?b" #f 145 20 145 26 ()}
      {Lisp-Entry "set-?b" #f 145 36 145 42 ()}
      {Lisp-Entry "?c" #f 146 8 146 10 ()}
      {Lisp-Entry "get-?c" #f 146 20 146 26 ()}
      {Lisp-Entry "set-?c" #f 146 36 146 42 ()}
      {Lisp-Entry "?d" #f 147 8 147 10 ()}
      {Lisp-Entry "get-?d" #f 147 20 147 26 ()}
      {Lisp-Entry "set-?d" #f 147 36 147 42 ()}
      {Lisp-Entry "?e" #f 148 8 148 10 ()}
      {Lisp-Entry "get-?e" #f 148 20 148 26 ()}
      {Lisp-Entry "set-?e" #f 148 36 148 42 ()}
      {Lisp-Entry "?f" #f 149 8 149 10 ()}
      {Lisp-Entry "get-?f" #f 149 20 149 26 ()}
      {Lisp-Entry "set-?f" #f 149 36 149 42 ()}
      {Lisp-Entry "?g" #f 150 8 150 10 ()}
      {Lisp-Entry "get-?g" #f 150 20 150 26 ()}
      {Lisp-Entry "set-?g" #f 150 36 150 42 ()}
      {Lisp-Entry "?h" #f 151 8 151 10 ()}
      {Lisp-Entry "get-?h" #f 151 20 151 26 ()}
      {Lisp-Entry "set-?h" #f 151 36 151 42 ()}
      {Lisp-Entry "?i" #f 152 8 152 10 ()}
      {Lisp-Entry "get-?i" #f 152 20 152 26 ()}
      {Lisp-Entry "set-?i" #f 152 36 152 42 ()}
      {Lisp-Entry "?j" #f 153 8 153 10 ()}
      {Lisp-Entry "get-?j" #f 153 20 153 26 ()}
      {Lisp-Entry "set-?j" #f 153 36 153 42 ()}
      {Lisp-Entry "?k" #f 154 8 154 10 ()}
      {Lisp-Entry "get-?k" #f 154 20 154 26 ()}
      {Lisp-Entry "set-?k" #f 154 36 154 42 ()}
      {Lisp-Entry "?l" #f 155 8 155 10 ()}
      {Lisp-Entry "get-?l" #f 155 20 155 26 ()}
      {Lisp-Entry "set-?l" #f 155 36 155 42 ()}
      {Lisp-Entry "?m" #f 156 8 156 10 ()}
      {Lisp-Entry "get-?m" #f 156 20 156 26 ()}
      {Lisp-Entry "set-?m" #f 156 36 156 42 ()}
      {Lisp-Entry "?n" #f 157 8 157 10 ()}
      {Lisp-Entry "get-?n" #f 157 20 157 26 ()}
      {Lisp-Entry "set-?n" #f 157 36 157 42 ()}
      {Lisp-Entry "?o" #f 158 8 158 10 ()}
      {Lisp-Entry "get-?o" #f 158 20 158 26 ()}
      {Lisp-Entry "set-?o" #f 158 36 158 42 ()}
      {Lisp-Entry "?p" #f 159 8 159 10 ()}
      {Lisp-Entry "get-?p" #f 159 20 159 26 ()}
      {Lisp-Entry "set-?p" #f 159 36 159 42 ()}
      {Lisp-Entry "?q" #f 160 8 160 10 ()}
      {Lisp-Entry "get-?q" #f 160 20 160 26 ()}
      {Lisp-Entry "set-?q" #f 160 36 160 42 ()}
      {Lisp-Entry "?r" #f 161 8 161 10 ()}
      {Lisp-Entry "get-?r" #f 161 20 161 26 ()}
      {Lisp-Entry "set-?r" #f 161 36 161 42 ()}
      {Lisp-Entry "?s" #f 162 8 162 10 ()}
      {Lisp-Entry "get-?s" #f 162 20 162 26 ()}
      {Lisp-Entry "set-?s" #f 162 36 162 42 ()}
      {Lisp-Entry "?t" #f 163 8 163 10 ()}
      {Lisp-Entry "get-?t" #f 163 20 163 26 ()}
      {Lisp-Entry "set-?t" #f 163 36 163 42 ()}
      {Lisp-Entry "?u" #f 164 8 164 10 ()}
      {Lisp-Entry "get-?u" #f 164 20 164 26 ()}
      {Lisp-Entry "set-?u" #f 164 36 164 42 ()}
      {Lisp-Entry "?v" #f 165 8 165 10 ()}
      {Lisp-Entry "get-?v" #f 165 20 165 26 ()}
      {Lisp-Entry "set-?v" #f 165 36 165 42 ()}
      {Lisp-Entry "?w" #f 166 8 166 10 ()}
      {Lisp-Entry "get-?w" #f 166 20 166 26 ()}
      {Lisp-Entry "set-?w" #f 166 36 166 42 ()}
      {Lisp-Entry "?x" #f 167 8 167 10 ()}
      {Lisp-Entry "get-?x" #f 167 20 167 26 ()}
      {Lisp-Entry "set-?x" #f 167 36 167 42 ()}
      {Lisp-Entry "?y" #f 168 8 168 10 ()}
      {Lisp-Entry "get-?y" #f 168 20 168 26 ()}
      {Lisp-Entry "set-?y" #f 168 36 168 42 ()}
      {Lisp-Entry "?z" #f 169 8 169 10 ()}
      {Lisp-Entry "get-?z" #f 169 20 169 26 ()}
      {Lisp-Entry "set-?z" #f 169 36 169 42 ()}
      {Lisp-Entry "%a" #f 172 8 172 10 ()}
      {Lisp-Entry "get-%a" #f 172 20 172 26 ()}
      {Lisp-Entry "set-%a" #f 172 36 172 42 ()}
      {Lisp-Entry "%b" #f 173 8 173 10 ()}
      {Lisp-Entry "get-%b" #f 173 20 173 26 ()}
      {Lisp-Entry "set-%b" #f 173 36 173 42 ()}
      {Lisp-Entry "%c" #f 174 8 174 10 ()}
      {Lisp-Entry "get-%c" #f 174 20 174 26 ()}
      {Lisp-Entry "set-%c" #f 174 36 174 42 ()}
      {Lisp-Entry "%d" #f 175 8 175 10 ()}
      {Lisp-Entry "get-%d" #f 175 20 175 26 ()}
      {Lisp-Entry "set-%d" #f 175 36 175 42 ()}
      {Lisp-Entry "%e" #f 176 8 176 10 ()}
      {Lisp-Entry "get-%e" #f 176 20 176 26 ()}
      {Lisp-Entry "set-%e" #f 176 36 176 42 ()}
      {Lisp-Entry "%f" #f 177 8 177 10 ()}
      {Lisp-Entry "get-%f" #f 177 20 177 26 ()}
      {Lisp-Entry "set-%f" #f 177 36 177 42 ()}
      {Lisp-Entry "%g" #f 178 8 178 10 ()}
      {Lisp-Entry "get-%g" #f 178 20 178 26 ()}
      {Lisp-Entry "set-%g" #f 178 36 178 42 ()}
      {Lisp-Entry "%h" #f 179 8 179 10 ()}
      {Lisp-Entry "get-%h" #f 179 20 179 26 ()}
      {Lisp-Entry "set-%h" #f 179 36 179 42 ()}
      {Lisp-Entry "%i" #f 180 8 180 10 ()}
      {Lisp-Entry "get-%i" #f 180 20 180 26 ()}
      {Lisp-Entry "set-%i" #f 180 36 180 42 ()}
      {Lisp-Entry "%j" #f 181 8 181 10 ()}
      {Lisp-Entry "get-%j" #f 181 20 181 26 ()}
      {Lisp-Entry "set-%j" #f 181 36 181 42 ()}
      {Lisp-Entry "%k" #f 182 8 182 10 ()}
      {Lisp-Entry "get-%k" #f 182 20 182 26 ()}
      {Lisp-Entry "set-%k" #f 182 36 182 42 ()}
      {Lisp-Entry "%l" #f 183 8 183 10 ()}
      {Lisp-Entry "get-%l" #f 183 20 183 26 ()}
      {Lisp-Entry "set-%l" #f 183 36 183 42 ()}
      {Lisp-Entry "%m" #f 184 8 184 10 ()}
      {Lisp-Entry "get-%m" #f 184 20 184 26 ()}
      {Lisp-Entry "set-%m" #f 184 36 184 42 ()}
      {Lisp-Entry "%n" #f 185 8 185 10 ()}
      {Lisp-Entry "get-%n" #f 185 20 185 26 ()}
      {Lisp-Entry "set-%n" #f 185 36 185 42 ()}
      {Lisp-Entry "%o" #f 186 8 186 10 ()}
      {Lisp-Entry "get-%o" #f 186 20 186 26 ()}
      {Lisp-Entry "set-%o" #f 186 36 186 42 ()}
      {Lisp-Entry "%p" #f 187 8 187 10 ()}
      {Lisp-Entry "get-%p" #f 187 20 187 26 ()}
      {Lisp-Entry "set-%p" #f 187 36 187 42 ()}
      {Lisp-Entry "%q" #f 188 8 188 10 ()}
      {Lisp-Entry "get-%q" #f 188 20 188 26 ()}
      {Lisp-Entry "set-%q" #f 188 36 188 42 ()}
      {Lisp-Entry "%r" #f 189 8 189 10 ()}
      {Lisp-Entry "get-%r" #f 189 20 189 26 ()}
      {Lisp-Entry "set-%r" #f 189 36 189 42 ()}
      {Lisp-Entry "%s" #f 190 8 190 10 ()}
      {Lisp-Entry "get-%s" #f 190 20 190 26 ()}
      {Lisp-Entry "set-%s" #f 190 36 190 42 ()}
      {Lisp-Entry "%t" #f 191 8 191 10 ()}
      {Lisp-Entry "get-%t" #f 191 20 191 26 ()}
      {Lisp-Entry "set-%t" #f 191 36 191 42 ()}
      {Lisp-Entry "%u" #f 192 8 192 10 ()}
      {Lisp-Entry "get-%u" #f 192 20 192 26 ()}
      {Lisp-Entry "set-%u" #f 192 36 192 42 ()}
      {Lisp-Entry "%v" #f 193 8 193 10 ()}
      {Lisp-Entry "get-%v" #f 193 20 193 26 ()}
      {Lisp-Entry "set-%v" #f 193 36 193 42 ()}
      {Lisp-Entry "%w" #f 194 8 194 10 ()}
      {Lisp-Entry "get-%w" #f 194 20 194 26 ()}
      {Lisp-Entry "set-%w" #f 194 36 194 42 ()}
      {Lisp-Entry "%x" #f 195 8 195 10 ()}
      {Lisp-Entry "get-%x" #f 195 20 195 26 ()}
      {Lisp-Entry "set-%x" #f 195 36 195 42 ()}
      {Lisp-Entry "%y" #f 196 8 196 10 ()}
      {Lisp-Entry "get-%y" #f 196 20 196 26 ()}
      {Lisp-Entry "set-%y" #f 196 36 196 42 ()}
      {Lisp-Entry "%z" #f 197 8 197 10 ()}
      {Lisp-Entry "get-%z" #f 197 20 197 26 ()}
      {Lisp-Entry "set-%z" #f 197 36 197 42 ()}
      {Lisp-Entry "open-digest" #f 205 8 205 19 ()}
      {Lisp-Entry "close-digest" #f 206 8 206 20 ()}
      {Lisp-Entry "digest-update-subu8vector" #f 207 8 207 33 ()}
      {Lisp-Entry "digest-string" #f 208 8 208 21 ()}
      {Lisp-Entry "digest-substring" #f 209 8 209 24 ()}
      {Lisp-Entry "digest-u8vector" #f 210 8 210 23 ()}
      {Lisp-Entry "digest-subu8vector" #f 211 8 211 26 ()}
      {Lisp-Entry "digest-file" #f 212 8 212 19 ()}
      {Lisp-Entry "enumerator?" #f 220 8 220 24 ()}
      {Lisp-Entry "enumerator->symbol" #f 221 8 221 31 ()}
      {Lisp-Entry "exception-reason" #f 229 8 229 29 ()}
      {Lisp-Entry "exception-detail" #f 230 8 230 29 ()}
      {Lisp-Entry "display-exception" #f 231 8 231 30 ()}
      {Lisp-Entry "display-continuation-backtrace" #f 232 8 232 43 ()}
      {Lisp-Entry "get-exception-hook" #f 233 8 233 31 ()}
      {Lisp-Entry "set-exception-hook" #f 234 8 234 31 ()}
      {Lisp-Entry "invoke-exception-hook" #f 235 8 235 34 ()}
      {Lisp-Entry "system-exception-hook" #f 236 8 236 34 ()}
      {Lisp-Entry "current-exception-handler" #f 237 8 237 38 ()}
      {Lisp-Entry "with-exception-handler" #f 238 8 238 35 ()}
      {Lisp-Entry "with-exception-catcher" #f 239 8 239 35 ()}
      {Lisp-Entry "with-exception-filter" #f 240 8 240 34 ()}
      {Lisp-Entry "with-exception-propagater" #f 241 8 241 38 ()}
      {Lisp-Entry "dump-exception" #f 242 8 242 27 ()}
      {Lisp-Entry "raise" #f 243 8 243 18 ()}
      {Lisp-Entry "present-exception" #f 244 8 244 30 ()}
      {Lisp-Entry "get-detail" #f 245 8 245 23 ()}
      {Lisp-Entry "field?" #f 253 8 253 19 ()}
      {Lisp-Entry "field-name" #f 254 8 254 23 ()}
      {Lisp-Entry "find-field" #f 255 8 255 23 ()}
      {Lisp-Entry "fixnum?" #f 263 8 263 15 ()}
      {Lisp-Entry "flonum?" #f 264 8 264 15 ()}
      {Lisp-Entry "fixnum->flonum" #f 265 8 265 27 ()}
      {Lisp-Entry "flonum->fixnum" #f 266 8 266 27 ()}
      {Lisp-Entry "fx+" #f 267 8 267 11 ()}
      {Lisp-Entry "fx-" #f 268 8 268 11 ()}
      {Lisp-Entry "fx*" #f 269 8 269 11 ()}
      {Lisp-Entry "+infinity" #f 270 8 270 22 ()}
      {Lisp-Entry "-infinity" #f 271 8 271 22 ()}
      {Lisp-Entry "##fl+" #f 281 8 281 13 ()}
      {Lisp-Entry "##fl-" #f 282 8 282 13 ()}
      {Lisp-Entry "##fl*" #f 283 8 283 13 ()}
      {Lisp-Entry "##fl/" #f 284 8 284 13 ()}
      {Lisp-Entry "foreign?" #f 292 8 292 21 ()}
      {Lisp-Entry "foreign-address" #f 293 8 293 28 ()}
      {Lisp-Entry "foreign-release!" #f 294 8 294 29 ()}
      {Lisp-Entry "foreign-released?" #f 295 8 295 30 ()}
      {Lisp-Entry "foreign-tags" #f 296 8 296 25 ()}
      {Lisp-Entry "still-obj-refcount-dec!" #f 298 8 298 36 ()}
      {Lisp-Entry "still-obj-refcount-inc!" #f 299 8 299 36 ()}
      {Lisp-Entry "compile-file" #f 307 8 307 20 ()}
      {Lisp-Entry "command-line" #f 315 8 315 20 ()}
      {Lisp-Entry "user-name" #f 316 8 316 17 ()}
      {Lisp-Entry "composite-name?" #f 324 8 324 28 ()}
      {Lisp-Entry "compose-name" #f 325 8 325 25 ()}
      {Lisp-Entry "identifier-module" #f 326 8 326 30 ()}
      {Lisp-Entry "identifier-name" #f 327 8 327 28 ()}
      {Lisp-Entry "split-identifier" #f 328 8 328 29 ()}
      {Lisp-Entry "bitwise-not" #f 344 8 344 19 ()}
      {Lisp-Entry "bitwise-and" #f 345 8 345 19 ()}
      {Lisp-Entry "bitwise-ior" #f 346 8 346 19 ()}
      {Lisp-Entry "bitwise-xor" #f 347 8 347 19 ()}
      {Lisp-Entry "arithmetic-shift" #f 348 8 348 24 ()}
      {Lisp-Entry "bit-set?" #f 349 8 349 16 ()}
      {Lisp-Entry "extract-bit-field" #f 350 8 350 25 ()}
      {Lisp-Entry "build-feedback" #f 358 8 358 27 ()}
      {Lisp-Entry "boot-directory" #f 359 8 359 27 ()}
      {Lisp-Entry "kernel-system" #f 360 8 360 26 ()}
      {Lisp-Entry "kernel-platform" #f 361 8 361 28 ()}
      {Lisp-Entry "kernel-windowing" #f 362 8 362 29 ()}
      {Lisp-Entry "kernel-safety" #f 363 8 363 26 ()}
      {Lisp-Entry "kernel-optimize?" #f 364 8 364 29 ()}
      {Lisp-Entry "kernel-debug-environments?" #f 365 8 365 39 ()}
      {Lisp-Entry "kernel-debug-location?" #f 366 8 366 35 ()}
      {Lisp-Entry "kernel-debug-source?" #f 367 8 367 33 ()}
      {Lisp-Entry "kernel-destination" #f 368 8 368 31 ()}
      {Lisp-Entry "kernel-built" #f 369 8 369 25 ()}
      {Lisp-Entry "kernel-install" #f 370 8 370 27 ()}
      {Lisp-Entry "kernel-source" #f 371 8 371 26 ()}
      {Lisp-Entry "kernel-version" #f 372 8 372 27 ()}
      {Lisp-Entry "get-source-version-number" #f 373 8 373 38 ()}
      {Lisp-Entry "jazz-product" #f 374 8 374 25 ()}
      {Lisp-Entry "jazz-profile" #f 375 8 375 25 ()}
      {Lisp-Entry "use-debugger?" #f 376 8 376 26 ()}
      {Lisp-Entry "get-repositories" #f 377 8 377 29 ()}
      {Lisp-Entry "install-repository" #f 378 8 378 31 ()}
      {Lisp-Entry "uninstall-repository" #f 379 8 379 33 ()}
      {Lisp-Entry "find-repository" #f 380 8 380 28 ()}
      {Lisp-Entry "find-package" #f 381 8 381 25 ()}
      {Lisp-Entry "repository?" #f 382 8 382 24 ()}
      {Lisp-Entry "repository-name" #f 383 8 383 28 ()}
      {Lisp-Entry "repository-directory" #f 384 8 384 33 ()}
      {Lisp-Entry "repository-library-root" #f 385 8 385 36 ()}
      {Lisp-Entry "repository-library-directory" #f 386 8 386 41 ()}
      {Lisp-Entry "repository-binary?" #f 387 8 387 31 ()}
      {Lisp-Entry "repository-packages" #f 388 8 388 32 ()}
      {Lisp-Entry "repository-find-package" #f 389 8 389 36 ()}
      {Lisp-Entry "repository-install-packages" #f 390 8 390 40 ()}
      {Lisp-Entry "repository-add-package" #f 391 8 391 35 ()}
      {Lisp-Entry "repository-remove-package" #f 392 8 392 38 ()}
      {Lisp-Entry "package?" #f 393 8 393 21 ()}
      {Lisp-Entry "package-repository" #f 394 8 394 31 ()}
      {Lisp-Entry "package-name" #f 395 8 395 25 ()}
      {Lisp-Entry "package-directory" #f 396 8 396 30 ()}
      {Lisp-Entry "package-products" #f 397 8 397 29 ()}
      {Lisp-Entry "package-project" #f 398 8 398 28 ()}
      {Lisp-Entry "split-version" #f 399 8 399 26 ()}
      {Lisp-Entry "present-version" #f 400 8 400 28 ()}
      {Lisp-Entry "load-package" #f 401 8 401 25 ()}
      {Lisp-Entry "register-product" #f 402 8 402 29 ()}
      {Lisp-Entry "register-product-run" #f 403 8 403 33 ()}
      {Lisp-Entry "product-descriptor-name" #f 404 8 404 36 ()}
      {Lisp-Entry "product-descriptor-module" #f 405 8 405 38 ()}
      {Lisp-Entry "product-descriptor-title" #f 406 8 406 37 ()}
      {Lisp-Entry "product-descriptor-icon" #f 407 8 407 36 ()}
      {Lisp-Entry "product-descriptor-run" #f 408 8 408 35 ()}
      {Lisp-Entry "product-descriptor-update" #f 409 8 409 38 ()}
      {Lisp-Entry "product-descriptor-build" #f 410 8 410 37 ()}
      {Lisp-Entry "product-descriptor-dependencies" #f 411 8 411 44 ()}
      {Lisp-Entry "run-product-descriptor" #f 412 8 412 35 ()}
      {Lisp-Entry "update-product-descriptor" #f 413 8 413 38 ()}
      {Lisp-Entry "build-product-descriptor" #f 414 8 414 37 ()}
      {Lisp-Entry "current-process-name" #f 415 8 415 33 ()}
      {Lisp-Entry "current-process-name-set!" #f 416 8 416 38 ()}
      {Lisp-Entry "current-process-title" #f 417 8 417 34 ()}
      {Lisp-Entry "current-process-title-set!" #f 418 8 418 39 ()}
      {Lisp-Entry "current-process-icon" #f 419 8 419 33 ()}
      {Lisp-Entry "current-process-icon-set!" #f 420 8 420 38 ()}
      {Lisp-Entry "current-process-version" #f 421 8 421 36 ()}
      {Lisp-Entry "current-process-version-set!" #f 422 8 422 41 ()}
      {Lisp-Entry "current-process-present" #f 423 8 423 36 ()}
      {Lisp-Entry "destination-directory" #f 424 8 424 34 ()}
      {Lisp-Entry "executable-extension" #f 425 8 425 33 ()}
      {Lisp-Entry "run-product" #f 426 8 426 24 ()}
      {Lisp-Entry "update-product" #f 427 8 427 27 ()}
      {Lisp-Entry "build-product" #f 428 8 428 26 ()}
      {Lisp-Entry "descendant-module?" #f 429 8 429 31 ()}
      {Lisp-Entry "find-pathname-module" #f 430 8 430 33 ()}
      {Lisp-Entry "find-module-src" #f 431 8 431 28 ()}
      {Lisp-Entry "gather-profiles" #f 432 8 432 28 ()}
      {Lisp-Entry "make-profile" #f 433 8 433 25 ()}
      {Lisp-Entry "profile-name" #f 434 8 434 25 ()}
      {Lisp-Entry "profile-title" #f 435 8 435 26 ()}
      {Lisp-Entry "profile-module" #f 436 8 436 27 ()}
      {Lisp-Entry "module-autoload" #f 437 8 437 28 ()}
      {Lisp-Entry "get-environment" #f 438 8 438 28 ()}
      {Lisp-Entry "get-environment-module" #f 439 8 439 35 ()}
      {Lisp-Entry "module-loaded?" #f 440 8 440 27 ()}
      {Lisp-Entry "module-uptodate-binary?" #f 441 8 441 36 ()}
      {Lisp-Entry "load-module" #f 442 8 442 24 ()}
      {Lisp-Entry "reload-module" #f 443 8 443 26 ()}
      {Lisp-Entry "load-all" #f 444 8 444 21 ()}
      {Lisp-Entry "get-load-mutex" #f 445 8 445 27 ()}
      {Lisp-Entry "get-load-stack" #f 446 8 446 27 ()}
      {Lisp-Entry "walk-for" #f 447 8 447 21 ()}
      {Lisp-Entry "register-service" #f 448 8 448 29 ()}
      {Lisp-Entry "get-service" #f 449 8 449 24 ()}
      {Lisp-Entry "require-service" #f 450 8 450 28 ()}
      {Lisp-Entry "main" #f 451 8 451 12 ()}
      {Lisp-Entry "keyword?" #f 459 8 459 21 ()}
      {Lisp-Entry "string->keyword" #f 460 8 460 28 ()}
      {Lisp-Entry "keyword->string" #f 461 8 461 28 ()}
      {Lisp-Entry "not-null?" #f 469 8 469 22 ()}
      {Lisp-Entry "listify" #f 470 8 470 20 ()}
      {Lisp-Entry "list-copy" #f 471 8 471 22 ()}
      {Lisp-Entry "last-pair" #f 472 8 472 22 ()}
      {Lisp-Entry "proper-list" #f 473 8 473 24 ()}
      {Lisp-Entry "gc" #f 481 8 481 15 ()}
      {Lisp-Entry "process-memory" #f 482 8 482 27 ()}
      {Lisp-Entry "symbols-memory" #f 483 8 483 27 ()}
      {Lisp-Entry "classes-statistics" #f 484 8 484 31 ()}
      {Lisp-Entry "class-instances-count" #f 485 8 485 34 ()}
      {Lisp-Entry "class-instances-size" #f 486 8 486 33 ()}
      {Lisp-Entry "instances-statistics" #f 487 8 487 33 ()}
      {Lisp-Entry "vector-size" #f 488 8 488 24 ()}
      {Lisp-Entry "f64vector-size" #f 489 8 489 27 ()}
      {Lisp-Entry "list-size" #f 490 8 490 22 ()}
      {Lisp-Entry "table-size" #f 491 8 491 23 ()}
      {Lisp-Entry "open-tcp-client" #f 499 8 499 28 ()}
      {Lisp-Entry "open-tcp-server" #f 500 8 500 28 ()}
      {Lisp-Entry "tcp-server-socket-info" #f 501 8 501 35 ()}
      {Lisp-Entry "call-with-tcp-client" #f 502 8 502 33 ()}
      {Lisp-Entry "new" #f 510 8 510 16 ()}
      {Lisp-Entry "class-of" #f 511 8 511 21 ()}
      {Lisp-Entry "object?" #f 512 8 512 20 ()}
      {Lisp-Entry "type?" #f 513 8 513 18 ()}
      {Lisp-Entry "category?" #f 514 8 514 22 ()}
      {Lisp-Entry "interface?" #f 515 8 515 23 ()}
      {Lisp-Entry "method?" #f 516 8 516 20 ()}
      {Lisp-Entry "is?" #f 517 8 517 16 ()}
      {Lisp-Entry "subtype?" #f 518 8 518 21 ()}
      {Lisp-Entry "subcategory?" #f 519 8 519 25 ()}
      {Lisp-Entry "subclass?" #f 520 8 520 22 ()}
      {Lisp-Entry "make-parameter" #f 528 8 528 22 ()}
      {Lisp-Entry "pathname-type" #f 536 8 536 26 ()}
      {Lisp-Entry "pathname-expand" #f 537 8 537 28 ()}
      {Lisp-Entry "pathname-normalize" #f 538 8 538 31 ()}
      {Lisp-Entry "file-exists?" #f 539 8 539 25 ()}
      {Lisp-Entry "file-delete" #f 540 8 540 24 ()}
      {Lisp-Entry "file-copy" #f 541 8 541 22 ()}
      {Lisp-Entry "file-modification-time" #f 542 8 542 35 ()}
      {Lisp-Entry "file-rename" #f 543 8 543 24 ()}
      {Lisp-Entry "current-directory" #f 544 8 544 30 ()}
      {Lisp-Entry "current-directory-set!" #f 545 8 545 35 ()}
      {Lisp-Entry "with-current-directory" #f 546 8 546 35 ()}
      {Lisp-Entry "directory-create" #f 547 8 547 29 ()}
      {Lisp-Entry "directory-content" #f 548 8 548 30 ()}
      {Lisp-Entry "directory-delete" #f 549 8 549 29 ()}
      {Lisp-Entry "open-string-pipe" #f 557 8 557 24 ()}
      {Lisp-Entry "port?" #f 565 8 565 13 ()}
      {Lisp-Entry "close-port" #f 566 8 566 23 ()}
      {Lisp-Entry "input-port-timeout-set!" #f 567 8 567 36 ()}
      {Lisp-Entry "output-port-timeout-set!" #f 568 8 568 37 ()}
      {Lisp-Entry "open-event-queue" #f 569 8 569 24 ()}
      {Lisp-Entry "eof-object" #f 570 8 570 23 ()}
      {Lisp-Entry "open-input-string" #f 571 8 571 25 ()}
      {Lisp-Entry "open-output-string" #f 572 8 572 26 ()}
      {Lisp-Entry "get-output-string" #f 573 8 573 25 ()}
      {Lisp-Entry "call-with-input-string" #f 574 8 574 30 ()}
      {Lisp-Entry "with-input-from-string" #f 575 8 575 30 ()}
      {Lisp-Entry "call-with-output-string" #f 576 8 576 31 ()}
      {Lisp-Entry "read-substring" #f 577 8 577 22 ()}
      {Lisp-Entry "open-vector" #f 578 8 578 19 ()}
      {Lisp-Entry "call-with-input-u8vector" #f 579 8 579 32 ()}
      {Lisp-Entry "open-output-u8vector" #f 580 8 580 28 ()}
      {Lisp-Entry "get-output-u8vector" #f 581 8 581 27 ()}
      {Lisp-Entry "read-u8" #f 582 8 582 20 ()}
      {Lisp-Entry "write-u8" #f 583 8 583 21 ()}
      {Lisp-Entry "read-subu8vector" #f 584 8 584 29 ()}
      {Lisp-Entry "write-subu8vector" #f 585 8 585 30 ()}
      {Lisp-Entry "read-line" #f 586 8 586 22 ()}
      {Lisp-Entry "read-proper-line" #f 587 8 587 29 ()}
      {Lisp-Entry "read-all" #f 588 8 588 21 ()}
      {Lisp-Entry "print" #f 589 8 589 18 ()}
      {Lisp-Entry "pretty-print" #f 590 8 590 25 ()}
      {Lisp-Entry "read-source-all" #f 591 8 591 28 ()}
      {Lisp-Entry "read-source-first" #f 592 8 592 30 ()}
      {Lisp-Entry "force-output" #f 593 8 593 20 ()}
      {Lisp-Entry "current-error-port" #f 594 8 594 26 ()}
      {Lisp-Entry "with-output-to-port" #f 595 8 595 27 ()}
      {Lisp-Entry "write-u8" #f 596 8 596 16 ()}
      {Lisp-Entry "property-getter" #f 604 8 604 28 ()}
      {Lisp-Entry "property-setter" #f 605 8 605 28 ()}
      {Lisp-Entry "new-queue" #f 613 8 613 22 ()}
      {Lisp-Entry "enqueue" #f 614 8 614 20 ()}
      {Lisp-Entry "enqueue-list" #f 615 8 615 25 ()}
      {Lisp-Entry "queue-list" #f 616 8 616 23 ()}
      {Lisp-Entry "reset-queue" #f 617 8 617 24 ()}
      {Lisp-Entry "random-integer" #f 625 8 625 27 ()}
      {Lisp-Entry "random-real" #f 626 8 626 24 ()}
      {Lisp-Entry "random-source-randomize!" #f 627 8 627 37 ()}
      {Lisp-Entry "random-source-pseudo-randomize!" #f 628 8 628 44 ()}
      {Lisp-Entry "default-random-source" #f 629 8 629 34 ()}
      {Lisp-Entry "with-readtable" #f 637 8 637 27 ()}
      {Lisp-Entry "scheme-readtable" #f 638 8 638 29 ()}
      {Lisp-Entry "jazz-readtable" #f 639 8 639 27 ()}
      {Lisp-Entry "with-jazz-readtable" #f 640 8 640 32 ()}
      {Lisp-Entry "install-jazz-literals" #f 641 8 641 34 ()}
      {Lisp-Entry "current-repl-context" #f 649 8 649 33 ()}
      {Lisp-Entry "repl-context-level" #f 650 8 650 31 ()}
      {Lisp-Entry "repl-context-depth" #f 651 8 651 31 ()}
      {Lisp-Entry "repl-context-cont" #f 652 8 652 30 ()}
      {Lisp-Entry "repl-context-initial-cont" #f 653 8 653 38 ()}
      {Lisp-Entry "repl-context-prev-level" #f 654 8 654 36 ()}
      {Lisp-Entry "repl-context-prev-depth" #f 655 8 655 36 ()}
      {Lisp-Entry "with-repl-context" #f 656 8 656 30 ()}
      {Lisp-Entry "inspect-repl-context" #f 657 8 657 33 ()}
      {Lisp-Entry "repl" #f 658 8 658 17 ()}
      {Lisp-Entry "eval-within-no-winding" #f 659 8 659 35 ()}
      {Lisp-Entry "repl-result-history-add" #f 660 8 660 36 ()}
      {Lisp-Entry "repl-result-history-ref" #f 661 8 661 31 ()}
      {Lisp-Entry "resource-pathname" #f 669 8 669 30 ()}
      {Lisp-Entry "get-catalog" #f 677 8 677 24 ()}
      {Lisp-Entry "get-catalog-entry" #f 678 8 678 30 ()}
      {Lisp-Entry "locate-library-declaration" #f 679 8 679 39 ()}
      {Lisp-Entry "get-object-slot" #f 680 8 680 28 ()}
      {Lisp-Entry "set-object-slot" #f 681 8 681 28 ()}
      {Lisp-Entry "dispatch" #f 682 8 682 21 ()}
      {Lisp-Entry "find-dispatch" #f 683 8 683 26 ()}
      {Lisp-Entry "call-into-abstract" #f 684 8 684 31 ()}
      {Lisp-Entry "object->serial" #f 692 8 692 27 ()}
      {Lisp-Entry "serial->object" #f 693 8 693 27 ()}
      {Lisp-Entry "object->serial-number" #f 696 8 696 29 ()}
      {Lisp-Entry "serial-number->object" #f 697 8 697 29 ()}
      {Lisp-Entry "shell-command" #f 705 8 705 21 ()}
      {Lisp-Entry "slot?" #f 713 8 713 18 ()}
      {Lisp-Entry "slot-value" #f 714 8 714 23 ()}
      {Lisp-Entry "set-slot-value" #f 715 8 715 27 ()}
      {Lisp-Entry "socket-info-address" #f 723 8 723 32 ()}
      {Lisp-Entry "socket-info-port-number" #f 724 8 724 36 ()}
      {Lisp-Entry "get-procedure-name" #f 732 8 732 31 ()}
      {Lisp-Entry "get-continuation-stack" #f 733 8 733 35 ()}
      {Lisp-Entry "get-continuation-name" #f 734 8 734 34 ()}
      {Lisp-Entry "get-continuation-dynamic-environment" #f 735 8 735 49 ()}
      {Lisp-Entry "get-continuation-lexical-environment" #f 736 8 736 49 ()}
      {Lisp-Entry "get-continuation-location" #f 737 8 737 38 ()}
      {Lisp-Entry "active-profile" #f 745 8 745 27 ()}
      {Lisp-Entry "profile-total" #f 746 8 746 26 ()}
      {Lisp-Entry "profile-unknown" #f 747 8 747 28 ()}
      {Lisp-Entry "profile-calls" #f 748 8 748 26 ()}
      {Lisp-Entry "reset-profile" #f 749 8 749 26 ()}
      {Lisp-Entry "start-profile" #f 750 8 750 26 ()}
      {Lisp-Entry "stop-profile" #f 751 8 751 25 ()}
      {Lisp-Entry "profile-running?" #f 752 8 752 29 ()}
      {Lisp-Entry "join-strings" #f 760 8 760 25 ()}
      {Lisp-Entry "generate-symbol" #f 768 8 768 28 ()}
      {Lisp-Entry "with-uniqueness" #f 769 8 769 28 ()}
      {Lisp-Entry "source?" #f 777 8 777 20 ()}
      {Lisp-Entry "source-code" #f 778 8 778 24 ()}
      {Lisp-Entry "source-locat" #f 779 8 779 25 ()}
      {Lisp-Entry "desourcify" #f 780 8 780 23 ()}
      {Lisp-Entry "desourcify-list" #f 781 8 781 28 ()}
      {Lisp-Entry "sourcify" #f 782 8 782 21 ()}
      {Lisp-Entry "sourcify-if" #f 783 8 783 24 ()}
      {Lisp-Entry "present-source" #f 784 8 784 27 ()}
      {Lisp-Entry "locat-container" #f 785 8 785 28 ()}
      {Lisp-Entry "locat-position" #f 786 8 786 27 ()}
      {Lisp-Entry "locat->file/line/col" #f 787 8 787 33 ()}
      {Lisp-Entry "container->path" #f 788 8 788 28 ()}
      {Lisp-Entry "position->filepos" #f 789 8 789 30 ()}
      {Lisp-Entry "filepos-line" #f 790 8 790 25 ()}
      {Lisp-Entry "filepos-col" #f 791 8 791 24 ()}
      {Lisp-Entry "switch?" #f 799 8 799 20 ()}
      {Lisp-Entry "switch-name" #f 800 8 800 24 ()}
      {Lisp-Entry "command-argument" #f 801 8 801 29 ()}
      {Lisp-Entry "open-process" #f 802 8 802 25 ()}
      {Lisp-Entry "process-status" #f 803 8 803 27 ()}
      {Lisp-Entry "exit" #f 804 8 804 17 ()}
      {Lisp-Entry "table?" #f 812 8 812 14 ()}
      {Lisp-Entry "make-table" #f 813 8 813 18 ()}
      {Lisp-Entry "table-ref" #f 814 8 814 17 ()}
      {Lisp-Entry "table-set!" #f 815 8 815 18 ()}
      {Lisp-Entry "table->list" #f 816 8 816 19 ()}
      {Lisp-Entry "list->table" #f 817 8 817 19 ()}
      {Lisp-Entry "table-clear" #f 818 8 818 24 ()}
      {Lisp-Entry "table-length" #f 819 8 819 25 ()}
      {Lisp-Entry "iterate-table" #f 820 8 820 26 ()}
      {Lisp-Entry "map-table" #f 821 8 821 22 ()}
      {Lisp-Entry "table-entries" #f 822 8 822 26 ()}
      {Lisp-Entry "eq-hash" #f 823 8 823 20 ()}
      {Lisp-Entry "eqv-hash" #f 824 8 824 21 ()}
      {Lisp-Entry "equal-hash" #f 825 8 825 23 ()}
      {Lisp-Entry "set-terminal-title" #f 833 8 833 31 ()}
      {Lisp-Entry "bring-terminal-to-front" #f 834 8 834 36 ()}
      {Lisp-Entry "clear-terminal" #f 835 8 835 27 ()}
      {Lisp-Entry "current-thread" #f 843 8 843 27 ()}
      {Lisp-Entry "thread?" #f 844 8 844 20 ()}
      {Lisp-Entry "make-thread" #f 845 8 845 24 ()}
      {Lisp-Entry "make-root-thread" #f 846 8 846 29 ()}
      {Lisp-Entry "thread-name" #f 847 8 847 24 ()}
      {Lisp-Entry "thread-specific" #f 848 8 848 28 ()}
      {Lisp-Entry "thread-specific-set!" #f 849 8 849 33 ()}
      {Lisp-Entry "thread-base-priority" #f 850 8 850 33 ()}
      {Lisp-Entry "thread-base-priority-set!" #f 851 8 851 38 ()}
      {Lisp-Entry "thread-priority-boost" #f 852 8 852 34 ()}
      {Lisp-Entry "thread-priority-boost-set!" #f 853 8 853 39 ()}
      {Lisp-Entry "thread-start!" #f 854 8 854 26 ()}
      {Lisp-Entry "thread-yield!" #f 855 8 855 26 ()}
      {Lisp-Entry "thread-sleep!" #f 856 8 856 26 ()}
      {Lisp-Entry "thread-terminate!" #f 857 8 857 30 ()}
      {Lisp-Entry "thread-join!" #f 858 8 858 25 ()}
      {Lisp-Entry "thread-send" #f 859 8 859 24 ()}
      {Lisp-Entry "thread-receive" #f 860 8 860 27 ()}
      {Lisp-Entry "thread-interrupt!" #f 861 8 861 30 ()}
      {Lisp-Entry "thread-thread-group" #f 862 8 862 32 ()}
      {Lisp-Entry "thread-group->thread-group-list" #f 863 8 863 44 ()}
      {Lisp-Entry "thread-group->thread-group-vector" #f 864 8 864 46 ()}
      {Lisp-Entry "thread-group->thread-list" #f 865 8 865 38 ()}
      {Lisp-Entry "thread-group->thread-vector" #f 866 8 866 40 ()}
      {Lisp-Entry "thread-state" #f 867 8 867 25 ()}
      {Lisp-Entry "thread-state-abnormally-terminated-reason" #f 868 8 868 54 ()}
      {Lisp-Entry "thread-state-abnormally-terminated?" #f 869 8 869 48 ()}
      {Lisp-Entry "thread-state-active-timeout" #f 870 8 870 40 ()}
      {Lisp-Entry "thread-state-active-waiting-for" #f 871 8 871 44 ()}
      {Lisp-Entry "thread-state-active?" #f 872 8 872 33 ()}
      {Lisp-Entry "thread-state-initialized?" #f 873 8 873 38 ()}
      {Lisp-Entry "thread-state-normally-terminated-result" #f 874 8 874 52 ()}
      {Lisp-Entry "thread-state-normally-terminated?" #f 875 8 875 46 ()}
      {Lisp-Entry "thread-state-uninitialized?" #f 876 8 876 40 ()}
      {Lisp-Entry "pristine-thread-continuation" #f 877 8 877 41 ()}
      {Lisp-Entry "mutex?" #f 878 8 878 19 ()}
      {Lisp-Entry "make-mutex" #f 879 8 879 23 ()}
      {Lisp-Entry "mutex-name" #f 880 8 880 23 ()}
      {Lisp-Entry "mutex-specific" #f 881 8 881 27 ()}
      {Lisp-Entry "mutex-specific-set!" #f 882 8 882 32 ()}
      {Lisp-Entry "mutex-state" #f 883 8 883 24 ()}
      {Lisp-Entry "mutex-lock!" #f 884 8 884 24 ()}
      {Lisp-Entry "mutex-unlock!" #f 885 8 885 26 ()}
      {Lisp-Entry "mutex-wait" #f 886 8 886 23 ()}
      {Lisp-Entry "mutex-owner" #f 887 8 887 24 ()}
      {Lisp-Entry "condition?" #f 888 8 888 23 ()}
      {Lisp-Entry "make-condition" #f 889 8 889 27 ()}
      {Lisp-Entry "condition-name" #f 890 8 890 27 ()}
      {Lisp-Entry "condition-specific" #f 891 8 891 31 ()}
      {Lisp-Entry "condition-specific-set!" #f 892 8 892 36 ()}
      {Lisp-Entry "condition-signal!" #f 893 8 893 30 ()}
      {Lisp-Entry "condition-broadcast!" #f 894 8 894 33 ()}
      {Lisp-Entry "current-systime" #f 902 8 902 28 ()}
      {Lisp-Entry "systime?" #f 903 8 903 21 ()}
      {Lisp-Entry "systime->seconds" #f 904 8 904 29 ()}
      {Lisp-Entry "seconds->systime" #f 905 8 905 29 ()}
      {Lisp-Entry "process-times" #f 906 8 906 26 ()}
      {Lisp-Entry "cpu-time" #f 907 8 907 21 ()}
      {Lisp-Entry "real-time" #f 908 8 908 22 ()}
      {Lisp-Entry "unspecified" #f 916 8 916 24 ()}
      {Lisp-Entry "unspecified?" #f 917 8 917 25 ()}
      {Lisp-Entry "specified?" #f 918 8 918 23 ()}
      {Lisp-Entry "vector-copy" #f 926 8 926 24 ()}
      {Lisp-Entry "u8vector" #f 927 8 927 16 ()}
      {Lisp-Entry "make-u8vector" #f 928 8 928 21 ()}
      {Lisp-Entry "u8vector-length" #f 929 8 929 23 ()}
      {Lisp-Entry "u8vector-ref" #f 930 8 930 20 ()}
      {Lisp-Entry "u8vector-set!" #f 931 8 931 21 ()}
      {Lisp-Entry "u8vector?" #f 932 8 932 17 ()}
      {Lisp-Entry "u8vector->list" #f 933 8 933 22 ()}
      {Lisp-Entry "list->u8vector" #f 934 8 934 22 ()}
      {Lisp-Entry "u8vector->object" #f 935 8 935 24 ()}
      {Lisp-Entry "object->u8vector" #f 936 8 936 24 ()}
      {Lisp-Entry "u16vector" #f 937 8 937 17 ()}
      {Lisp-Entry "make-u16vector" #f 938 8 938 22 ()}
      {Lisp-Entry "u16vector-length" #f 939 8 939 24 ()}
      {Lisp-Entry "u16vector-ref" #f 940 8 940 21 ()}
      {Lisp-Entry "u16vector-set!" #f 941 8 941 22 ()}
      {Lisp-Entry "u16vector?" #f 942 8 942 18 ()}
      {Lisp-Entry "u32vector" #f 943 8 943 17 ()}
      {Lisp-Entry "make-u32vector" #f 944 8 944 22 ()}
      {Lisp-Entry "u32vector-length" #f 945 8 945 24 ()}
      {Lisp-Entry "u32vector-ref" #f 946 8 946 21 ()}
      {Lisp-Entry "u32vector-set!" #f 947 8 947 22 ()}
      {Lisp-Entry "u32vector?" #f 948 8 948 18 ()}
      {Lisp-Entry "f32vector" #f 949 8 949 17 ()}
      {Lisp-Entry "make-f32vector" #f 950 8 950 22 ()}
      {Lisp-Entry "f32vector-length" #f 951 8 951 24 ()}
      {Lisp-Entry "f32vector-ref" #f 952 8 952 21 ()}
      {Lisp-Entry "f32vector-set!" #f 953 8 953 22 ()}
      {Lisp-Entry "f32vector?" #f 954 8 954 18 ()}
      {Lisp-Entry "f64vector" #f 955 8 955 17 ()}
      {Lisp-Entry "make-f64vector" #f 956 8 956 22 ()}
      {Lisp-Entry "f64vector-length" #f 957 8 957 24 ()}
      {Lisp-Entry "f64vector-ref" #f 958 8 958 21 ()}
      {Lisp-Entry "f64vector-set!" #f 959 8 959 22 ()}
      {Lisp-Entry "f64vector?" #f 960 8 960 18 ()}
      {Lisp-Entry "new-walk-context" #f 968 8 968 29 ()}
      {Lisp-Entry "register-literal-constructor" #f 969 8 969 41 ()}
      {Lisp-Entry "specifier?" #f 970 8 970 23 ()}
      {Lisp-Entry "binding-specifier" #f 971 8 971 30 ()}
      {Lisp-Entry "parse-specifier" #f 972 8 972 28 ()}
      {Lisp-Entry "requested-module-name" #f 973 8 973 34 ()}
      {Lisp-Entry "requested-module-resource" #f 974 8 974 38 ()}}})
"_language"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "dialect" "language" "_language.jazz"} 1244896780
    {Lisp-Entry "jazz.dialect.language" #f 37 19 37 40 ("axis-find-in" "axis-find" "axis-for-each" "instantiate-ends-with?" "instantiate-starts-with?" "string-find-in" "instantiate-find-in" "string-find" "instantiate-find" "instantiate-butlast" "string-for-each" "instantiate-for-each" "jazz.dialect")
      {Lisp-Entry "nil" #f 48 12 48 15 ("nil" "'nil" "list")}
      {Lisp-Entry "nil?" #f 52 27 52 31 ("nil" "eq?" "obj")}
      {Lisp-Entry "not-nil?" #f 56 27 56 35 ("nil" "eq?" "not" "obj")}
      {Lisp-Entry "Object" #f 65 17 65 23 ("Object-Class")
        {Lisp-Entry "initialize" #f 68 19 68 29 ()}
        {Lisp-Entry "destroy" #f 72 19 72 26 ()}
        {Lisp-Entry "print" #f 76 26 76 31 ("print-detail" "function" "print-unreadable" "self" "object?" "if" "detail" "output")}
        {Lisp-Entry "print-detail" #f 85 21 85 33 ("write" "self" "display" ":human" "eq?" "if" "detail" "output")}
        {Lisp-Entry "fold-literal" #f 91 26 91 38 ("self" "error")}
        {Lisp-Entry "class-actions" #f 95 26 95 39 ()}
        {Lisp-Entry "focus-actions" #f 99 26 99 39 ()}
        {Lisp-Entry "guest-actions" #f 103 26 103 39 ()}
        {Lisp-Entry "initialized?" #f 107 18 107 30 ("self" "object-initialized?")}
        {Lisp-Entry "hash-object" #f 111 26 111 37 ("self" "error")}
        {Lisp-Entry "copy-object" #f 115 29 115 40 ("self" "error" "deep?")}
        {Lisp-Entry "compare-object" #f 119 26 119 40 (":incompatible" "object")}
        {Lisp-Entry "ci-compare-object" #f 123 26 123 43 (":incompatible" "object")}
        {Lisp-Entry "describe-object" #f 127 29 127 44 ("print" "printer")}
        {Lisp-Entry "release" #f 131 26 131 33 ()}
        {Lisp-Entry "close" #f 135 26 135 31 ("self" "call-destroy")}
        {Lisp-Entry "destroy-mandatory" #f 139 21 139 38 ("self" "set-must-destroy")}
        {Lisp-Entry "destroyed?" #f 143 18 143 28 ("self" "object-destroyed?")}
        {Lisp-Entry "get-sort-value" #f 147 26 147 40 ()}
        {Lisp-Entry "redirect-handler" #f 151 26 151 42 ("self" "sender" "handler")}
        {Lisp-Entry "coerce-string" #f 155 26 155 39 ("self" "error")}
        {Lisp-Entry "iterate-object" #f 159 26 159 40 ("self" "error")}
        {Lisp-Entry "object-similar?" #f 168 26 168 41 ("self" "eq?" "object")}
        {Lisp-Entry "object-alphabetic?" #f 172 26 172 44 ("self" "error")}
        {Lisp-Entry "object-numeric?" #f 176 26 176 41 ("self" "error")}
        {Lisp-Entry "object-alphanumeric?" #f 180 26 180 46 ("self" "error")}
        {Lisp-Entry "object-whitespace?" #f 184 26 184 44 ("self" "error")}
        {Lisp-Entry "object-upper-case?" #f 188 26 188 44 ("self" "error")}
        {Lisp-Entry "object-lower-case?" #f 192 26 192 44 ("self" "error")}
        {Lisp-Entry "object-upcase" #f 196 26 196 39 ("self" "error")}
        {Lisp-Entry "object-downcase" #f 200 26 200 41 ("self" "error")}
        {Lisp-Entry "object-capitalize" #f 204 26 204 43 ("self" "error")}}
      {Lisp-Entry "compare" #f 208 27 208 34 ("compare-object" ":equal" "eqv?" "if" "b" "a")}
      {Lisp-Entry "ci-compare" #f 214 27 214 37 ("ci-compare-object" ":equal" "eqv?" "if" "b" "a")}
      {Lisp-Entry "copy" #f 220 20 220 24 ("subcopy" "obj")}
      {Lisp-Entry "subcopy" #f 224 20 224 27 ("copy-object" "deep?" "obj")}
      {Lisp-Entry "native-class" #f 228 13 228 25 ("error" "name")}
      {Lisp-Entry "=-hash" #f 232 13 232 19 ("hash-object" "obj")}
      {Lisp-Entry "object-initialized?" #f 236 13 236 32 ("obj")}
      {Lisp-Entry "get-must-destroy" #f 241 13 241 29 ("obj")}
      {Lisp-Entry "set-must-destroy" #f 245 13 245 29 ("obj")}
      {Lisp-Entry "set-was-destroyed" #f 250 13 250 30 ("obj")}
      {Lisp-Entry "object-destroyed?" #f 255 13 255 30 ("obj")}
      {Lisp-Entry "destroy-mandatory" #f 260 20 260 37 ()}
      {Lisp-Entry "call-destroy" #f 265 13 265 25 ("set-was-destroyed" "destroy" "obj")}
      {Lisp-Entry "Type" #f 275 7 275 11 ("Object")}
      {Lisp-Entry "Category" #f 283 7 283 15 ("Type")
        {Lisp-Entry "name" #f 286 8 286 12 ("generate")}
        {Lisp-Entry "fields" #f 287 8 287 14 ("generate")}
        {Lisp-Entry "virtual-size" #f 288 8 288 20 ("generate")}
        {Lisp-Entry "ancestors" #f 289 8 289 17 ("generate")}
        {Lisp-Entry "descendants" #f 290 8 290 19 ("generate")}
        {Lisp-Entry "print" #f 293 11 293 16 ("get-name" "format" "function" "self" "print-unreadable" "detail" "output")}}
      {Lisp-Entry "Class" #f 304 7 304 12 ("Category")
        {Lisp-Entry "ascendant" #f 307 8 307 17 ("generate")}
        {Lisp-Entry "interfaces" #f 308 8 308 18 ("generate")}
        {Lisp-Entry "slots" #f 309 8 309 13 ("generate")}
        {Lisp-Entry "instance-size" #f 310 8 310 21 ("generate")}
        {Lisp-Entry "level" #f 311 8 311 13 ("generate")}
        {Lisp-Entry "dispatch-table" #f 312 8 312 22 ("generate")}
        {Lisp-Entry "core-method-alist" #f 313 8 313 25 ("generate")}
        {Lisp-Entry "core-virtual-alist" #f 314 8 314 26 ("generate")}
        {Lisp-Entry "core-virtual-names" #f 315 8 315 26 ("generate")}
        {Lisp-Entry "core-vtable" #f 316 8 316 19 ("generate")}
        {Lisp-Entry "class-table" #f 317 8 317 19 ("generate")}
        {Lisp-Entry "interface-table" #f 318 8 318 23 ("generate")}
        {Lisp-Entry "coerce-object" #f 321 26 321 39 ("self" "type-name" "error" "obj")}
        {Lisp-Entry "external-name" #f 325 26 325 39 ("self" "type-name" "error" "when" "error?" "error?:")}}
      {Lisp-Entry "Object-Class" #f 330 7 330 19 ("Class")}
      {Lisp-Entry "class?" #f 333 27 333 33 ("Class" "is?" "obj")}
      {Lisp-Entry "coerce" #f 337 27 337 33 ("coerce-object" "class" "object")}
      {Lisp-Entry "allocate" #f 341 20 341 28 ("call-into-abstract" "size" "class")}
      {Lisp-Entry "Interface" #f 350 7 350 16 ("Category")
        {Lisp-Entry "ascendants" #f 353 8 353 18 ("generate")}
        {Lisp-Entry "rank" #f 354 8 354 12 ("generate")}}
      {Lisp-Entry "Field" #f 362 7 362 12 ("Object")
        {Lisp-Entry "name" #f 365 8 365 12 ("generate")}}
      {Lisp-Entry "category-field" #f 368 20 368 34 ("find-field" "field-name" "category")}
      {Lisp-Entry "all-slots" #f 372 20 372 29 ("get-slots" "model")}
      {Lisp-Entry "Method" #f 381 7 381 13 ("Field")
        {Lisp-Entry "dispatch-type" #f 384 8 384 21 ("generate")}
        {Lisp-Entry "implementation" #f 385 8 385 22 ("generate")}
        {Lisp-Entry "implementation-tree" #f 386 8 386 27 ("generate")}
        {Lisp-Entry "category-rank" #f 387 8 387 21 ("generate")}
        {Lisp-Entry "implementation-rank" #f 388 8 388 27 ("generate")}}
      {Lisp-Entry "object-method" #f 392 20 392 33 ("apply" "rest" "function" "class-of" "find-field" "get-implementation" "impl" "let" "name" "object")}
      {Lisp-Entry "Generic" #f 403 7 403 14 ("Object")
        {Lisp-Entry "locator" #f 406 8 406 15 ("generate")}
        {Lisp-Entry "name" #f 407 8 407 12 ("generate")}
        {Lisp-Entry "root-specific" #f 408 8 408 21 ("generate")}
        {Lisp-Entry "pending-specifics" #f 409 8 409 25 ("generate")}}
      {Lisp-Entry "Specific" #f 412 7 412 15 ("Object")
        {Lisp-Entry "dynamic-signature" #f 415 8 415 25 ("generate")}
        {Lisp-Entry "implementation" #f 416 8 416 22 ("generate")}
        {Lisp-Entry "ancestor-specifics" #f 417 8 417 26 ("generate")}
        {Lisp-Entry "descendant-specifics" #f 418 8 418 28 ("generate")}}
      {Lisp-Entry "Boolean-Class" #f 426 7 426 20 ("Class")}
      {Lisp-Entry "Boolean" #f 429 17 429 24 ("Object" "Boolean-Class")
        {Lisp-Entry "initialize" #f 432 11 432 21 ("native-class" "rest")}}
      {Lisp-Entry "/=" #f 436 27 436 29 ("=" "not" "y" "x")}
      {Lisp-Entry "neq?" #f 440 27 440 31 ("eq?" "not" "y" "x")}
      {Lisp-Entry "xor" #f 444 27 444 30 ("not" "and" "or" "y" "x")}
      {Lisp-Entry "nu=?" #f 449 20 449 24 ("cdr" "else" "car" "neq?" "null?" "cond" "scan" "iter" "first" "let" ":equal" "compare" "eq?" "and" "rest" "m" "n")}
      {Lisp-Entry "nu/=?" #f 461 20 461 25 ("nu=?" "apply" "not" ":equal" "compare" "neq?" "null?" "if" "rest" "m" "n")}
      {Lisp-Entry "nu<?" #f 467 20 467 24 ("cdr" "car" "value" "null?" "if" "max" "scan" "iter" "let" "error" "else" ":equal" ":greater" ":less" "compare" "case" "and" "rest" "m" "n")}
      {Lisp-Entry "nu<=?" #f 482 20 482 25 ("cdr" "car" "value" "null?" "if" "max" "scan" "iter" "let" "error" "else" ":greater" ":equal" ":less" "compare" "case" "and" "rest" "m" "n")}
      {Lisp-Entry "nu>?" #f 497 20 497 24 ("cdr" "car" "value" "null?" "if" "min" "scan" "iter" "let" "error" "else" ":equal" ":less" ":greater" "compare" "case" "and" "rest" "m" "n")}
      {Lisp-Entry "nu>=?" #f 512 20 512 25 ("cdr" "car" "value" "null?" "if" "min" "scan" "iter" "let" "error" "else" ":less" ":equal" ":greater" "compare" "case" "and" "rest" "m" "n")}
      {Lisp-Entry "ci=?" #f 527 20 527 24 ("finally" "return" ":equal" "ci-compare" "neq?" "when" "cdr" "in" "object" "for" "loop" "car" "first" "let" "null?" "if" "rest")}
      {Lisp-Entry "ci/=?" #f 537 20 537 25 ("ci=?" "apply" "not" "rest")}
      {Lisp-Entry "ci<?" #f 541 20 541 24 ("error" "else" ":equal" ":greater" "cdr" ":less" "ci-compare" "case" "car" "value" "null?" "if" "max" "scan" "iter" "let" "rest" "n")}
      {Lisp-Entry "ci<=?" #f 552 20 552 25 ("error" "else" ":greater" "cdr" ":equal" ":less" "ci-compare" "case" "car" "value" "null?" "if" "max" "scan" "iter" "let" "rest" "n")}
      {Lisp-Entry "ci>?" #f 563 20 563 24 ("error" "else" ":equal" ":less" "cdr" ":greater" "ci-compare" "case" "car" "value" "null?" "if" "min" "scan" "iter" "let" "rest" "n")}
      {Lisp-Entry "ci>=?" #f 574 20 574 25 ("error" "else" ":less" "cdr" ":equal" ":greater" "ci-compare" "case" "car" "value" "null?" "if" "min" "scan" "iter" "let" "rest" "n")}
      {Lisp-Entry "boolean->integer" #f 585 27 585 43 ("0" "1" "if" "bool")}
      {Lisp-Entry "integer->boolean" #f 589 27 589 43 ("0" "/=" "n")}
      {Lisp-Entry "Whitespace-Chars" #f 598 12 598 28 ()}
      {Lisp-Entry "Uppercase-Chars" #f 601 12 601 27 ()}
      {Lisp-Entry "Lowercase-Chars" #f 604 12 604 27 ()}
      {Lisp-Entry "Alphabetic-Chars" #f 607 12 607 28 ("Lowercase-Chars" "Uppercase-Chars" "append")}
      {Lisp-Entry "Numeric-Chars" #f 610 12 610 25 ()}
      {Lisp-Entry "Uppercase-Lowerbound" #f 614 12 614 32 ("char->integer")}
      {Lisp-Entry "Uppercase-Upperbound" #f 617 12 617 32 ("char->integer")}
      {Lisp-Entry "Lowercase-Lowerbound" #f 620 12 620 32 ("char->integer")}
      {Lisp-Entry "Lowercase-Upperbound" #f 623 12 623 32 ("char->integer")}
      {Lisp-Entry "Numeric-Lowerbound" #f 626 12 626 30 ("char->integer")}
      {Lisp-Entry "Numeric-Upperbound" #f 629 12 629 30 ("char->integer")}
      {Lisp-Entry "Char-Class" #f 633 7 633 17 ("Class")}
      {Lisp-Entry "Char" #f 636 17 636 21 ("Object" "Char-Class")
        {Lisp-Entry "initialize" #f 639 11 639 21 ("native-class" "rest")}
        {Lisp-Entry "coerce-string" #f 643 11 643 24 ("get-output-string" "self" "write-char" "open-output-string" "port" "let")}
        {Lisp-Entry "compare-object" #f 649 11 649 25 (":incompatible" ":less" "else" ":greater" ">" ":equal" "=" "cond" "v2" "self" "char->integer" "v1" "let" "Char" "is?" "if" "c")}
        {Lisp-Entry "ci-compare-object" #f 659 11 659 28 ("self" "downcase" "compare" "c")}
        {Lisp-Entry "object-similar?" #f 664 11 664 26 ("self" "char-similar?" "char?" "and" "object-similar?" "'object-similar?" "unimplemented" "object")}
        {Lisp-Entry "object-alphabetic?" #f 671 11 671 29 ("object-lower-case?" "object-upper-case?" "or")}
        {Lisp-Entry "object-numeric?" #f 676 11 676 26 ("Numeric-Upperbound" "<=" "Numeric-Lowerbound" ">=" "and" "self" "char->integer" "n" "let")}
        {Lisp-Entry "object-alphanumeric?" #f 682 11 682 31 ("object-numeric?" "object-alphabetic?" "or")}
        {Lisp-Entry "object-whitespace?" #f 687 11 687 29 ("self" "eqv?" "or")}
        {Lisp-Entry "object-upper-case?" #f 694 11 694 29 ("Uppercase-Upperbound" "<=" "Uppercase-Lowerbound" ">=" "and" "self" "char->integer" "n" "let")}
        {Lisp-Entry "object-lower-case?" #f 700 11 700 29 ("Lowercase-Upperbound" "<=" "Lowercase-Lowerbound" ">=" "and" "self" "char->integer" "n" "let")}
        {Lisp-Entry "object-upcase" #f 706 11 706 24 ("32" "char->integer" "-" "integer->char" "self" "lower-case?" "if")}
        {Lisp-Entry "object-downcase" #f 712 11 712 26 ("32" "char->integer" "+" "integer->char" "self" "upper-case?" "if")}
        {Lisp-Entry "object-capitalize" #f 718 11 718 28 ("object-upcase")}}
      {Lisp-Entry "whitechar?" #f 722 12 722 22 ("char-whitespace?")}
      {Lisp-Entry "char-presentation" #f 726 20 726 37 ("string" "char-symbol" "or" "char")}
      {Lisp-Entry "alphabetic?" #f 731 27 731 38 ("object-alphabetic?" "object")}
      {Lisp-Entry "numeric?" #f 735 27 735 35 ("object-numeric?" "object")}
      {Lisp-Entry "alphanumeric?" #f 739 27 739 40 ("object-alphanumeric?" "object")}
      {Lisp-Entry "whitespace?" #f 743 27 743 38 ("object-whitespace?" "object")}
      {Lisp-Entry "upper-case?" #f 747 27 747 38 ("object-upper-case?" "object")}
      {Lisp-Entry "lower-case?" #f 751 27 751 38 ("object-lower-case?" "object")}
      {Lisp-Entry "upcase" #f 755 27 755 33 ("object-upcase" "object")}
      {Lisp-Entry "downcase" #f 759 27 759 35 ("object-downcase" "object")}
      {Lisp-Entry "capitalize" #f 763 27 763 37 ("object-capitalize" "object")}
      {Lisp-Entry "vowel?" #f 767 20 767 26 ("downcase" "memv?" "c")}
      {Lisp-Entry "character-types" #f 771 12 771 27 ("symbol" "literal" "quasiquote" "backslash" "reference" "exprcomment" "comment" "unquote" "terminator" "list" "quote" "sharp" "string" "constituent" "whitespace" "invalid" "#")}
      {Lisp-Entry "character-type" #f 790 20 790 34 ("character-types" "vector-ref" "constituent" "'constituent" "127" ">" "if" "char->integer" "num" "let" "ascii-c")}
      {Lisp-Entry "scheme-constituent?" #f 797 13 797 32 ("eqv?" "constituent" "'constituent" "character-type" "eq?" "alphanumeric?" "or" "c")}
      {Lisp-Entry "jazz-constituent?" #f 804 13 804 30 ("eqv?" "constituent" "'constituent" "character-type" "eq?" "alphanumeric?" "or" "c")}
      {Lisp-Entry "c-constituent?" #f 810 13 810 27 ("eqv?" "alphanumeric?" "or" "c")}
      {Lisp-Entry "sql-constituent?" #f 815 13 815 29 ("eqv?" "alphanumeric?" "or" "c")}
      {Lisp-Entry "Diacritic-Equivalences" #f 830 12 830 34 ()}
      {Lisp-Entry "make-diacritic-table" #f 839 13 839 33 ("table-set!" "char" "function" "for-each" "eqv?" "test:" "make-table" "table" "let" "equivalences")}
      {Lisp-Entry "Diacritic-Table" #f 848 12 848 27 ("Diacritic-Equivalences" "make-diacritic-table")}
      {Lisp-Entry "di=?" #f 852 13 852 17 ("Diacritic-Table" "table-ref" "memv?" "ci=?" "or" "y" "x")}
      {Lisp-Entry "string-di=?" #f 857 13 857 24 ("di=?" "every" "b" "in-sequence" "a" "for" "loop" "string-length" "=" "and" "y" "x")}
      {Lisp-Entry "*exception-debugger*" #f 869 12 869 32 ()}
      {Lisp-Entry "get-exception-debugger" #f 873 13 873 35 ("*exception-debugger*")}
      {Lisp-Entry "set-exception-debugger" #f 876 13 876 35 ("*exception-debugger*" "set!" "exception-debugger")}
      {Lisp-Entry "current-exception-debugger" #f 880 12 880 38 ("make-parameter")}
      {Lisp-Entry "exception-debugger-hook" #f 884 13 884 36 ("system-exception-hook" "if" "*exception-debugger*" "current-exception-debugger" "either" "exception-debugger" "let" "other" "exc")}
      {Lisp-Entry "with-exception-debugger" #f 891 13 891 36 ("current-exception-debugger" "parameterize" "thunk" "exception-debugger")}
      {Lisp-Entry "system-exception-debugger" #f 896 13 896 38 ("system-exception-hook" "invoke-exception-hook" "exc")}
      {Lisp-Entry "with-system-exception-debugger" #f 900 13 900 43 ("system-exception-debugger" "with-exception-debugger" "thunk")}
      {Lisp-Entry "Exception" #f 905 7 905 16 ("Object")
        {Lisp-Entry "get-message" #f 908 26 908 37 ()}
        {Lisp-Entry "present-message" #f 912 26 912 41 ("get-message" "list" "rest")}
        {Lisp-Entry "print" #f 916 11 916 16 ("get-message" "format" "function" "self" "print-unreadable" "readably" "printer")}}
      {Lisp-Entry "Exception-Detail" #f 922 7 922 23 ("Object")
        {Lisp-Entry "icon" #f 925 8 925 12 ("generate")}
        {Lisp-Entry "title" #f 926 8 926 13 ("generate")}
        {Lisp-Entry "location" #f 927 8 927 16 ("generate")}
        {Lisp-Entry "children" #f 928 8 928 16 ("generate")}
        {Lisp-Entry "initialize" #f 931 11 931 21 ("set-children" "set-location" "set-title" "set-icon" "nextmethod" "children" "location" "title" "icon")}
        {Lisp-Entry "fold-literal" #f 939 11 939 23 ("children" ",children" "',children" "location" ",location" "',location" "title" ",title" "',title" "icon" ",icon" "',icon" "Exception-Detail" "new")}
        {Lisp-Entry "print" #f 943 11 943 16 ("children" "location" "title" "icon" "self" "class-of" "type-name" "identifier-name" "format" "readably" "printer")}}
      {Lisp-Entry "Continue" #f 952 7 952 15 ("Exception")}
      {Lisp-Entry "Error" #f 955 7 955 12 ("Exception")
        {Lisp-Entry "message" #f 958 8 958 15 ("generate")}
        {Lisp-Entry "initialize" #f 961 11 961 21 ("set-message" "nextmethod" "message" "message:")}}
      {Lisp-Entry "Read-Error" #f 966 7 966 17 ("Error")
        {Lisp-Entry "source" #f 969 8 969 14 ()}
        {Lisp-Entry "start" #f 970 8 970 13 ()}
        {Lisp-Entry "end" #f 971 8 971 11 ()}
        {Lisp-Entry "initialize" #f 974 11 974 21 ("end~self" "start~self" "source~self" "set!" "nextmethod" "apply" "others" "end" "start" "source" "bind-keywords" "rest")}
        {Lisp-Entry "get-source" #f 982 18 982 28 ("source")}
        {Lisp-Entry "get-start" #f 986 18 986 27 ("start")}
        {Lisp-Entry "get-end" #f 990 18 990 25 ("end")}
        {Lisp-Entry "get-range" #f 994 18 994 27 ("end" "start" "Range" "new")}}
      {Lisp-Entry "Parse-Error" #f 998 7 998 18 ("Error")
        {Lisp-Entry "source" #f 1001 8 1001 14 ()}
        {Lisp-Entry "start" #f 1002 8 1002 13 ()}
        {Lisp-Entry "end" #f 1003 8 1003 11 ()}
        {Lisp-Entry "initialize" #f 1006 11 1006 21 ("end~self" "start~self" "source~self" "set!" "nextmethod" "apply" "others" "end" "start" "source" "bind-keywords" "rest")}
        {Lisp-Entry "get-source" #f 1014 18 1014 28 ("source")}
        {Lisp-Entry "get-start" #f 1018 18 1018 27 ("start")}
        {Lisp-Entry "get-end" #f 1022 18 1022 25 ("end")}}
      {Lisp-Entry "Convertion-Error" #f 1026 7 1026 23 ("Parse-Error")
        {Lisp-Entry "object" #f 1029 8 1029 14 ()}
        {Lisp-Entry "type" #f 1030 8 1030 12 ()}
        {Lisp-Entry "initialize" #f 1033 11 1033 21 ("type~self" "object~self" "set!" "nextmethod" "apply" "others" "type" "object" "bind-keywords" "rest")}
        {Lisp-Entry "get-object" #f 1040 18 1040 28 ("object")}
        {Lisp-Entry "get-type" #f 1044 18 1044 26 ("type")}
        {Lisp-Entry "get-message" #f 1048 11 1048 22 ("format-gender" "object" "format" "type-name" "string?" "if" "type" "let")}}
      {Lisp-Entry "Signal" #f 1056 7 1056 13 ("Exception")}
      {Lisp-Entry "Cancel-Signal" #f 1059 7 1059 20 ("Signal")}
      {Lisp-Entry "call-with-catch" #f 1062 13 1062 28 ("is?" "object?" "and" "exception" "function" "with-exception-filter" "thunk" "catcher" "type")}
      {Lisp-Entry "throw" #f 1078 20 1078 25 ("raise" "exception")}
      {Lisp-Entry "throw-cancel" #f 1082 27 1082 39 ("Cancel-Signal" "new" "throw")}
      {Lisp-Entry "signal" #f 1086 12 1086 18 ("throw")}
      {Lisp-Entry "error" #f 1089 13 1089 18 ("format" "apply" "message:" "Error" "new" "signal" "rest")}
      {Lisp-Entry "Restart" #f 1098 7 1098 14 ("Object")
        {Lisp-Entry "name" #f 1101 8 1101 12 ("generate")}
        {Lisp-Entry "message" #f 1102 8 1102 15 ("generate")}
        {Lisp-Entry "handler" #f 1103 8 1103 15 ("generate")}
        {Lisp-Entry "initialize" #f 1106 11 1106 21 ("handler~self" "message~self" "name~self" "set!" "nextmethod" "handler" "message" "name")}
        {Lisp-Entry "print" #f 1113 11 1113 16 ("name" "format" "function" "self" "print-unreadable" "readably" "printer")}}
      {Lisp-Entry "current-restarts" #f 1120 12 1120 28 ("make-parameter")}
      {Lisp-Entry "with-restart-handler" #f 1124 13 1124 33 ("Restart" "new" "cons" "current-restarts" "parameterize" "thunk" "handler" "message" "name")}
      {Lisp-Entry "with-restart-catcher" #f 1129 13 1129 33 ("else" "car" "null?" "not" "cond" "continuation-return" "rest" "with-restart-handler" "catcher-cont" "function" "continuation-capture" "thunk" "catcher" "message" "name")}
      {Lisp-Entry "find-restart" #f 1141 20 1141 32 ("current-restarts" "get-name" "eq?" "restart" "function" "find-if" "name")}
      {Lisp-Entry "find-restarts" #f 1147 20 1147 33 ("current-restarts" "get-name" "eq?" "restart" "function" "collect-if" "name")}
      {Lisp-Entry "invoke-restart" #f 1153 13 1153 27 ("apply" "get-handler" "handler" "let" "rest" "restart")}
      {Lisp-Entry "Walk-Location" #f 1163 7 1163 20 ("Object")
        {Lisp-Entry "module-locator" #f 1166 8 1166 22 ("generate")}
        {Lisp-Entry "declaration-locator" #f 1167 8 1167 27 ("generate")}
        {Lisp-Entry "locat" #f 1168 8 1168 13 ("generate")}
        {Lisp-Entry "initialize" #f 1171 11 1171 21 ("locat~self" "declaration-locator~self" "module-locator~self" "set!" "nextmethod" "locat" "declaration-locator" "module-locator")}
        {Lisp-Entry "fold-literal" #f 1178 11 1178 23 ("locat" ",locat" "',locat" "declaration-locator" ",declaration-locator" "',declaration-locator" "module-locator" ",module-locator" "',module-locator" "Walk-Location" "new")}
        {Lisp-Entry "print" #f 1182 11 1182 16 ("locat" "declaration-locator" "module-locator" "self" "class-of" "type-name" "identifier-name" "format" "readably" "printer")}}
      {Lisp-Entry "Port-Class" #f 1195 7 1195 17 ("Class")}
      {Lisp-Entry "Port" #f 1198 17 1198 21 ("Object" "Port-Class")
        {Lisp-Entry "initialize" #f 1201 11 1201 21 ("native-class" "rest")}
        {Lisp-Entry "destroy" #f 1205 11 1205 18 ("nextmethod" "self" "close-port")}}
      {Lisp-Entry "Symbol-Class" #f 1215 7 1215 19 ("Class")}
      {Lisp-Entry "Symbol" #f 1218 17 1218 23 ("Object" "Symbol-Class")
        {Lisp-Entry "initialize" #f 1221 11 1221 21 ("native-class" "rest")}
        {Lisp-Entry "coerce-string" #f 1225 11 1225 24 ("self" "symbol->string")}
        {Lisp-Entry "compare-object" #f 1229 11 1229 25 (":incompatible" "self" "symbol->string" "compare" "symbol?" "if" "obj")}
        {Lisp-Entry "ci-compare-object" #f 1235 11 1235 28 (":incompatible" "self" "symbol->string" "ci-compare" "symbol?" "if" "obj")}}
      {Lisp-Entry "=" #f 1241 20 1241 21 ("eq?" "s2" "s1")}
      {Lisp-Entry "generated-symbol?" #f 1245 20 1245 37 ("symbol->string" "starts-with?" "symbol")}
      {Lisp-Entry "symbol->keyword" #f 1249 27 1249 42 ("symbol->string" "string->keyword" "symbol")}
      {Lisp-Entry "keyword->symbol" #f 1253 27 1253 42 ("keyword->string" "string->symbol" "keyword")}
      {Lisp-Entry "find-symbol" #f 1257 13 1257 24 ("string->symbol" "str")}
      {Lisp-Entry "symbol-bound?" #f 1262 13 1262 26 ("rest" "name")}
      {Lisp-Entry "symbol-unbound?" #f 1265 13 1265 28 ("rest" "name")}
      {Lisp-Entry "Keyword-Class" #f 1275 7 1275 20 ("Class")}
      {Lisp-Entry "Keyword" #f 1278 17 1278 24 ("Object" "Keyword-Class")
        {Lisp-Entry "initialize" #f 1281 11 1281 21 ("native-class" "rest")}}
      {Lisp-Entry "find-keyword" #f 1285 20 1285 32 ("specified?" "null?" "cdr" "cddr" "set-cdr!" "cadr" "set!" "begin" "eq?" "error" "car" "keyword?" "if" "elem" "not-null?" "unspecified?" "and" "while" "unspecified" "found" "unbox-list" "scan" "before" "let" "default" "box" "keyword")}
      {Lisp-Entry "Continuation-Class" #f 1312 7 1312 25 ("Class")}
      {Lisp-Entry "Continuation" #f 1315 17 1315 29 ("Object" "Continuation-Class")}
      {Lisp-Entry "Procedure-Class" #f 1323 7 1323 22 ("Class")}
      {Lisp-Entry "Procedure" #f 1326 17 1326 26 ("Object" "Procedure-Class")}
      {Lisp-Entry "Foreign-Class" #f 1334 7 1334 20 ("Class")}
      {Lisp-Entry "Foreign" #f 1337 17 1337 24 ("Object" "Foreign-Class")}
      {Lisp-Entry "Numeric-Class" #f 1345 7 1345 20 ("Class")}
      {Lisp-Entry "Numeric" #f 1348 17 1348 24 ("Object" "Numeric-Class")
        {Lisp-Entry "numeric-norm" #f 1351 35 1351 47 ()}
        {Lisp-Entry "numeric-add" #f 1352 35 1352 46 ("obj")}
        {Lisp-Entry "numeric-negate" #f 1353 35 1353 49 ()}
        {Lisp-Entry "numeric-multiply" #f 1354 35 1354 51 ("n")}
        {Lisp-Entry "numeric-inverse" #f 1355 35 1355 50 ()}}
      {Lisp-Entry "Number-Class" #f 1363 7 1363 19 ("Numeric-Class")}
      {Lisp-Entry "Number" #f 1366 17 1366 23 ("Numeric" "Number-Class")
        {Lisp-Entry "initialize" #f 1369 11 1369 21 ("native-class" "rest")}
        {Lisp-Entry "compare-object" #f 1373 11 1373 25 (":incompatible" ":greater" "else" ":less" "<" ":equal" "self" "=" "cond" "number?" "if" "obj")}
        {Lisp-Entry "ci-compare-object" #f 1381 11 1381 28 ("compare-object" "obj")}
        {Lisp-Entry "numeric-norm" #f 1385 11 1385 23 ("self" "abs")}
        {Lisp-Entry "numeric-add" #f 1389 11 1389 22 ("error" "self" "+" "number?" "if" "obj")}
        {Lisp-Entry "numeric-negate" #f 1395 11 1395 25 ("self" "-")}
        {Lisp-Entry "numeric-multiply" #f 1399 11 1399 27 ("error" "self" "*" "number?" "if" "obj")}
        {Lisp-Entry "numeric-inverse" #f 1405 11 1405 26 ("self" "/")}}
      {Lisp-Entry "Complex-Class" #f 1414 7 1414 20 ("Number-Class")}
      {Lisp-Entry "Complex" #f 1417 17 1417 24 ("Number" "Complex-Class")
        {Lisp-Entry "numeric-norm" #f 1420 11 1420 23 ("imag-part" "2" "self" "real-part" "expt" "+" "sqrt")}}
      {Lisp-Entry "Real-Class" #f 1429 7 1429 17 ("Complex-Class")}
      {Lisp-Entry "Real" #f 1432 17 1432 21 ("Complex" "Real-Class")}
      {Lisp-Entry "Rational-Class" #f 1440 7 1440 21 ("Real-Class")}
      {Lisp-Entry "Rational" #f 1443 17 1443 25 ("Real" "Rational-Class")}
      {Lisp-Entry "Integer-Class" #f 1451 7 1451 20 ("Rational-Class")}
      {Lisp-Entry "Integer" #f 1454 17 1454 24 ("Rational" "Integer-Class")}
      {Lisp-Entry "Fixnum-Class" #f 1462 7 1462 19 ("Integer-Class")}
      {Lisp-Entry "Fixnum" #f 1465 17 1465 23 ("Integer" "Fixnum-Class")}
      {Lisp-Entry "Flonum-Class" #f 1473 7 1473 19 ("Real-Class")}
      {Lisp-Entry "Flonum" #f 1476 17 1476 23 ("Real" "Flonum-Class")}
      {Lisp-Entry "fl+" #f 1481 27 1481 30 ("##fl+" "y" "x")}
      {Lisp-Entry "fl-" #f 1484 27 1484 30 ("##fl-" "y" "x")}
      {Lisp-Entry "fl*" #f 1487 27 1487 30 ("##fl*" "y" "x")}
      {Lisp-Entry "fl/" #f 1490 27 1490 30 ("##fl/" "y" "x")}
      {Lisp-Entry "relate" #f 1499 20 1499 26 ("0" "else" "1" ">" "-1" "<" "cond" "y" "x")}
      {Lisp-Entry "sign" #f 1505 20 1505 24 ("0" "relate" "n")}
      {Lisp-Entry "nu+" #f 1509 20 1509 23 ("numeric-add" "cdr" "scan" "car" "result" "iter" "let" "0" "null?" "if" "rest")}
      {Lisp-Entry "nu-" #f 1518 20 1518 23 ("nu+" "apply" "r" "let" "numeric-negate" "null?" "if" "rest" "n")}
      {Lisp-Entry "nu*" #f 1525 20 1525 23 ("numeric-multiply" "cdr" "scan" "car" "result" "iter" "let" "1" "null?" "if" "rest")}
      {Lisp-Entry "nu/" #f 1534 20 1534 23 ("nu*" "apply" "r" "let" "numeric-inverse" "null?" "if" "rest" "n")}
      {Lisp-Entry "minimum" #f 1541 20 1541 27 ("cdr" "set!" ":less" "apply-key" "eq?" "when" "object" "function" "for-each" "car" "min" "let" "compare" "compare:" "key" "key:" "lst")}
      {Lisp-Entry "maximum" #f 1550 20 1550 27 ("cdr" "set!" ":greater" "apply-key" "eq?" "when" "object" "function" "for-each" "car" "max" "let" "compare" "compare:" "key" "key:" "lst")}
      {Lisp-Entry "between?" #f 1559 20 1559 28 ("<=" ">=" "not" "or" "and" "upper" "lower" "n")}
      {Lisp-Entry "between" #f 1564 20 1564 27 ("else" ">" "<" "cond" "upper" "n" "lower")}
      {Lisp-Entry "in-interval?" #f 1570 20 1570 32 ("<" ">=" "and" "upper" "lower" "n")}
      {Lisp-Entry "norm" #f 1574 27 1574 31 ("numeric-norm" "x")}
      {Lisp-Entry "distance" #f 1578 20 1578 28 ("nu-" "norm" "end" "start")}
      {Lisp-Entry "near?" #f 1582 20 1582 25 ("nu-" "norm" "<=" "distance" "y" "x")}
      {Lisp-Entry "contiguous-range" #f 1586 20 1586 36 ("cons" "cdr" "continuation-return" "set!" "1" "+" "=" "if" "n" "for-each" "second" "car" "first" "let*" "return" "function" "continuation-capture" "not-null?" "when" "lst")}
      {Lisp-Entry "naturals" #f 1600 20 1600 28 ("collect" "below" "from" "n" "for" "loop" "upper" "lower")}
      {Lisp-Entry "lobyte" #f 1605 20 1605 26 ("#xFF" "bitwise-and" "word")}
      {Lisp-Entry "hibyte" #f 1609 20 1609 26 ("-8" "arithmetic-shift" "lobyte" "word")}
      {Lisp-Entry "make-word" #f 1613 20 1613 29 ("8" "arithmetic-shift" "bitwise-ior" "hi" "lo")}
      {Lisp-Entry "lochar" #f 1617 20 1617 26 ("#xFF" "#x80" "+" "bitwise-and" "-" "word")}
      {Lisp-Entry "hichar" #f 1621 20 1621 26 ("-8" "arithmetic-shift" "lochar" "word")}
      {Lisp-Entry "make-int" #f 1625 20 1625 28 ("16" "arithmetic-shift" "bitwise-ior" "hi" "lo")}
      {Lisp-Entry "loword" #f 1629 20 1629 26 ("#xFFFF" "bitwise-and" "dword")}
      {Lisp-Entry "hiword" #f 1633 20 1633 26 ("-16" "arithmetic-shift" "loword" "dword")}
      {Lisp-Entry "signed-loword" #f 1637 20 1637 33 ("#xFFFF" "#x8000" "+" "bitwise-and" "-" "dword")}
      {Lisp-Entry "signed-hiword" #f 1641 20 1641 33 ("-16" "arithmetic-shift" "signed-loword" "dword")}
      {Lisp-Entry "sign-word" #f 1645 20 1645 29 ("#x10000" "-" "15" "bit-set?" "if" "word")}
      {Lisp-Entry "separate" #f 1651 13 1651 21 ("values" "*" "-" "r" "quotient" "q" "let*" "int2" "int1")}
      {Lisp-Entry "randomize" #f 1657 13 1657 22 ("default-random-source" "random-source-randomize!")}
      {Lisp-Entry "random" #f 1660 12 1660 18 ("random-integer")}
      {Lisp-Entry "bit-set" #f 1663 13 1663 20 ("bitwise-not" "bitwise-and" "bitwise-ior" "if" "1" "arithmetic-shift" "msk" "let" "bit" "pos" "num")}
      {Lisp-Entry "mask-bit-set" #f 1670 13 1670 25 ("bitwise-not" "bitwise-and" "bitwise-ior" "if" "bit" "msk" "num")}
      {Lisp-Entry "mask-bit-set?" #f 1676 13 1676 26 ("0" "bitwise-and" "/=" "msk" "num")}
      {Lisp-Entry "bit-mask" #f 1680 20 1680 28 ("1" "arithmetic-shift" "-" "lo" "hi")}
      {Lisp-Entry "random-seed" #f 1684 20 1684 31 ("10000" "random" "randomize")}
      {Lisp-Entry "sqr" #f 1690 27 1690 30 ("2" "expt" "num")}
      {Lisp-Entry "percentage" #f 1694 27 1694 37 ("100." "/" "*" "total" "part")}
      {Lisp-Entry "percent" #f 1698 27 1698 34 ("100." "*" "/" "n" "percent")}
      {Lisp-Entry "fxfloor" #f 1702 27 1702 34 ("floor" "flonum->fixnum" "r")}
      {Lisp-Entry "fxceiling" #f 1705 27 1705 36 ("ceiling" "flonum->fixnum" "r")}
      {Lisp-Entry "fxtruncate" #f 1708 27 1708 37 ("truncate" "flonum->fixnum" "r")}
      {Lisp-Entry "fxround" #f 1711 27 1711 34 ("round" "flonum->fixnum" "r")}
      {Lisp-Entry "fxfloor/" #f 1717 20 1717 28 ("fl/" "fxfloor" "d" "n")}
      {Lisp-Entry "fxceiling/" #f 1720 20 1720 30 ("fl/" "fxceiling" "d" "n")}
      {Lisp-Entry "fxtruncate/" #f 1723 20 1723 31 ("fl/" "fxtruncate" "d" "n")}
      {Lisp-Entry "fxround/" #f 1726 20 1726 28 ("fl/" "fxround" "d" "n")}
      {Lisp-Entry "Iterator" #f 1735 7 1735 15 ("Object")
        {Lisp-Entry "Empty" #f 1738 14 1738 19 ("empty")}
        {Lisp-Entry "peeked" #f 1742 8 1742 14 ("Empty")}
        {Lisp-Entry "iterate-object" #f 1745 11 1745 25 ("self")}
        {Lisp-Entry "get-next" #f 1749 26 1749 34 ("next" "peek" "prog1")}
        {Lisp-Entry "peek" #f 1754 26 1754 30 ("next" "set!" "Empty" "peeked" "eq?" "when")}
        {Lisp-Entry "unget" #f 1760 26 1760 31 ("error" "set!" "Empty" "peeked" "eq?" "if" "object")}
        {Lisp-Entry "next" #f 1766 26 1766 30 ("get-next!" "else" "set!" "prog1" "Empty" "neq?" "peeked" "eof-object?" "cond")}
        {Lisp-Entry "done?" #f 1776 26 1776 31 ("peek" "eof-object?")}
        {Lisp-Entry "get-next!" #f 1780 26 1780 35 ()}
        {Lisp-Entry "put" #f 1784 26 1784 29 ("error" "object")}
        {Lisp-Entry "get-position" #f 1788 26 1788 38 ("self" "error")}
        {Lisp-Entry "set-position" #f 1792 26 1792 38 ("self" "error" "pos")}
        {Lisp-Entry "get-state" #f 1796 26 1796 35 ()}
        {Lisp-Entry "reset-state" #f 1800 26 1800 37 ("old")}}
      {Lisp-Entry "iterate-sequence" #f 1804 27 1804 43 ("iterate-object" "obj")}
      {Lisp-Entry "Explorer" #f 1813 7 1813 15 ("Iterator")
        {Lisp-Entry "direction" #f 1816 8 1816 17 ("forward" "'forward")}
        {Lisp-Entry "peek-forward" #f 1819 29 1819 41 ("error")}
        {Lisp-Entry "peek-backward" #f 1823 29 1823 42 ("error")}
        {Lisp-Entry "peek" #f 1827 11 1827 15 ("peek-backward" "backward" "peek-forward" "forward" "direction" "case" "eof-object" "done?" "if")}
        {Lisp-Entry "goto-beginning" #f 1835 26 1835 40 ("error")}
        {Lisp-Entry "goto-end" #f 1839 26 1839 34 ("error")}
        {Lisp-Entry "forward" #f 1843 26 1843 33 ("error")}
        {Lisp-Entry "backward" #f 1847 26 1847 34 ("error")}
        {Lisp-Entry "next" #f 1851 11 1851 15 ("backward" "forward" "direction" "case" "done?" "not" "when")}
        {Lisp-Entry "done-forward?" #f 1858 29 1858 42 ("error")}
        {Lisp-Entry "done-backward?" #f 1862 29 1862 43 ("error")}
        {Lisp-Entry "done?" #f 1866 11 1866 16 ("done-backward?" "backward" "done-forward?" "forward" "direction" "case")}
        {Lisp-Entry "put-forward" #f 1872 29 1872 40 ("error" "object")}
        {Lisp-Entry "put-backward" #f 1876 29 1876 41 ("error" "object")}
        {Lisp-Entry "put" #f 1880 11 1880 14 ("put-backward" "backward" "put-forward" "forward" "direction" "case" "object")}
        {Lisp-Entry "set-direction" #f 1886 18 1886 31 ("direction" "set!" "dir")}}
      {Lisp-Entry "explore" #f 1890 20 1890 27 ("Sequence-Explorer" "new" "apply" "rest" "object")}
      {Lisp-Entry "Sequence-Class" #f 1900 7 1900 21 ("Class")
        {Lisp-Entry "allocate-sequence" #f 1903 35 1903 52 ("len")}
        {Lisp-Entry "coerce-object" #f 1906 11 1906 24 ("element" "set-element!" "below" "0" "from" "n" "for" "loop" "allocate-sequence" "new-sequence" "cardinality" "len" "let" "seq")}}
      {Lisp-Entry "Sequence" #f 1915 17 1915 25 ("Object" "Sequence-Class")
        {Lisp-Entry "compare-object" #f 1918 11 1918 25 (":incompatible" "1" "+" "neq?" "element" "compare" "cmp" ":less" "else" ":greater" ">" ":equal" "=" "cond" ">=" "or" "0" "i" "iter" "l2" "self" "cardinality" "l1" "let" "Sequence" "is?" "if" "seq")}
        {Lisp-Entry "copy-object" #f 1934 11 1934 22 ("1" "+" "element" "set-element!" "begin" "=" "0" "i" "iter" "let" "class-of" "allocate-sequence" "new-seq" "self" "cardinality" "len" "copy" "x" "function" "if" "subcopy" "let*" "deep?")}
        {Lisp-Entry "iterate-object" #f 1946 11 1946 25 ("self" "Sequence-Explorer" "new")}
        {Lisp-Entry "object-alphabetic?" #f 1950 11 1950 29 ("self" "alphabetic?" "every?")}
        {Lisp-Entry "object-numeric?" #f 1954 11 1954 26 ("self" "numeric?" "every?")}
        {Lisp-Entry "object-alphanumeric?" #f 1958 11 1958 31 ("self" "alphanumeric?" "every?")}
        {Lisp-Entry "object-whitespace?" #f 1962 11 1962 29 ("self" "whitespace?" "every?")}
        {Lisp-Entry "object-upper-case?" #f 1966 11 1966 29 ("self" "upper-case?" "every?")}
        {Lisp-Entry "object-lower-case?" #f 1970 11 1970 29 ("self" "lower-case?" "every?")}
        {Lisp-Entry "object-upcase" #f 1974 11 1974 24 ("class-of" "upcase" "self" "accumulate")}
        {Lisp-Entry "object-downcase" #f 1978 11 1978 26 ("class-of" "downcase" "self" "accumulate")}
        {Lisp-Entry "object-capitalize" #f 1982 11 1982 28 ("class-of" "upcase" "set!" "not" "alphanumeric?" "if" "object" "function" "self" "accumulate" "break?" "let")}
        {Lisp-Entry "sequence-element" #f 1996 35 1996 51 ("n")}
        {Lisp-Entry "sequence-set-element!" #f 1999 35 1999 56 ("obj" "n")}
        {Lisp-Entry "sequence-cardinality" #f 2002 35 2002 55 ()}
        {Lisp-Entry "sequence-tail" #f 2005 35 2005 48 ("start")}
        {Lisp-Entry "sequence-last" #f 2008 35 2008 48 ()}
        {Lisp-Entry "sequence-butlast" #f 2011 35 2011 51 ()}
        {Lisp-Entry "sequence-subseq!" #f 2014 26 2014 42 ("cardinality" "-" "Subseq" "new" "self" "-1" "0" "=" "and" "if" "end" "start")}
        {Lisp-Entry "sequence-replace-subseq!" #f 2020 26 2020 50 ("cardinality" "0" "self" "subseq" "concatenate!" "replacement" "end" "start")}}
      {Lisp-Entry "sequence?" #f 2026 27 2026 36 ("Sequence" "is?" "seq")}
      {Lisp-Entry "element" #f 2030 27 2030 34 ("sequence-element" "n" "seq")}
      {Lisp-Entry "set-element!" #f 2034 27 2034 39 ("sequence-set-element!" "obj" "n" "seq")}
      {Lisp-Entry "cardinality" #f 2038 27 2038 38 ("sequence-cardinality" "seq")}
      {Lisp-Entry "empty?" #f 2042 27 2042 33 ("cardinality" "0" "=" "seq")}
      {Lisp-Entry "tail" #f 2046 27 2046 31 ("sequence-tail" "start" "seq")}
      {Lisp-Entry "last" #f 2050 27 2050 31 ("sequence-last" "seq")}
      {Lisp-Entry "butlast" #f 2054 27 2054 34 ("sequence-butlast" "seq")}
      {Lisp-Entry "skip-whitespace" #f 2058 20 2058 35 ("else" "1" "+" "element" "eq?" "cardinality" "=" "cond" "0" "either" "i" "iter" "let" "start" "start:" "seq")}
      {Lisp-Entry "subseq" #f 2065 20 2065 26 ("1" "+" "set!" "element" "set-element!" "<" "while" "j" "0" "i" "allocate-sequence" "sub" "class-of" "cls" "cardinality" "either" "-" "len" "let*" "type" "end" "start" "seq")}
      {Lisp-Entry "replace-subseq!" #f 2078 27 2078 42 ("sequence-replace-subseq!" "replacement" "end" "start" "seq")}
      {Lisp-Entry "subseq!" #f 2082 20 2082 27 ("sequence-subseq!" "cardinality" "end" "start" "seq")}
      {Lisp-Entry "sort" #f 2086 20 2086 24 ("class-of" "List" "sort" "coerce" "null/pair?" "let*" "cddr" "or" "split" "cdr" "cons" "apply-key" "if" "e2" "car" "e1" "let" "else" "null?" "cond" "l2" "l1" "merge" "merge-sort" "smaller" "l" "sort-list" "define" "key" "key:" "seq" "test")}
      {Lisp-Entry "first" #f 2117 27 2117 32 ("0" "element" "seq")}
      {Lisp-Entry "second" #f 2118 27 2118 33 ("1" "element" "seq")}
      {Lisp-Entry "third" #f 2119 27 2119 32 ("2" "element" "seq")}
      {Lisp-Entry "fourth" #f 2120 27 2120 33 ("3" "element" "seq")}
      {Lisp-Entry "fifth" #f 2121 27 2121 32 ("4" "element" "seq")}
      {Lisp-Entry "sixth" #f 2122 27 2122 32 ("5" "element" "seq")}
      {Lisp-Entry "seventh" #f 2123 27 2123 34 ("6" "element" "seq")}
      {Lisp-Entry "eighth" #f 2124 27 2124 33 ("7" "element" "seq")}
      {Lisp-Entry "ninth" #f 2125 27 2125 32 ("8" "element" "seq")}
      {Lisp-Entry "tenth" #f 2126 27 2126 32 ("9" "element" "seq")}
      {Lisp-Entry "set-first!" #f 2128 27 2128 37 ("0" "set-element!" "value" "seq")}
      {Lisp-Entry "set-second!" #f 2129 27 2129 38 ("1" "set-element!" "value" "seq")}
      {Lisp-Entry "set-third!" #f 2130 27 2130 37 ("2" "set-element!" "value" "seq")}
      {Lisp-Entry "set-fourth!" #f 2131 27 2131 38 ("3" "set-element!" "value" "seq")}
      {Lisp-Entry "set-fifth!" #f 2132 27 2132 37 ("4" "set-element!" "value" "seq")}
      {Lisp-Entry "set-sixth!" #f 2133 27 2133 37 ("5" "set-element!" "value" "seq")}
      {Lisp-Entry "set-seventh!" #f 2134 27 2134 39 ("6" "set-element!" "value" "seq")}
      {Lisp-Entry "set-eighth!" #f 2135 27 2135 38 ("7" "set-element!" "value" "seq")}
      {Lisp-Entry "set-ninth!" #f 2136 27 2136 37 ("8" "set-element!" "value" "seq")}
      {Lisp-Entry "set-tenth!" #f 2137 27 2137 37 ("9" "set-element!" "value" "seq")}
      {Lisp-Entry "element-reversed" #f 2140 27 2140 43 ("1" "cardinality" "-" "element" "n" "seq")}
      {Lisp-Entry "iterate" #f 2144 20 2144 27 ("in-sequence" "obj" "for" "loop" "proc" "seq")}
      {Lisp-Entry "accumulate" #f 2149 20 2149 30 ("coerce" "not" "if" "collect" "in-sequence" "obj" "for" "loop" "lst" "let" "type" "proc" "seq")}
      {Lisp-Entry "apply-key" #f 2158 28 2158 37 ("not" "if" "object" "key")}
      {Lisp-Entry "apply-test" #f 2164 28 2164 38 ("eqv?" "not" "if" "y" "x" "test")}
      {Lisp-Entry "gather" #f 2170 20 2170 26 ("collect" "in-sequence" "obj" "for" "loop" "coerce" "List" "type" "type:" "iterable")}
      {Lisp-Entry "collect" #f 2176 20 2176 27 ("class-of" "either" "collect" "when" "apply-key" "val" "with" "in-sequence" "obj" "for" "loop" "coerce" "type" "type:" "key" "key:" "seq" "proc")}
      {Lisp-Entry "collect-if" #f 2184 20 2184 30 ("class-of" "collect" "apply-key" "when" "in-sequence" "obj" "for" "loop" "coerce" "key" "key:" "seq" "predicate")}
      {Lisp-Entry "collect-type" #f 2191 20 2191 32 ("class-of" "collect" "apply-key" "is?" "when" "in-sequence" "obj" "for" "loop" "coerce" "key" "key:" "seq" "type")}
      {Lisp-Entry "collect-sections" #f 2198 20 2198 36 ("reset" "get-output" "put" "begin" "apply-test" "if" "value" "function" "for-each" "section" "List-Factory" "new" "sections" "let" "test" "test:" "separator" "separator:" "lst")}
      {Lisp-Entry "count" #f 2212 20 2212 25 ("increase!" "apply-key" "apply-test" "when" "in-sequence" "object" "for" "loop" "0" "total" "let" "test" "test:" "key" "key:" "seq" "target")}
      {Lisp-Entry "count-if" #f 2220 20 2220 28 ("increase!" "apply-key" "when" "in-sequence" "object" "for" "loop" "0" "total" "let" "key" "key:" "seq" "predicate")}
      {Lisp-Entry "count-type" #f 2228 20 2228 30 ("increase!" "apply-key" "is?" "when" "in-sequence" "object" "for" "loop" "0" "total" "let" "key" "key:" "seq" "type")}
      {Lisp-Entry "find" #f 2236 20 2236 24 ("1" "-" "get-position" "continuation-return" "apply-key" "apply-test" "object" "iterate" "exit" "function" "continuation-capture" "set-position" "when" "iterate-sequence" "backward" "'backward" "direction:" "explore" "iterator" "let" "0" "either" "list-find" "not" "null/pair?" "and" "if" "reversed?" "reversed?:" "start" "start:" "test" "test:" "key" "key:" "target" "seq")}
      {Lisp-Entry "list-find" #f 2251 13 2251 22 ("1" "+" "cdr" "else" "car" "null?" "cond" "rank" "tail" "rest" "iter" "eqv?" "x" "function" "not" "if" "let" "start" "test" "key" "target" "list")}
      {Lisp-Entry "find-in" #f 2262 20 2262 27 ("continuation-return" "apply-key" "apply-test" "object" "iterate" "exit" "function" "continuation-capture" "set-position" "when" "iterate-sequence" "backward" "'backward" "direction:" "explore" "iterator" "let" "0" "either" "list-find-in" "not" "null/pair?" "and" "if" "reversed?" "reversed?:" "start" "start:" "test" "test:" "key" "key:" "target" "seq")}
      {Lisp-Entry "list-find-in" #f 2277 13 2277 25 ("1" "+" "cdr" "else" "car" "null?" "cond" "rank" "tail" "rest" "iter" "eqv?" "x" "function" "not" "if" "let" "start" "test" "key" "target" "list")}
      {Lisp-Entry "find-balanced" #f 2288 20 2288 33 ("error" "else" "1" "-" "get-position" "position" "continuation-return" "case" "<" "decrease!" "increase!" "apply-key" "apply-test" "cond" "object" "iterate" "exit" "function" "continuation-capture" "set-position" "when" "0" "count" "iterate-sequence" "backward" "'backward" "direction:" "explore" "if" "iterator" "let" "item" "'item" "return" "return:" "reversed?" "reversed?:" "start" "start:" "test" "test:" "key" "key:" "seq" "close" "open")}
      {Lisp-Entry "find-if" #f 2309 20 2309 27 ("error" "else" "1" "-" "get-position" "position" "continuation-return" "case" "apply-key" "object" "iterate" "set-position" "when" "iterate-sequence" "backward" "'backward" "direction:" "explore" "iterator" "let" "exit" "function" "continuation-capture" "0" "either" "find-if-list" "not" "null/pair?" "and" "if" "item" "'item" "return" "return:" "reversed?" "reversed?:" "start" "start:" "key" "key:" "seq" "predicate")}
      {Lisp-Entry "get-rank" #f 2327 20 2327 28 ("1" "-" "get-position" "continuation-return" "apply-key" "apply-test" "object" "iterate" "set-position" "when" "iterate-sequence" "backward" "'backward" "direction:" "explore" "iterator" "let" "exit" "function" "continuation-capture" "string-find" "string?" "0" "either" "list-find" "not" "null/pair?" "and" "if" "reversed?" "reversed?:" "start" "start:" "test" "test:" "key" "key:" "seq" "target")}
      {Lisp-Entry "skip" #f 2344 20 2344 24 ("1" "get-position" "-" "continuation-return" "apply-key" "not" "when" "object" "iterate" "set-position" "iterate-sequence" "iterator" "let" "return" "function" "continuation-capture" "0" "start" "start:" "key" "key:" "seq" "predicate")}
      {Lisp-Entry "some?" #f 2356 20 2356 25 ("continuation-return" "apply-key" "when" "object" "iterate-sequence" "iterate" "return" "function" "continuation-capture" "key" "key:" "seq" "predicate")}
      {Lisp-Entry "every?" #f 2366 20 2366 26 ("continuation-return" "apply-key" "not" "when" "object" "iterate-sequence" "iterate" "return" "function" "continuation-capture" "key" "key:" "seq" "predicate")}
      {Lisp-Entry "concatenate" #f 2376 20 2376 31 ("class-of" "coerce" "not" "get-output" "output" "put-sequence" "sequence" "function" "for-each" "null/pair?" "list?" "car" "first" "let*" "List-Factory" "new" "fact" "let" "null?" "if" "rest")}
      {Lisp-Entry "concatenate!" #f 2391 20 2391 32 ("concatenate" "apply" "rest")}
      {Lisp-Entry "subset?" #f 2395 20 2395 27 ("memv?" "element" "function" "every?" "null?" "or" "set2" "set1")}
      {Lisp-Entry "union" #f 2402 20 2402 25 ("apply-union" "rest")}
      {Lisp-Entry "apply-union" #f 2406 20 2406 31 ("class-of" "coerce" "cdr" "put" "get-output" "member?" "not" "when" "object" "iterate-sequence" "iterate" "set" "function" "for-each" "put-sequence" "List-Factory" "new" "dst" "car" "first" "let" "null?" "if" "test" "test:" "lst")}
      {Lisp-Entry "intersection" #f 2421 20 2421 32 ("cons" "apply-intersection" "rest" "first")}
      {Lisp-Entry "apply-intersection" #f 2425 20 2425 38 ("class-of" "get-output" "coerce" "put" "member?" "set" "every?" "when" "object" "function" "iterate-sequence" "iterate" "List-Factory" "new" "dst" "cdr" "car" "first" "let" "null?" "if" "test" "test:" "lst")}
      {Lisp-Entry "difference" #f 2440 20 2440 30 ("class-of" "get-output" "coerce" "put" "member?" "not" "when" "object" "function" "iterate-sequence" "iterate" "List-Factory" "new" "dst" "let" "null?" "if" "eqv?" "test" "test:" "y" "x")}
      {Lisp-Entry "set-xor" #f 2451 20 2451 27 ("difference" "union" "eqv?" "test" "test:" "y" "x")}
      {Lisp-Entry "remove" #f 2456 20 2456 26 ("class-of" "get-output" "coerce" "put" "apply-test" "not" "when" "object" "function" "iterate-sequence" "iterate" "List-Factory" "new" "dst" "let" "eqv?" "test" "test:" "seq" "target")}
      {Lisp-Entry "string-remove" #f 2465 15 2465 28 ()}
      {Lisp-Entry "remove" #f 2465 30 2465 36 ("get-output-string" "write-char" "eqv?" "not" "when" "element" "c" "cardinality" "below" "0" "from" "n" "for" "loop" "open-output-string" "output" "let" "str" "target")}
      {Lisp-Entry "remove-trailing" #f 2474 20 2474 35 ("reverse" "cons" "set!" "apply-test" "and" "unless" "element" "function" "for-each" "trailing?" "result" "let" "eqv?" "test" "test:" "list" "target")}
      {Lisp-Entry "remove-enclosing" #f 2485 20 2485 36 ("subseq" "decrease!" "1" "-" ">" "increase!" "element" "apply-test" "<" "and" "while" "tail" "head" "cardinality" "end" "0" "start" "let*" "eqv?" "test" "test:" "seq" "target")}
      {Lisp-Entry "remove-duplicates" #f 2497 20 2497 37 ("class-of" "coerce" "put" "get-output" "apply-key" "member?" "not" "when" "object" "function" "iterate-sequence" "iterate" "List-Factory" "new" "dst" "let" "eqv?" "test" "test:" "key" "key:" "seq")}
      {Lisp-Entry "remove-nils" #f 2506 20 2506 31 ("identity" "collect-if" "seq")}
      {Lisp-Entry "remove-empty-strings" #f 2510 20 2510 40 ("empty-string?" "not" "obj" "function" "collect-if" "seq")}
      {Lisp-Entry "trim-spaces" #f 2516 20 2516 31 ("remove-enclosing" "seq")}
      {Lisp-Entry "trim-whitespace" #f 2520 20 2520 35 ("whitespace?" "ignore" "c" "function" "test:" "remove-enclosing" "seq")}
      {Lisp-Entry "mismatch" #f 2526 20 2526 28 ("if" "increase!" "continuation-return" "get-next" "or" "when" "done?" "not" "while" "0" "pos" "targ" "iterate-sequence" "srce" "let" "return" "function" "continuation-capture" "equal?" "test" "test:" "seq" "target")}
      {Lisp-Entry "prefix" #f 2541 20 2541 26 ("0" "subseq" "cdr" "set!" "<" "not" "or" "and" "when" "mismatch" "n" "object" "function" "for-each" "min" "car" "ref" "let" "null?" "if" "equal?" "test" "test:" "sequences")}
      {Lisp-Entry "prefix?" #f 2556 20 2556 27 ("continuation-return" "get-next" "nu/=?" "when" "done?" "not" "and" "while" "iter" "iterate-sequence" "targ" "let" "return" "function" "continuation-capture" "seq" "target")}
      {Lisp-Entry "Search-Context" #f 2567 7 2567 21 ("Object")
        {Lisp-Entry "target" #f 2570 8 2570 14 ("generate")}
        {Lisp-Entry "whole-words?" #f 2571 8 2571 20 ("generate")}
        {Lisp-Entry "ignore-case?" #f 2572 8 2572 20 ("generate")}
        {Lisp-Entry "constituent-test" #f 2573 8 2573 24 ("generate")}
        {Lisp-Entry "user-data" #f 2574 8 2574 17 ("generate")}}
      {Lisp-Entry "construct-search-context" #f 2577 20 2577 44 ("Search-Context" "construct" "user-data" "constituent-test" "ignore-case?" "whole-words?" "target")}
      {Lisp-Entry "make-search-context" #f 2581 20 2581 39 ("construct-search-context" "user-data" "user-data:" "word-constituent?" "constituent-test" "constituent-test:" "ignore-case?" "ignore-case?:" "whole-words?" "whole-words?:" "target")}
      {Lisp-Entry "multisearch-impl" #f 2589 13 2589 29 ("cdr" "cons" "found" "last" "find-forward" "<=" "find-backward" "eqv?" "c" "<" "after" "before" "or" "and" "match?" "+" "else" "element" "not" ">=" "cond" "j" "i" "1" "-" "to" "match-case?" "define" "size" "char=?" "char-ci=?" "test" "get-constituent-test" "constituent-test" "get-ignore-case?" "ignore-case?" "get-whole-words?" "whole-words?" "get-target" "target" "car" "context" "null?" "scan" "iter" "0" "if" "either" "pos" "cardinality" "len" "let" "reverse?" "start" "contexts" "seq")}
      {Lisp-Entry "multisearch" #f 2656 20 2656 31 ("multisearch-impl" "reverse?" "reverse?:" "start" "start:" "contexts" "seq")}
      {Lisp-Entry "multisearch-all" #f 2662 20 2662 35 ("queue-list" "car" "get-target" "+" "cdr" "enqueue" "begin" "multisearch-impl" "found" "0" "if" "either" "pos" "iter" "new-queue" "queue" "cardinality" "len" "let" "reverse?" "reverse?:" "start" "start:" "contexts" "seq")}
      {Lisp-Entry "search" #f 2678 20 2678 26 ("cdr" "if" "construct-search-context" "list" "multisearch-impl" "found" "let" "word-constituent?" "constituent-test" "constituent-test:" "ignore-case?" "ignore-case?:" "whole-words?" "whole-words?:" "reverse?" "reverse?:" "start" "start:" "target" "seq")}
      {Lisp-Entry "search-all" #f 2690 20 2690 30 ("construct-search-context" "list" "multisearch-all" "cdr" "map" "word-constituent?" "constituent-test" "constituent-test:" "ignore-case?" "ignore-case?:" "whole-words?" "whole-words?:" "reverse?" "reverse?:" "start" "start:" "target" "seq")}
      {Lisp-Entry "split" #f 2701 20 2701 25 ("when" "search" "iterate" "incr" "else" "get-output" "1" "+" "subseq" "put" "set!" "if" "position" "'position" "return:" "start:" "find-if" "pos" "not" "while" "done?" "List-Factory" "new" "result" "0" "previous" "let" "procedure?" "list" "cardinality" "zero?" "cond" "separator" "seq")}
      {Lisp-Entry "split-justified" #f 2730 20 2730 35 ("get-output" "increase!" "+" "set!" "subseq" "put" "begin" "<=" "if" "-" "effective-width" "not" "while" "done?" "List-Factory" "new" "result" "cardinality" "size" "pos" "let" "0" "column" "column:" "separators" "width" "seq")}
      {Lisp-Entry "join" #f 2747 20 2747 24 ("get-output" "concatenate" "apply" "seq" "function" "for-each" "put" "List-Factory" "new" "dst" "join-strings" "string?" "if" "first" "let" "else" "car" "cdr" "null?" "cond" "separator" "sequences")}
      {Lisp-Entry "inject" #f 2766 20 2766 26 ("get-output" "put" "put-sequence" "set!" "if" "element" "function" "for-each" "first?" "List-Factory" "new" "fact" "let" "inserted" "sequence")}
      {Lisp-Entry "substitute" #f 2778 20 2778 30 ("class-of" "get-output" "coerce" "put-sequence" "put" "apply-key" "apply-test" "if" "get-next" "object" "done?" "not" "while" "List-Factory" "new" "dst" "iterate-sequence" "src" "let" "sequence?" "sequence?:" "test" "test:" "key" "key:" "seq" "new-value" "old-value")}
      {Lisp-Entry "substitute-alist" #f 2791 20 2791 36 ("class-of" "get-output" "coerce" "put" "set!" "put-sequence" "apply-key" "apply-test" "when" "old" "bind" "unless" "replacement" "function" "for-each" "found?" "get-next" "object" "done?" "not" "while" "List-Factory" "new" "dst" "iterate-sequence" "src" "let" "test" "test:" "key" "key:" "seq" "replacements")}
      {Lisp-Entry "fill!" #f 2809 20 2809 25 ("next" "put" "done?" "not" "while" "set-position" "when" "iterate-sequence" "src" "let" "start" "start:" "object" "seq")}
      {Lisp-Entry "replace!" #f 2819 20 2819 28 ("next" "get-next" "put" "done?" "not" "and" "while" "set-position" "when" "rep" "iterate-sequence" "src" "let" "start" "start:" "replacement" "seq")}
      {Lisp-Entry "ordered-position" #f 2830 20 2830 36 ("find" "<=" "test" "test:" "key" "key:" "seq" "object")}
      {Lisp-Entry "insert-ordered!" #f 2834 20 2834 35 ("cardinality" "either" "insert!" "ordered-position" "n" "let" "<=" "test" "test:" "key" "key:" "seq" "object")}
      {Lisp-Entry "merge-ordered" #f 2839 20 2839 33 ("get-next" "expr" "error" "else" ":right" ":greater" ":left" ":less" "next" ":same" ":equal" "case" "ky" "apply-key" "kx" "ey" "peek" "ex" "let*" "done?" "not" "and" "while" "compare" "ci-compare" "if" "either" "compare-proc" "iy" "iterate-sequence" "ix" "let" "case-insensitive?" "case-insensitive?:" "test" "test:" "right-key" "right-key:" "left-key" "left-key:" "key" "key:" "y" "x" "proc")}
      {Lisp-Entry "merge" #f 2865 20 2865 25 ("get-output" "cdr" "set-car!" "put" ":equal" "neq?" "not" "or" "if" "object" "list" "pair" "function" "for-each-pair" "List-Factory" "new" "res" "apply-key" "min-key" ":compare" "remove-nils" "car" "map" "minimum" "min" "let*" "identity" "some?" "while" "copy" "scan" "let" "compare" "compare:" "key" "key:" "lists" "proc")}
      {Lisp-Entry "random-element" #f 2883 20 2883 34 ("cardinality" "random" "element" "seq")}
      {Lisp-Entry "partition" #f 2887 20 2887 29 ("elements" "bind" "partition" "map" "reverse!" "cdr" "set-cdr!" "list" "cons" "set!" "not" "if" "associate" "pair" "category" "let*" "element" "function" "for-each" "result" "let" "test" "test:" "identity" "key" "key:" "sequence")}
      {Lisp-Entry "partition-binary" #f 2902 20 2902 36 ("values" "cons" "set!" "if" "elem" "function" "for-each" "no" "yes" "let" "predicate" "lst")}
      {Lisp-Entry "starts-with?" #f 2913 13 2913 25 ("0" "subseq" "string=?" ">=" "and" "tl" "cardinality" "sl" "let" "target" "seq")}
      {Lisp-Entry "ends-with?" #f 2922 13 2922 23 ("-" "subseq" "string=?" ">=" "and" "tl" "cardinality" "sl" "let" "target" "seq")}
      {Lisp-Entry "for-each-reversed" #f 2931 13 2931 30 ("car" "cdr" "pair?" "when" "iterate" "let" "lst" "proc")}
      {Lisp-Entry "find-if-list" #f 2938 13 2938 25 ("1" "+" "cdr" "error" "else" "item" "'item" "position" "'position" "eq?" "car" "null?" "cond" "rank" "tail" "rest" "iter" "x" "function" "not" "if" "let" "returned" "start" "key" "list" "predicate")}
      {Lisp-Entry "insert-sequence!" #f 2950 27 2950 43 ("replace-subseq!" "seq" "pos" "sequence")}
      {Lisp-Entry "Sequence-Explorer" #f 2959 7 2959 24 ("Explorer")
        {Lisp-Entry "sequence" #f 2962 8 2962 16 ()}
        {Lisp-Entry "sequence-cardinality" #f 2963 8 2963 28 ()}
        {Lisp-Entry "current" #f 2964 8 2964 15 ()}
        {Lisp-Entry "initialize" #f 2967 11 2967 21 ("current" "goto-end" "backward" "goto-beginning" "case" "not" "if" "set-direction" "cardinality" "sequence-cardinality" "sequence" "set!" "nextmethod" "start" "start:" "forward" "'forward" "direction" "direction:" "seq")}
        {Lisp-Entry "peek-forward" #f 2979 11 2979 23 ("current" "sequence" "element")}
        {Lisp-Entry "peek-backward" #f 2983 11 2983 24 ("1" "current" "-" "sequence" "element")}
        {Lisp-Entry "goto-beginning" #f 2987 11 2987 25 ("0" "current" "set!")}
        {Lisp-Entry "goto-end" #f 2991 11 2991 19 ("sequence-cardinality" "current" "set!")}
        {Lisp-Entry "forward" #f 2995 11 2995 18 ("1" "current" "increase!")}
        {Lisp-Entry "backward" #f 2999 11 2999 19 ("1" "current" "decrease!")}
        {Lisp-Entry "done-forward?" #f 3003 11 3003 24 ("sequence-cardinality" "current" ">=")}
        {Lisp-Entry "done-backward?" #f 3007 11 3007 25 ("0" "current" "=")}
        {Lisp-Entry "put-forward" #f 3011 11 3011 22 ("current" "sequence" "set-element!" "object")}
        {Lisp-Entry "put-backward" #f 3015 11 3015 23 ("1" "current" "-" "sequence" "set-element!" "object")}
        {Lisp-Entry "get-position" #f 3019 11 3019 23 ("current")}
        {Lisp-Entry "set-position" #f 3023 11 3023 23 ("sequence-cardinality" "0" "between" "current" "set!" "pos")}
        {Lisp-Entry "get-state" #f 3027 11 3027 20 ("current")}
        {Lisp-Entry "reset-state" #f 3031 11 3031 22 ("current" "set!" "state")}}
      {Lisp-Entry "List-Class" #f 3040 7 3040 17 ("Sequence-Class")
        {Lisp-Entry "allocate-sequence" #f 3043 11 3043 28 ("make-list" "len")}}
      {Lisp-Entry "List" #f 3047 17 3047 21 ("Sequence" "List-Class")
        {Lisp-Entry "initialize" #f 3050 11 3050 21 ("native-class" "rest")}
        {Lisp-Entry "copy-object" #f 3054 11 3054 22 ("self" "copy" "if" "x" "function" "map" "deep?")}
        {Lisp-Entry "iterate-object" #f 3062 11 3062 25 ("self" "List-Iterator" "new")}
        {Lisp-Entry "sequence-element" #f 3066 11 3066 27 ("self" "list-ref" "n")}
        {Lisp-Entry "sequence-set-element!" #f 3070 11 3070 32 ("self" "list-set!" "obj" "n")}
        {Lisp-Entry "sequence-cardinality" #f 3074 11 3074 31 ("self" "length")}
        {Lisp-Entry "sequence-tail" #f 3078 11 3078 24 ("1" "-" "cdr" "tail" "0" "=" "self" "null?" "or" "if" "n")}
        {Lisp-Entry "sequence-last" #f 3084 11 3084 24 ("last" "car" "self" "cdr" "null?" "if")}
        {Lisp-Entry "sequence-butlast" #f 3090 11 3090 27 ("butlast" "car" "cons" "cdr" "self" "null?" "or" "if")}
        {Lisp-Entry "sequence-subseq!" #f 3096 11 3096 27 ("subseq" "self" "-1" "0" "=" "or" "if" "end" "start")}
        {Lisp-Entry "replace-subseq!" #f 3102 11 3102 26 ("+" "after" "1" "-" "before" "let*" "self" "tail" "last-tail" "set-cdr!" "begin" "0" "=" "if" "seq" "end" "start")}}
      {Lisp-Entry "Null-Class" #f 3114 7 3114 17 ("List-Class")}
      {Lisp-Entry "Null" #f 3117 17 3117 21 ("List" "Null-Class")
        {Lisp-Entry "compare-object" #f 3120 11 3120 25 (":not-equal" ":equal" "null?" "if" "obj")}}
      {Lisp-Entry "Pair-Class" #f 3126 7 3126 17 ("List-Class")}
      {Lisp-Entry "Pair" #f 3129 17 3129 21 ("List" "Pair-Class")
        {Lisp-Entry "compare-object" #f 3132 11 3132 25 (":not-equal" "else" "null?" "and" "cond" "right" "cdr" "left" "let" ":equal" ":greater" ":less" "self" "car" "compare" "case" "pair?" "if" "obj")}}
      {Lisp-Entry "element" #f 3152 20 3152 27 ("list-ref" "n" "list")}
      {Lisp-Entry "cardinality" #f 3156 20 3156 31 ("length" "list")}
      {Lisp-Entry "insert!" #f 3160 27 3160 34 ("class-of" "list" "coerce" "insert-sequence!" "obj" "pos" "seq")}
      {Lisp-Entry "atom?" #f 3164 27 3164 32 ("pair?" "not" "obj")}
      {Lisp-Entry "null/pair?" #f 3168 27 3168 37 ("pair?" "null?" "or" "obj")}
      {Lisp-Entry "last-tail" #f 3172 20 3172 29 ("cdr" "pair?" "cur" "iter" "let" "null?" "if" "lst")}
      {Lisp-Entry "make-list" #f 3181 20 3181 29 ("1" "-" "cons" "set!" "0" ">" "while" "list" "car" "null?" "if" "fill" "let" "rest" "n")}
      {Lisp-Entry "list-set!" #f 3190 27 3190 36 ("list-tail" "set-car!" "value" "n" "list")}
      {Lisp-Entry "set-cadr!" #f 3194 27 3194 36 ("cdr" "set-car!" "value" "pair")}
      {Lisp-Entry "append!" #f 3198 20 3198 27 ("queue-list" "enqueue-list" "lst" "function" "for-each" "new-queue" "queue" "let" "rest")}
      {Lisp-Entry "position" #f 3206 20 3206 28 ("0" "1" "+" "cdr" "else" "car" "eqv?" "null?" "cond" "pos" "function" "position" "letrec" "lst" "element")}
      {Lisp-Entry "copy-tree" #f 3218 20 3218 29 ("cdr" "car" "copy-tree" "cons" "pair?" "if" "tree")}
      {Lisp-Entry "position-of" #f 3225 20 3225 31 ("1" "+" "cdr" "car" "eq?" "null?" "if" "0" "i" "rst" "iter" "let" "lst" "obj")}
      {Lisp-Entry "proper-list?" #f 3234 13 3234 25 ("cdr" "proper-list?" "else" "pair?" "not" "null?" "cond" "lst")}
      {Lisp-Entry "last-cdr" #f 3240 13 3240 21 ("cdr" "last-cdr" "pair?" "if" "lst")}
      {Lisp-Entry "but-last-cdr" #f 3246 13 3246 25 ("cdr" "but-last-cdr" "car" "cons" "pair?" "if" "lst")}
      {Lisp-Entry "move-to-head!" #f 3252 13 3252 26 ("else" "cons" "set-cdr!" "cond" "cdr" "scan" "previous" "iter" "let" "car" "eq?" "null?" "or" "if" "lst" "target")}
      {Lisp-Entry "move-to-tail!" #f 3263 13 3263 26 ("begin" "if" "scan" "previous" "iter" "let" "else" "cdr" "cons" "last-tail" "set-cdr!" "car" "eq?" "null?" "cond" "lst" "target")}
      {Lisp-Entry "augment" #f 3282 20 3282 27 ("get-output" "set!" "put" "car" "put-sequence" "cdr" "null?" "if" "not-null?" "while" "scan" "List-Factory" "new" "fact" "let" "rest")}
      {Lisp-Entry "memq?" #f 3293 27 3293 32 ("memq" "boolean" "list" "target")}
      {Lisp-Entry "memv?" #f 3297 27 3297 32 ("memv" "boolean" "list" "target")}
      {Lisp-Entry "member?" #f 3301 20 3301 27 ("cdr" "else" "car" "apply-key" "apply-test" "null?" "cond" "scan" "iter" "let" "equal?" "test" "test:" "key" "key:" "list" "target")}
      {Lisp-Entry "assq-value" #f 3311 20 3311 30 ("cdr" "if" "assq" "pair" "let" "default-value" "list" "key")}
      {Lisp-Entry "assv-value" #f 3318 20 3318 30 ("cdr" "if" "assv" "pair" "let" "default-value" "list" "key")}
      {Lisp-Entry "assoc-value" #f 3325 20 3325 31 ("cdr" "if" "assoc" "pair" "let" "default-value" "list" "key")}
      {Lisp-Entry "associate" #f 3332 20 3332 29 ("cdr" "apply-key" "apply-test" "car" "pair" "null?" "if" "scan" "iter" "let" "equal?" "test" "test:" "key" "key:" "list" "target")}
      {Lisp-Entry "rassociate" #f 3342 20 3342 30 ("cdr" "apply-key" "apply-test" "car" "pair" "null?" "if" "scan" "iter" "let" "equal?" "test" "test:" "key" "key:" "list" "target")}
      {Lisp-Entry "find-pair" #f 3352 20 3352 29 ("cdr" "else" "car" "eq?" "null?" "cond" "scan" "iter" "let" "list" "target")}
      {Lisp-Entry "reverse!" #f 3362 20 3362 28 ("set-cdr!" "cdr" "set!" "not-null?" "while" "ptr" "res" "let" "list")}
      {Lisp-Entry "remove!" #f 3373 20 3373 27 ("set-cdr!" "begin" "scan" "previous" "let" "null?" "if" "cdr" "set!" "car" "apply-key" "not-null?" "and" "while" "eqv?" "test" "test:" "key" "key:" "list" "target")}
      {Lisp-Entry "getprop" #f 3390 20 3390 27 ("cddr" "else" "car" "apply-key" "eqv?" "null?" "cond" "scan" "iter" "let" "key" "key:" "target" "plist")}
      {Lisp-Entry "getf" #f 3400 20 3400 24 ("cadr" "not" "if" "getprop" "pair" "let" "not-found" "not-found:" "key" "key:" "target" "plist")}
      {Lisp-Entry "setf" #f 3407 20 3407 24 ("getprop" "set-second!" "value" "target" "plist")}
      {Lisp-Entry "addf" #f 3411 20 3411 24 ("set-second!" "list" "append!" "not" "if" "getprop" "pair" "let" "value" "target" "plist")}
      {Lisp-Entry "for-each-pair" #f 3419 20 3419 33 ("cdr" "set!" "not-null?" "while" "lst" "proc")}
      {Lisp-Entry "for-each-property" #f 3425 20 3425 37 ("cddr" "set!" "cadr" "car" "not-null?" "while" "lst" "proc")}
      {Lisp-Entry "map-property" #f 3431 20 3431 32 ("queue-list" "enqueue" "value" "property" "function" "for-each-property" "new-queue" "queue" "let" "lst" "proc")}
      {Lisp-Entry "flatten" #f 3439 20 3439 27 ("append" "apply" "llist")}
      {Lisp-Entry "uniform" #f 3443 20 3443 27 ("cdr" "continuation-return" "apply-test" "unless" "value" "object" "for-each" "car" "apply-key" "first" "let" "return" "function" "continuation-capture" "null?" "if" "test" "test:" "key" "key:" "lst")}
      {Lisp-Entry "sort-property-list" #f 3457 20 3457 38 ("append" "apply" "car" "key:" "<" "sort" "sorted" "get-output" "for-each-property" "begin" "alist" "list" "put" "value" "property" "function" "proc" "List-Factory" "new" "factory" "let*" "prop-list")}
      {Lisp-Entry "List-Iterator" #f 3473 7 3473 20 ("Iterator")
        {Lisp-Entry "current" #f 3476 8 3476 15 ()}
        {Lisp-Entry "position" #f 3477 8 3477 16 ()}
        {Lisp-Entry "initialize" #f 3480 11 3480 21 ("0" "position" "current" "set!" "nextmethod" "list")}
        {Lisp-Entry "get-next!" #f 3486 11 3486 20 ("1" "+" "position" "cdr" "set!" "car" "prog1" "eof-object" "current" "null?" "if")}
        {Lisp-Entry "done?" #f 3494 11 3494 16 ("Empty" "peeked" "eq?" "current" "null?" "and")}
        {Lisp-Entry "put" #f 3498 11 3498 14 ("current" "set-car!" "object")}
        {Lisp-Entry "get-position" #f 3502 11 3502 23 ("position")}
        {Lisp-Entry "set-position" #f 3506 11 3506 23 ("tail" "current" "set!" ">" "error" "0" "<" "cond" "position" "-" "delta" "let" "pos")}
        {Lisp-Entry "get-state" #f 3514 11 3514 20 ("position" "current" "cons")}
        {Lisp-Entry "reset-state" #f 3518 11 3518 22 ("cdr" "position" "car" "current" "set!" "state")}
        {Lisp-Entry "get-list" #f 3523 18 3523 26 ("current")}}
      {Lisp-Entry "List-Factory" #f 3532 7 3532 19 ("Object")
        {Lisp-Entry "list" #f 3535 8 3535 12 ()}
        {Lisp-Entry "last-list" #f 3536 8 3536 17 ()}
        {Lisp-Entry "last-anchor" #f 3537 8 3537 19 ()}
        {Lisp-Entry "current" #f 3538 8 3538 15 ()}
        {Lisp-Entry "size" #f 3539 8 3539 12 ("0")}
        {Lisp-Entry "put" #f 3542 11 3542 14 ("increase!" "size" "prog1" "cdr" "set-cdr!" "copy-last-list" "last-list" "when" "else" "list" "cons" "set!" "current" "null?" "cond" "object")}
        {Lisp-Entry "put-unique" #f 3555 11 3555 21 ("put" "list" "member?" "unless" "eqv?" "test" "test:" "object")}
        {Lisp-Entry "put-sequence" #f 3560 11 3560 23 ("cardinality" "increase!" "size" "prog1" "set-cdr!" "last-anchor" "copy-last-list" "else" "list" "last-list" "set!" "current" "null?" "cond" "put" "iterate" "pair?" "not" "if" "when" "seq")}
        {Lisp-Entry "is-empty?" #f 3578 18 3578 27 ("current" "null?")}
        {Lisp-Entry "get-size" #f 3582 18 3582 26 ("size")}
        {Lisp-Entry "get-list" #f 3586 18 3586 26 ("list")}
        {Lisp-Entry "get-last-element" #f 3590 18 3590 34 ("current" "car")}
        {Lisp-Entry "get-output" #f 3594 11 3594 21 ("list")}
        {Lisp-Entry "reset" #f 3598 18 3598 23 ("0" "size" "current" "last-anchor" "last-list" "list" "set!")}
        {Lisp-Entry "copy-last-list" #f 3606 19 3606 33 ("set-cdr!" "else" "last-tail" "current" "last-list" "copy" "list" "set!" "last-anchor" "not" "cond")}}
      {Lisp-Entry "Table" #f 3622 17 3622 22 ("Object")
        {Lisp-Entry "initialize" #f 3625 11 3625 21 ("native-class" "rest")}
        {Lisp-Entry "print" #f 3629 11 3629 16 ("table-length" "format" "function" "self" "print-unreadable" "readably" "printer")}}
      {Lisp-Entry "table-add" #f 3636 20 3636 29 ("table-ref" "cons" "table-set!" "value" "key" "table")}
      {Lisp-Entry "table-remove!" #f 3640 20 3640 33 ("table-ref" "remove!" "table-set!" "value" "name" "table")}
      {Lisp-Entry "empty-table" #f 3644 13 3644 24 ("empty-table" "'empty-table" "unimplemented" "table")}
      {Lisp-Entry "table-keys" #f 3648 20 3648 30 ("cons" "set!" "value" "key" "function" "iterate-table" "list" "let" "table")}
      {Lisp-Entry "table-values" #f 3656 20 3656 32 ("cons" "set!" "value" "key" "function" "iterate-table" "list" "let" "table")}
      {Lisp-Entry "table-keys/values" #f 3664 20 3664 37 ("cons" "set!" "value" "key" "function" "iterate-table" "list" "let" "table")}
      {Lisp-Entry "table-load" #f 3672 20 3672 30 ("table-set!" "error" "table-ref" "if" "eof-object?" "not" "and" "when" "object" "read" "name" "iterate" "let" "reader" "function" "cr-lf" "'cr-lf" "eol-encoding:" "parse" "path:" "list" "call-with-input-file" "error-on-duplicates?" "file" "table")}
      {Lisp-Entry "Cell" #f 3691 7 3691 11 ("Numeric")
        {Lisp-Entry "row" #f 3694 8 3694 11 ("generate")}
        {Lisp-Entry "col" #f 3695 8 3695 11 ("generate")}
        {Lisp-Entry "initialize" #f 3698 11 3698 21 ("col" "row" "set!" "c" "r")}
        {Lisp-Entry "copy-object" #f 3703 11 3703 22 ("col" "row" "Cell" "new" "deep?")}
        {Lisp-Entry "compare-object" #f 3707 11 3707 25 ("get-col" "col" ":equal" "eq?" "not" "get-row" "row" "compare" "compared" "let" ":incompatible" "Cell" "is-not?" "if" "target")}
        {Lisp-Entry "fold-literal" #f 3716 11 3716 23 ("col" ",col" "',col" "row" ",row" "',row" "Cell" "new")}
        {Lisp-Entry "print" #f 3720 11 3720 16 ("col" "row" "self" "class-of" "type-name" "identifier-name" "format" "readably" "printer")}
        {Lisp-Entry "numeric-norm" #f 3727 11 3727 23 ("self" "error")}
        {Lisp-Entry "numeric-add" #f 3731 11 3731 22 ("self" "error" "else" "integer?" "get-col" "col" "get-row" "row" "+" "new" "Cell" "is?" "cond" "n")}
        {Lisp-Entry "numeric-negate" #f 3737 11 3737 25 ("col" "row" "-" "Cell" "new")}
        {Lisp-Entry "numeric-multiply" #f 3741 11 3741 27 ("self" "error" "col" "row" "*" "Cell" "new" "integer?" "if" "n")}
        {Lisp-Entry "numeric-inverse" #f 3747 11 3747 26 ("self" "error")}
        {Lisp-Entry "increase-row" #f 3751 18 3751 30 ("+" "row" "set!" "1" "delta")}
        {Lisp-Entry "increase-col" #f 3755 18 3755 30 ("+" "col" "set!" "1" "delta")}}
      {Lisp-Entry "new-cell" #f 3759 27 3759 35 ("Cell" "construct" "col" "row")}
      {Lisp-Entry "new" #f 3762 20 3762 23 ("new-cell" "col" "row" "class")}
      {Lisp-Entry "copy-cell" #f 3766 22 3766 31 ()}
      {Lisp-Entry "copy" #f 3766 33 3766 37 ("get-col" "get-row" "Cell" "new" "c")}
      {Lisp-Entry "cell=" #f 3770 22 3770 27 ()}
      {Lisp-Entry "=" #f 3770 29 3770 30 ("get-col" "get-row" "=" "and" "c2" "c1")}
      {Lisp-Entry "cell<" #f 3775 15 3775 20 ()}
      {Lisp-Entry "<" #f 3775 22 3775 23 ("get-col" "=" "and" "<" "or" "r2" "get-row" "r1" "let" "c2" "c1")}
      {Lisp-Entry "cell<=" #f 3783 15 3783 21 ()}
      {Lisp-Entry "<=" #f 3783 23 3783 25 ("get-col" "<=" "=" "and" "<" "or" "r2" "get-row" "r1" "let" "c2" "c1")}
      {Lisp-Entry "cell>" #f 3791 15 3791 20 ()}
      {Lisp-Entry ">" #f 3791 22 3791 23 ("get-col" "=" "and" ">" "or" "r2" "get-row" "r1" "let" "c2" "c1")}
      {Lisp-Entry "cell>=" #f 3799 15 3799 21 ()}
      {Lisp-Entry ">=" #f 3799 23 3799 25 ("get-col" ">=" "=" "and" ">" "or" "r2" "get-row" "r1" "let" "c2" "c1")}
      {Lisp-Entry "cell+" #f 3807 22 3807 27 ()}
      {Lisp-Entry "+" #f 3807 29 3807 30 ("get-col" "get-row" "+" "Cell" "new" "c2" "c1")}
      {Lisp-Entry "+" #f 3813 20 3813 21 ("get-col" "+" "get-row" "Cell" "new" "n" "c")}
      {Lisp-Entry "cell-" #f 3819 22 3819 27 ()}
      {Lisp-Entry "-" #f 3819 29 3819 30 ("get-col" "get-row" "-" "Cell" "new" "c2" "c1")}
      {Lisp-Entry "-" #f 3825 20 3825 21 ("get-col" "-" "get-row" "Cell" "new" "n" "c")}
      {Lisp-Entry "Range" #f 3836 7 3836 12 ("Object")
        {Lisp-Entry "start" #f 3839 8 3839 13 ()}
        {Lisp-Entry "end" #f 3840 8 3840 11 ()}
        {Lisp-Entry "initialize" #f 3843 11 3843 21 ("end" "start" "set!" "nextmethod" "e" "s")}
        {Lisp-Entry "copy-object" #f 3849 11 3849 22 ("end" "start" "Range" "new" "deep?")}
        {Lisp-Entry "compare-object" #f 3853 11 3853 25 (":not-equal" "else" ":equal" "get-end" "end" "get-start" "start" "=" "and" ":incompatible" "Range" "is-not?" "cond" "target")}
        {Lisp-Entry "fold-literal" #f 3862 11 3862 23 ("end" ",end" "',end" "start" ",start" "',start" "Range" "new")}
        {Lisp-Entry "print" #f 3866 11 3866 16 ("end" "start" "self" "class-of" "type-name" "identifier-name" "format" "readably" "printer")}
        {Lisp-Entry "get-start" #f 3873 25 3873 34 ("start")}
        {Lisp-Entry "get-end" #f 3877 25 3877 32 ("end")}
        {Lisp-Entry "extent" #f 3881 26 3881 32 ("start" "end" "-")}
        {Lisp-Entry "extended?" #f 3885 26 3885 35 ("end" "start" "=" "not")}
        {Lisp-Entry "inside?" #f 3889 18 3889 25 ("end" "<" "start" ">=" "and" "n")}
        {Lisp-Entry "before?" #f 3894 18 3894 25 ("start" "<" "n")}
        {Lisp-Entry "after?" #f 3898 18 3898 24 ("end" ">" "n")}
        {Lisp-Entry "intersect?" #f 3902 18 3902 28 ("start" "get-end" ">=" "end" "get-start" "<" "and" "range")}
        {Lisp-Entry "intersect" #f 3907 18 3907 27 ("get-end" "end" "min" "get-start" "start" "max" "self" "class-of" "new" "intersect?" "when" "range")}}
      {Lisp-Entry "new-range" #f 3912 27 3912 36 ("Range" "construct" "end" "start")}
      {Lisp-Entry "new" #f 3915 20 3915 23 ("new-range" "end" "start" "class")}
      {Lisp-Entry "range=" #f 3919 22 3919 28 ()}
      {Lisp-Entry "=" #f 3919 30 3919 31 ("get-end" "get-start" "=" "and" "r2" "r1")}
      {Lisp-Entry "Range$Cell$" #f 3929 7 3929 18 ("Object")
        {Lisp-Entry "start" #f 3932 8 3932 13 ("generate")}
        {Lisp-Entry "end" #f 3933 8 3933 11 ("generate")}
        {Lisp-Entry "initialize" #f 3936 11 3936 21 ("end" "start" "set!" "nextmethod" "e" "s")}
        {Lisp-Entry "copy-object" #f 3942 11 3942 22 ("end" "start" "Range$Cell$" "new" "deep?")}
        {Lisp-Entry "compare-object" #f 3946 11 3946 25 (":not-equal" "else" ":equal" "get-end" "end" "get-start" "start" "=" "and" ":incompatible" "Range$Cell$" "is-not?" "cond" "target")}
        {Lisp-Entry "fold-literal" #f 3955 11 3955 23 ("end" ",end" "',end" "start" ",start" "',start" "Range$Cell$" "new")}
        {Lisp-Entry "print" #f 3959 11 3959 16 ("end" "start" "self" "class-of" "type-name" "identifier-name" "format" "readably" "printer")}
        {Lisp-Entry "extent" #f 3966 26 3966 32 ("start" "end" "-")}
        {Lisp-Entry "extended?" #f 3970 26 3970 35 ("end" "start" "=" "not")}
        {Lisp-Entry "inside?" #f 3974 18 3974 25 ("end" "<" "start" ">=" "and" "n")}
        {Lisp-Entry "before?" #f 3979 18 3979 25 ("start" "<" "n")}
        {Lisp-Entry "after?" #f 3983 18 3983 24 ("end" ">" "n")}
        {Lisp-Entry "intersect?" #f 3987 18 3987 28 ("start" "get-end" ">=" "end" "get-start" "<" "and" "range")}
        {Lisp-Entry "intersect" #f 3992 18 3992 27 ("get-end" "end" "min" "get-start" "start" "max" "self" "class-of" "new" "intersect?" "when" "range")}}
      {Lisp-Entry "new" #f 3997 20 3997 23 ("Range$Cell$" "construct" "end" "start" "class")}
      {Lisp-Entry "=" #f 4001 20 4001 21 ("get-end" "get-start" "=" "and" "r2" "r1")}
      {Lisp-Entry "Point" #f 4011 7 4011 12 ("Numeric")
        {Lisp-Entry "h" #f 4014 8 4014 9 ("generate")}
        {Lisp-Entry "v" #f 4015 8 4015 9 ("generate")}
        {Lisp-Entry "initialize" #f 4018 11 4018 21 ("v~self" "h~self" "set!" "nextmethod" "v" "h")}
        {Lisp-Entry "copy-object" #f 4024 11 4024 22 ("v" "h" "Point" "new" "deep?")}
        {Lisp-Entry "compare-object" #f 4028 11 4028 25 (":not-equal" "else" ":equal" "get-v" "v" "get-h" "h" "=" "and" "target-point" "let" ":incompatible" "Point" "is-not?" "cond" "target")}
        {Lisp-Entry "fold-literal" #f 4038 11 4038 23 ("v" ",v" "',v" "h" ",h" "',h" "Point" "new")}
        {Lisp-Entry "print" #f 4042 11 4042 16 ("v" "h" "format" "readably" "printer")}
        {Lisp-Entry "numeric-norm" #f 4048 11 4048 23 ("v" "2" "h" "expt" "+" "sqrt")}
        {Lisp-Entry "numeric-add" #f 4052 11 4052 22 ("self" "error" "else" "integer?" "get-height" "get-width" "Dimension" "get-v" "v" "get-h" "h" "+" "new" "Point" "is?" "cond" "n")}
        {Lisp-Entry "numeric-negate" #f 4059 11 4059 25 ("v" "h" "-" "Point" "new")}
        {Lisp-Entry "numeric-multiply" #f 4063 11 4063 27 ("self" "error" "v" "h" "*" "Point" "new" "integer?" "if" "n")}
        {Lisp-Entry "numeric-inverse" #f 4069 11 4069 26 ("self" "error")}}
      {Lisp-Entry "new-point" #f 4073 27 4073 36 ("Point" "construct" "v" "h")}
      {Lisp-Entry "new" #f 4076 20 4076 23 ("new-point" "v" "h" "class")}
      {Lisp-Entry "point=" #f 4080 22 4080 28 ()}
      {Lisp-Entry "=" #f 4080 30 4080 31 ("get-v" "get-h" "=" "and" "p2" "p1")}
      {Lisp-Entry "point+" #f 4085 22 4085 28 ()}
      {Lisp-Entry "+" #f 4085 30 4085 31 ("get-v" "get-h" "+" "Point" "new" "p2" "p1")}
      {Lisp-Entry "+" #f 4091 20 4091 21 ("get-v" "get-h" "+" "Point" "new" "n" "p")}
      {Lisp-Entry "point-" #f 4097 22 4097 28 ()}
      {Lisp-Entry "-" #f 4097 30 4097 31 ("get-v" "get-h" "-" "Point" "new" "p2" "p1")}
      {Lisp-Entry "-" #f 4103 20 4103 21 ("get-v" "get-h" "-" "Point" "new" "n" "p")}
      {Lisp-Entry "-" #f 4109 20 4109 21 ("get-v" "get-h" "-" "Point" "new" "p")}
      {Lisp-Entry "point*" #f 4115 22 4115 28 ()}
      {Lisp-Entry "*" #f 4115 30 4115 31 ("get-v" "get-h" "*" "Point" "new" "n" "p")}
      {Lisp-Entry "Dimension" #f 4126 7 4126 16 ("Numeric")
        {Lisp-Entry "width" #f 4129 8 4129 13 ("generate")}
        {Lisp-Entry "height" #f 4130 8 4130 14 ("generate")}
        {Lisp-Entry "initialize" #f 4133 11 4133 21 ("height" "width" "set!" "nextmethod" "h" "w")}
        {Lisp-Entry "copy-object" #f 4139 11 4139 22 ("height" "width" "Dimension" "new" "deep?")}
        {Lisp-Entry "compare-object" #f 4143 11 4143 25 ("get-height" "height" ":equal" "neq?" "get-width" "width" "compare" "compared" "let" ":incompatible" "Dimension" "is-not?" "if" "target")}
        {Lisp-Entry "fold-literal" #f 4152 11 4152 23 ("height" ",height" "',height" "width" ",width" "',width" "Dimension" "new")}
        {Lisp-Entry "print" #f 4156 11 4156 16 ("height" "width" "format" "readably" "printer")}
        {Lisp-Entry "numeric-norm" #f 4162 11 4162 23 ("self" "error")}
        {Lisp-Entry "numeric-add" #f 4166 11 4166 22 ("self" "error" "else" "integer?" "get-v" "get-h" "Point" "get-height" "height" "get-width" "width" "+" "new" "Dimension" "is?" "cond" "n")}
        {Lisp-Entry "numeric-negate" #f 4173 11 4173 25 ("height" "width" "-" "Dimension" "new")}
        {Lisp-Entry "numeric-multiply" #f 4177 11 4177 27 ("self" "error" "height" "width" "*" "Dimension" "new" "integer?" "if" "n")}
        {Lisp-Entry "numeric-inverse" #f 4183 11 4183 26 ("self" "error")}}
      {Lisp-Entry "new-dimension" #f 4187 27 4187 40 ("Dimension" "construct" "height" "width")}
      {Lisp-Entry "new" #f 4190 20 4190 23 ("new-dimension" "height" "width" "class")}
      {Lisp-Entry "dimension=" #f 4194 22 4194 32 ()}
      {Lisp-Entry "=" #f 4194 34 4194 35 ("get-height" "get-width" "=" "and" "d2" "d1")}
      {Lisp-Entry "dimension+" #f 4199 22 4199 32 ()}
      {Lisp-Entry "+" #f 4199 34 4199 35 ("get-height" "get-width" "+" "Dimension" "new" "d2" "d1")}
      {Lisp-Entry "dimension-" #f 4205 22 4205 32 ()}
      {Lisp-Entry "-" #f 4205 34 4205 35 ("get-height" "get-width" "-" "Dimension" "new" "d2" "d1")}
      {Lisp-Entry "dimension*" #f 4211 22 4211 32 ()}
      {Lisp-Entry "*" #f 4211 34 4211 35 ("get-height" "get-width" "*" "Dimension" "new" "n" "d")}
      {Lisp-Entry "Rect-Class" #f 4222 7 4222 17 ("Class")
        {Lisp-Entry "coerce-object" #f 4225 11 4225 24 ("nextmethod" "else" "0" "get-v" "get-h" "Rect" "new" "Point" "typecase" "object")}}
      {Lisp-Entry "Rect" #f 4231 7 4231 11 ("Object" "Rect-Class")
        {Lisp-Entry "left" #f 4235 8 4235 12 ("generate")}
        {Lisp-Entry "top" #f 4236 8 4236 11 ("generate")}
        {Lisp-Entry "right" #f 4237 8 4237 13 ("generate")}
        {Lisp-Entry "bottom" #f 4238 8 4238 14 ("generate")}
        {Lisp-Entry "initialize" #f 4241 11 4241 21 ("bottom" "right" "top" "left" "set!" "nextmethod" "b" "r" "t" "l")}
        {Lisp-Entry "copy-object" #f 4249 11 4249 22 ("bottom" "right" "top" "left" "Rect" "new" "deep?")}
        {Lisp-Entry "compare-object" #f 4253 11 4253 25 (":not-equal" "else" ":equal" "get-bottom" "bottom" "get-right" "right" "get-top" "top" "get-left" "left" "=" "and" ":incompatible" "Rect" "is-not?" "cond" "target")}
        {Lisp-Entry "fold-literal" #f 4262 11 4262 23 ("bottom" ",bottom" "',bottom" "right" ",right" "',right" "top" ",top" "',top" "left" ",left" "',left" "Rect" "new")}
        {Lisp-Entry "print" #f 4266 11 4266 16 ("bottom" "right" "top" "left" "self" "class-of" "type-name" "identifier-name" "format" "readably" "printer")}}
      {Lisp-Entry "new-rect" #f 4275 27 4275 35 ("Rect" "construct" "bottom" "right" "top" "left")}
      {Lisp-Entry "new" #f 4278 20 4278 23 ("new-rect" "bottom" "right" "top" "left" "class")}
      {Lisp-Entry "rect=" #f 4282 22 4282 27 ()}
      {Lisp-Entry "=" #f 4282 29 4282 30 ("get-bottom" "get-right" "get-top" "get-left" "=" "and" "r2" "r1")}
      {Lisp-Entry "Active-Process" #f 4294 12 4294 26 ()}
      {Lisp-Entry "Process-Active?" #f 4297 12 4297 27 ()}
      {Lisp-Entry "get-process" #f 4301 20 4301 31 ("Active-Process")}
      {Lisp-Entry "get-application" #f 4305 20 4305 35 ("Active-Process")}
      {Lisp-Entry "set-process" #f 4309 13 4309 24 ("Active-Process" "set!" "process")}
      {Lisp-Entry "set-application" #f 4313 13 4313 28 ("Active-Process" "set!" "application")}
      {Lisp-Entry "activate-process" #f 4317 13 4317 29 ("Process-Active?" "set!")}
      {Lisp-Entry "process-active?" #f 4321 13 4321 28 ("Process-Active?")}
      {Lisp-Entry "get-toplevel" #f 4325 13 4325 25 ("get-toplevel" "when" "get-application" "appl" "let")}
      {Lisp-Entry "Slot" #f 4336 7 4336 11 ("Field")
        {Lisp-Entry "offset" #f 4339 8 4339 14 ("generate")}
        {Lisp-Entry "initialize" #f 4340 8 4340 18 ("generate")}}
      {Lisp-Entry "Property" #f 4348 7 4348 15 ("Slot")
        {Lisp-Entry "getter" #f 4351 8 4351 14 ("generate")}
        {Lisp-Entry "setter" #f 4352 8 4352 14 ("generate")}}
      {Lisp-Entry "property?" #f 4355 27 4355 36 ("Property" "is?" "obj")}
      {Lisp-Entry "symbolize-property" #f 4359 20 4359 38 ("else" "keyword->symbol" "keyword?" "get-name" "field?" "cond" "property")}
      {Lisp-Entry "symbolize-properties" #f 4365 20 4365 40 ("get-output" "symbolize-property" "put" "value" "property" "function" "for-each-property" "List-Factory" "new" "fact" "let" "properties")}
      {Lisp-Entry "keywordize-property" #f 4375 20 4375 39 ("else" "keyword?" "field-name" "symbol->keyword" "field?" "cond" "property")}
      {Lisp-Entry "keywordize-properties" #f 4381 20 4381 41 ("get-output" "keywordize-property" "put" "value" "property" "function" "for-each-property" "List-Factory" "new" "fact" "let" "properties")}
      {Lisp-Entry "read-property" #f 4391 20 4391 33 ("property-field" "property-getter" "getter" "let" "expr" "object")}
      {Lisp-Entry "write-property" #f 4396 20 4396 34 ("property-field" "property-setter" "setter" "let" "value" "expr" "object")}
      {Lisp-Entry "property-field" #f 4401 20 4401 34 ("error" "keyword->symbol" "keyword?" "class-of" "category-field" "field" "let" "property?" "if" "expr" "object")}
      {Lisp-Entry "String-Class" #f 4415 7 4415 19 ("Sequence-Class")
        {Lisp-Entry "allocate-sequence" #f 4418 11 4418 28 ("make-string" "len")}
        {Lisp-Entry "coerce-object" #f 4422 11 4422 24 ("coerce-string" "nextmethod" "sequence?" "if" "obj")}}
      {Lisp-Entry "String" #f 4428 17 4428 23 ("Sequence" "String-Class")
        {Lisp-Entry "initialize" #f 4431 11 4431 21 ("native-class" "rest")}
        {Lisp-Entry "compare-object" #f 4435 11 4435 25 (":incompatible" ":greater" "else" ":less" "string<?" ":equal" "self" "string=?" "cond" "string?" "if" "obj")}
        {Lisp-Entry "ci-compare-object" #f 4447 11 4447 28 (":incompatible" ":greater" "else" ":less" "string-ci<?" ":equal" "self" "string-ci=?" "cond" "string?" "if" "obj")}
        {Lisp-Entry "sequence-element" #f 4459 11 4459 27 ("self" "string-ref" "n")}
        {Lisp-Entry "sequence-set-element!" #f 4463 11 4463 32 ("self" "string-set!" "obj" "n")}
        {Lisp-Entry "sequence-cardinality" #f 4467 11 4467 31 ("self" "string-length")}
        {Lisp-Entry "sequence-tail" #f 4471 11 4471 24 ("substring" ">=" "if" "self" "cardinality" "lgt" "let" "n")}
        {Lisp-Entry "sequence-last" #f 4478 11 4478 24 ("1" "cardinality" "-" "self" "element")}
        {Lisp-Entry "sequence-butlast" #f 4482 11 4482 27 ("1" "cardinality" "-" "0" "self" "substring")}}
      {Lisp-Entry "=" #f 4486 20 4486 21 ("string=?" "s2" "s1")}
      {Lisp-Entry "element" #f 4490 20 4490 27 ("string-ref" "n" "string")}
      {Lisp-Entry "set-element!" #f 4494 20 4494 32 ("string-set!" "c" "n" "string")}
      {Lisp-Entry "cardinality" #f 4498 20 4498 31 ("string-length" "string")}
      {Lisp-Entry "subseq" #f 4502 20 4502 26 ("substring" "end" "start" "string")}
      {Lisp-Entry "replace-subseq!" #f 4506 13 4506 28 ("cardinality" "0" "subseq" "string-append" "replacement" "end" "start" "string")}
      {Lisp-Entry "empty-string?" #f 4521 27 4521 40 ("string-length" "zero?" "string?" "and" "object")}
      {Lisp-Entry "->string" #f 4526 20 4526 28 ("get-output-string" "print" "open-output-string" "output" "let" ":human" "':human" "detail" "expr")}
      {Lisp-Entry "remove-trailing-char" #f 4532 20 4532 40 ("0" "subseq" "1" "-" "element" "eqv?" "if" "cardinality" "len" "let" "c" "string")}
      {Lisp-Entry "value-string?" #f 4539 20 4539 33 ("empty-string?" "not" "string?" "and" "object")}
      {Lisp-Entry "wi=" #f 4544 20 4544 23 ("else" "eqv?" "eq?" "continuation-return" "cond" "when" ">=" "increase!" "element" "whitechar?" "and" "set!" "not" "or" "while" "d2?" "=" "d1?" "w2?" "w1?" "s?" "l2" "cardinality" "l1" "n2" "0" "n1" "let*" "return" "function" "continuation-capture" "s2" "s1")}
      {Lisp-Entry "unique-domain-name" #f 4584 20 4584 38 ("increase!" "->string" "set!" "iterate" "let" "suffix" "1" "n" "subseq" "starts-with?" "when" "string" "function" "collect" "suffixes" "cardinality" "common-length" "append" "common-prefix" "let*" "member?" "not" "if" "separator" "separator:" "domain" "name")}
      {Lisp-Entry "remove-numeric-suffix" #f 4604 20 4604 41 ("1" "+" "0" "subseq" "if" "position" "'position" "return:" "reversed?:" "numeric?" "not" "c" "function" "find-if" "pos" "let" "string")}
      {Lisp-Entry "compare-n" #f 4611 13 4611 22 ("1" "+" "string-ref" "not" "or" ">=" "if" "0" "n" "iter" "ylen" "string-length" "xlen" "let" "eqv?" "test" "test:" "max" "y" "x")}
      {Lisp-Entry "string-checksum" #f 4622 13 4622 28 ("1" "+" "string-ref" "char->integer" "increase!" "<" "when" "n" "iter" "string-length" "len" "0" "sum" "let" "str")}
      {Lisp-Entry "primordial-thread-object" #f 4637 12 4637 36 ("current-thread")}
      {Lisp-Entry "primordial-thread" #f 4641 20 4641 37 ("primordial-thread-object")}
      {Lisp-Entry "primordial-thread?" #f 4645 20 4645 38 ("primordial-thread" "current-thread" "eq?")}
      {Lisp-Entry "new-thread" #f 4649 20 4649 30 ("make-root-thread" "apply" "rest" "thunk")}
      {Lisp-Entry "new-system-thread" #f 4655 20 4655 37 ("with-system-exception-debugger" "function" "new-thread" "apply" "rest" "thunk")}
      {Lisp-Entry "top-threads" #f 4663 20 4663 31 ("primordial-thread" "thread-thread-group" "thread-group->thread-list")}
      {Lisp-Entry "present-thread-name" #f 4667 20 4667 39 ("->string" "else" "unspecified?" "not" "or" "cond" "name")}
      {Lisp-Entry "present-thread-state" #f 4672 20 4672 40 ("get-output-string" "else" "when" "write" "thread-state-active-timeout" "thread-state-active-waiting-for" "wf" "thread-state-active?" "thread-state-abnormally-terminated?" "thread-state-normally-terminated?" "thread-state-initialized?" "format" "thread-state-uninitialized?" "cond" "10.0" "*" "round" "/" "current-systime" "systime->seconds" "-" "expiry" "display" "to" "write-timeout" "define" "open-output-string" "port" "let" "state")}
      {Lisp-Entry "present-object" #f 4710 20 4710 34 (":reader" "->string" "exc" "function" "with-exception-catcher" "object")}
      {Lisp-Entry "thread-loop?" #f 4719 20 4719 32 ("thread-specific" "thread")}
      {Lisp-Entry "thread-start-loop" #f 4722 20 4722 37 ("thread-specific-set!" "thread")}
      {Lisp-Entry "thread-stop-loop" #f 4725 20 4725 36 ("thread-specific-set!" "thread")}
      {Lisp-Entry "thread-loop" #f 4729 20 4729 31 ("thread-loop?" "when" "thread-read" "thunk" "loop" "let")}
      {Lisp-Entry "thread-ports" #f 4737 12 4737 24 ("weak-keys:" "eq?" "test:" "make-table")}
      {Lisp-Entry "thread-ports-mutex" #f 4740 12 4740 30 ("thread-ports" "'thread-ports" "make-mutex")}
      {Lisp-Entry "get-thread-port" #f 4743 13 4743 28 ("mutex-unlock!" "table-set!" "open-vector" "port" "let" "thread-ports" "table-ref" "either" "prog1" "thread-ports-mutex" "mutex-lock!" "thread")}
      {Lisp-Entry "thread-write" #f 4751 13 4751 25 ("force-output" "write" "get-thread-port" "thread-port" "let" "value" "thread")}
      {Lisp-Entry "thread-read" #f 4756 13 4756 24 ("read" "+infinity" "input-port-timeout-set!" "current-thread" "get-thread-port" "thread-port" "let")}
      {Lisp-Entry "thread-read-non-blocking" #f 4761 13 4761 37 ("read" "0" "input-port-timeout-set!" "current-thread" "get-thread-port" "thread-port" "let")}
      {Lisp-Entry "thread-post" #f 4767 20 4767 31 ("thread-write" "current-thread" "eq?" "if" "thunk" "name" "thread")}
      {Lisp-Entry "thread-execute" #f 4773 20 4773 34 ("mutex-unlock!" "unwind-protect" "function" "thread-write" "mutex-lock!" "make-mutex" "mutex" "let" "current-thread" "eq?" "if" "thunk" "name" "thread")}
      {Lisp-Entry "thread-call-noresult" #f 4786 12 4786 32 ("thread-call-noresult" "'thread-call-noresult" "list")}
      {Lisp-Entry "thread-call-result?" #f 4790 20 4790 39 ("thread-call-noresult" "neq?" "result")}
      {Lisp-Entry "thread-call" #f 4794 20 4794 31 ("mutex-specific" "mutex-unlock!" "unwind-protect" "function" "thread-write" "thread-call-noresult" "mutex-specific-set!" "mutex-lock!" "make-mutex" "mutex" "eq?" "if" "current-thread" "delegator" "let" "thunk" "name" "thread")}
      {Lisp-Entry "thread-exit" #f 4810 20 4810 31 ("pristine-thread-continuation" "continuation-return")}
      {Lisp-Entry "wait" #f 4819 13 4819 17 ("wait" "'wait" "unimplemented" "delay")}
      {Lisp-Entry "is-not?" #f 4828 27 4828 34 ("is?" "not" "type" "object")}
      {Lisp-Entry "type-name" #f 4832 27 4832 36 ("get-category-name" "type")}
      {Lisp-Entry "type-ascendant" #f 4836 27 4836 41 ("get-class-ascendant" "type")}
      {Lisp-Entry "type-descendants" #f 4840 20 4840 36 ("get-category-descendants" "type")}
      {Lisp-Entry "Vector-Class" #f 4849 7 4849 19 ("Sequence-Class")
        {Lisp-Entry "allocate-sequence" #f 4852 11 4852 28 ("make-vector" "len")}}
      {Lisp-Entry "Vector" #f 4856 17 4856 23 ("Sequence" "Vector-Class")
        {Lisp-Entry "initialize" #f 4859 11 4859 21 ("native-class" "rest")}
        {Lisp-Entry "object-similar?" #f 4864 11 4864 26 ("self" "cardinality" "zero?" "vector?" "and" "object")}
        {Lisp-Entry "sequence-element" #f 4870 11 4870 27 ("self" "vector-ref" "n")}
        {Lisp-Entry "sequence-set-element!" #f 4874 11 4874 32 ("self" "vector-set!" "obj" "n")}
        {Lisp-Entry "sequence-cardinality" #f 4878 11 4878 31 ("self" "vector-length")}
        {Lisp-Entry "sequence-tail" #f 4882 11 4882 24 ("self" "vector->list" "tail" "list->vector" "n")}
        {Lisp-Entry "sequence-last" #f 4886 11 4886 24 ("1" "cardinality" "-" "self" "element")}
        {Lisp-Entry "sequence-butlast" #f 4890 11 4890 27 ("self" "vector->list" "butlast" "list->vector")}}
      {Lisp-Entry "element" #f 4894 20 4894 27 ("vector-ref" "n" "vector")}
      {Lisp-Entry "set-element!" #f 4898 20 4898 32 ("vector-set!" "obj" "n" "vector")}
      {Lisp-Entry "cardinality" #f 4902 20 4902 31 ("vector-length" "vector")}
      {Lisp-Entry "U8Vector-Class" #f 4911 7 4911 21 ("Sequence-Class")
        {Lisp-Entry "allocate-sequence" #f 4914 11 4914 28 ("make-u8vector" "len")}}
      {Lisp-Entry "U8Vector" #f 4918 17 4918 25 ("Sequence" "U8Vector-Class")
        {Lisp-Entry "initialize" #f 4921 11 4921 21 ("native-class" "rest")}
        {Lisp-Entry "object-similar?" #f 4926 11 4926 26 ("self" "cardinality" "zero?" "vector?" "and" "object")}
        {Lisp-Entry "sequence-element" #f 4932 11 4932 27 ("self" "u8vector-ref" "n")}
        {Lisp-Entry "sequence-set-element!" #f 4936 11 4936 32 ("self" "u8vector-set!" "obj" "n")}
        {Lisp-Entry "sequence-cardinality" #f 4940 11 4940 31 ("self" "u8vector-length")}
        {Lisp-Entry "sequence-tail" #f 4944 11 4944 24 ("self" "u8vector->list" "tail" "list->u8vector" "n")}
        {Lisp-Entry "sequence-last" #f 4948 11 4948 24 ("1" "cardinality" "-" "self" "element")}
        {Lisp-Entry "sequence-butlast" #f 4952 11 4952 27 ("self" "u8vector->list" "butlast" "list->u8vector")}}
      {Lisp-Entry "element" #f 4956 20 4956 27 ("u8vector-ref" "n" "vector")}
      {Lisp-Entry "set-element!" #f 4960 20 4960 32 ("u8vector-set!" "obj" "n" "vector")}
      {Lisp-Entry "cardinality" #f 4964 20 4964 31 ("u8vector-length" "vector")}
      {Lisp-Entry "AXIS_MIN_SIZE" #f 4973 12 4973 25 ("8")}
      {Lisp-Entry "AXIS_GOLDEN_RATIO" #f 4974 12 4974 29 ("1.6")}
      {Lisp-Entry "Axis-Class" #f 4977 7 4977 17 ("Sequence-Class")
        {Lisp-Entry "allocate-sequence" #f 4980 11 4980 28 ("Axis" "new" "len")}}
      {Lisp-Entry "Axis" #f 4984 7 4984 11 ("Sequence" "Axis-Class")
        {Lisp-Entry "size" #f 4987 8 4987 12 ("generate")}
        {Lisp-Entry "content" #f 4988 8 4988 15 ("generate")}
        {Lisp-Entry "initialize" #f 4991 11 4991 21 ("make-vector" "content" "size" "set!" "s")}
        {Lisp-Entry "print" #f 4996 11 4996 16 ("content" "size" "format" "function" "self" "print-unreadable" "detail" "output")}
        {Lisp-Entry "sequence-element" #f 5002 11 5002 27 ("self" "element" "n")}
        {Lisp-Entry "sequence-set-element!" #f 5006 11 5006 32 ("self" "set-element!" "obj" "n")}
        {Lisp-Entry "sequence-cardinality" #f 5010 11 5010 31 ("self" "cardinality")}
        {Lisp-Entry "sequence-tail" #f 5014 11 5014 24 ("self" "tail" "n")}
        {Lisp-Entry "sequence-last" #f 5018 11 5018 24 ("self" "last")}}
      {Lisp-Entry "axis" #f 5022 13 5022 17 ("Axis" "coerce" "rest")}
      {Lisp-Entry "element" #f 5026 20 5026 27 ("get-content" "vector-ref" "n" "axis")}
      {Lisp-Entry "set-element!" #f 5030 20 5030 32 ("get-content" "vector-set!" "obj" "n" "axis")}
      {Lisp-Entry "cardinality" #f 5034 20 5034 31 ("get-size" "axis")}
      {Lisp-Entry "tail" #f 5038 13 5038 17 ("1" "+" "element" "set-element!" ">=" "if" "0" "i" "iter" "get-size" "-" "offset" "Axis" "new" "new-axis" "let" "n" "axis")}
      {Lisp-Entry "last" #f 5048 13 5048 17 ("1" "get-size" "-" "element" "axis")}
      {Lisp-Entry "insert!" #f 5052 13 5052 20 ("list" "replace-subseq!" "obj" "pos" "axis")}
      {Lisp-Entry "replace-subseq!" #f 5056 13 5056 28 ("axis-grow" "1" "element" "set-element!" "0" ">" "when" "dst" "src" "n" "iter" "let" "<" "cond" "+" "new-size" "get-size" "old-size" "delta" "cardinality" "after" "-" "before" "let*" "replacement" "end" "start" "axis")}
      {Lisp-Entry "axis-remove!" #f 5086 20 5086 32 ("replace-subseq!" "1" "+" "end" "start" "let*" "when" "find" "n" "let" "element" "axis")}
      {Lisp-Entry "axis-grow" #f 5094 20 5094 29 ("1" "+" "element" "set-element!" "begin" "<" "when" "i" "iter" "AXIS_GOLDEN_RATIO" "*" "fxround" "old-content" "old-real-size" "let" "else" "AXIS_MIN_SIZE" "make-vector" "set-content" "0" "get-size" "=" "set-size" "get-content" "cardinality" "<=" "cond" "n" "axis")}
      {Lisp-Entry "axis-add" #f 5112 20 5112 28 ("set-element!" "1" "+" "axis-grow" "cardinality" "size" "let" "obj" "axis")}
      {Lisp-Entry "new-axis" #f 5118 27 5118 35 ("make-vector" "Axis" "construct" "size")}
      {Lisp-Entry "new" #f 5121 20 5121 23 ("new-axis" "size" "class")}
      {Lisp-Entry "allocate" #f 5125 13 5125 21 ("new-axis" "size" "class")}
      {Lisp-Entry "coerce" #f 5129 13 5129 19 ("element" "set-element!" "below" "0" "from" "n" "for" "loop" "allocate" "new-sequence" "cardinality" "len" "let" "class" "seq")}
      {Lisp-Entry "axis-ref" #f 5137 22 5137 30 ()}
      {Lisp-Entry "element" #f 5137 32 5137 39 ("get-content" "vector-ref" "n" "axis")}
      {Lisp-Entry "axis-set!" #f 5141 22 5141 31 ()}
      {Lisp-Entry "set-element!" #f 5141 33 5141 45 ("get-content" "vector-set!" "obj" "n" "axis")}
      {Lisp-Entry "axis-cardinality" #f 5145 22 5145 38 ()}
      {Lisp-Entry "cardinality" #f 5145 40 5145 51 ("get-size" "axis")}
      {Lisp-Entry "box-list" #f 5159 20 5159 28 ("cons" "lst")}
      {Lisp-Entry "unbox-list" #f 5163 20 5163 30 ("cdr" "box")}
      {Lisp-Entry "Enumeration" #f 5173 7 5173 18 ("Type")
        {Lisp-Entry "name" #f 5176 8 5176 12 ()}
        {Lisp-Entry "entries" #f 5177 8 5177 15 ()}
        {Lisp-Entry "construct-literal" #f 5181 16 5181 33 ("self" "new" "entries" "name" "context")}
        {Lisp-Entry "initialize" #f 5185 11 5185 21 ("entries~self" "name~self" "set!" "Enumeration" "nextmethod" "entries" "name")}
        {Lisp-Entry "foldable?" #f 5192 11 5192 20 ()}
        {Lisp-Entry "fold-object" #f 5197 11 5197 22 ("entries" "name" "fold-more" "self" "class-of" "type-name" "fold" "output" "compiler")}
        {Lisp-Entry "print" #f 5205 11 5205 16 ("entries" "name" "self" "class-of" "type-name" "format" "readably" "printer")}
        {Lisp-Entry "get-name" #f 5212 18 5212 26 ("name")}
        {Lisp-Entry "get-entries" #f 5216 18 5216 29 ("entries")}
        {Lisp-Entry "set-value" #f 5220 18 5220 27 ("entry-from-name" "cdr" "set-car!" "value" "name")}
        {Lisp-Entry "get-size" #f 5224 11 5224 19 ("int" "size-of")}
        {Lisp-Entry "read-content" #f 5228 11 5228 23 ("%read-int" "address")}
        {Lisp-Entry "write-content" #f 5232 11 5232 24 ("%write-int" "object" "address")}
        {Lisp-Entry "entry-from-name" #f 5236 11 5236 26 ("self" "error" "eq?" "test:" "first" "key:" "entries" "find-in" "either" "name")}
        {Lisp-Entry "entry-from-value" #f 5241 11 5241 27 ("self" "error" "eqv?" "test:" "second" "key:" "entries" "find-in" "either" "value")}
        {Lisp-Entry "value->name" #f 5246 18 5246 29 ("entry-from-value" "car" "value")}
        {Lisp-Entry "name->value" #f 5250 18 5250 29 ("entry-from-name" "cadr" "name")}
        {Lisp-Entry "get-rank" #f 5254 18 5254 26 ("eq?" "test:" "first" "key:" "entries" "find" "1" "+" "0" "name" "=" "if" "target")}}
      {Lisp-Entry "enumeration?" #f 5260 27 5260 39 ("enumeration?" "'enumeration?" "unimplemented" "object")}
      {Lisp-Entry "set-enumeration!" #f 5264 20 5264 36 ("set-value" "set-enumeration!" "'set-enumeration!" "unimplemented" "value" "name" "enumeration")}
      {Lisp-Entry "parse-file" #f 5275 20 5275 30 ("parse" "string?" "if" "file")}
      {Lisp-Entry "Chunk-Size" #f 5281 12 5281 22 ("1024")}
      {Lisp-Entry "make-u8-content" #f 5285 13 5285 28 ("cons" "content" "size")}
      {Lisp-Entry "u8-content-size" #f 5288 13 5288 28 ("car" "content")}
      {Lisp-Entry "iterate-u8-content" #f 5291 13 5291 31 ("cdr" "size" "u8vector" "bind" "chunk" "function" "for-each" "proc" "content")}
      {Lisp-Entry "read-u8-content" #f 5298 13 5298 28 ("cons" "put" "increase!" "get-output" "make-u8-content" "=" "if" "read-subu8vector" "read" "Chunk-Size" "make-u8vector" "u8vector" "loop" "List-Factory" "new" "fact" "0" "size" "let" "port")}
      {Lisp-Entry "write-u8-content" #f 5311 13 5311 29 ("0" "write-subu8vector" "size" "u8vector" "function" "iterate-u8-content" "port" "content")}
      {Lisp-Entry "Permanent-Port" #f 5318 7 5318 21 ("Object")
        {Lisp-Entry "port" #f 5321 8 5321 12 ("generate")}
        {Lisp-Entry "eof?" #f 5322 8 5322 12 ("generate")}
        {Lisp-Entry "initialize" #f 5325 11 5325 21 ("eof?~self" "port~self" "set!" "nextmethod" "port")}}
      {Lisp-Entry "read-substring-blocking-for-1" #f 5331 13 5331 42 ("else" "not" "len" "set!" "function" "-inf.0" "to?" "=" "and" "if" "1" "+" "read-substring" "n" "+inf.0" "input-port-timeout-set!" "get-port" "port" "let" "<" "0" "set-eof?" "get-eof?" "cond" "permanent-port" "end" "start" "str")}
      {Lisp-Entry "start-pump" #f 5353 13 5353 23 ("substring" ">" "if" "0" "read-substring-blocking-for-1" "n" "iterate" "make-string" "buffer" "1000" "size" "let" "proper-tail-calls" "declare" "proc" "permanent-port")}
      {Lisp-Entry "read-until" #f 5371 20 5371 30 ("enqueue" "queue-list" "if" "read" "expr" "iterate" "new-queue" "queue" "let" "reader" "test")}
      {Lisp-Entry "read-string-element" #f 5381 20 5381 39 ("read" "call-with-input-string" "string")}
      {Lisp-Entry "read-string-content" #f 5386 20 5386 39 ("eof-object?" "read-until" "reader" "function" "call-with-input-string" "string")}
      {Lisp-Entry "read-delimited-string" #f 5392 20 5392 41 ("get-output" "peek-char" "eof-object?" "if" "skip-whites" "put" "read-delimited" "lst" "iterate" "List-Factory" "new" "fact" "let" "reader" "function" "call-with-input-string" "char" "string")}
      {Lisp-Entry "parse-integer" #f 5405 20 5405 33 ("type:" "object:" "Convertion-Error" "new" "signal" "read-string-element" "numeric?" "empty-string?" "not" "and" "if" "string")}
      {Lisp-Entry "parse-hexadecimal" #f 5411 20 5411 37 ("format" "read-string-element" "string")}
      {Lisp-Entry "parse-boolean" #f 5415 20 5415 33 ("type:" "object:" "Convertion-Error" "new" "signal" "else" "ci=?" "or" "not" "cond" "string")}
      {Lisp-Entry "parse-strings" #f 5422 20 5422 33 ("split" "trim-spaces" "function" "map" "=" "empty-string?" "or" "if" "separator" "separator:" "string")}
      {Lisp-Entry "parse-delimited-string" #f 5430 20 5430 42 ("parse-strings" "function" "map" "separator" "separator:" "string")}
      {Lisp-Entry "require-char" #f 5436 20 5436 32 ("error" "eof-object?" "if" "read-char" "c" "let" "reader")}
      {Lisp-Entry "skip-line" #f 5443 20 5443 29 ("eqv?" "eof-object?" "not" "and" "if" "read-char" "c" "iterate" "let" "reader")}
      {Lisp-Entry "skip-whites" #f 5454 20 5454 31 ("read-char" "whitespace?" "when" "skip-line" "eqv?" "if" "eof-object?" "unless" "peek-char" "c" "iterate" "let" "reader")}
      {Lisp-Entry "read-delimited" #f 5465 20 5465 34 ("enqueue" "else" "read" "enqueue-list" "read-char" "eqv?" "error" "queue-list" "if" "eof-object?" "cond" "peek-char" "c" "skip-whites" "iterate" "new-queue" "queue" "let" "allow-eof?" "delimiter" "kind" "reader")}
      {Lisp-Entry "string-delimiter?" #f 5485 27 5485 44 ("eqv?" "c")}
      {Lisp-Entry "read-lines" #f 5489 13 5489 23 ("queue-list" "when" "enqueue" "begin" "if" "read-proper-line" "proper?" "line" "receive" "last-proper?" "iterate" "new-queue" "queue" "let" "proper-tail-calls" "declare" "reader")}
      {Lisp-Entry "read-content-string" #f 5503 20 5503 39 ("eof-object?" "if" "read-line" "line" "let" "reader")}
      {Lisp-Entry "pipe" #f 5512 20 5512 24 ("write-char" "begin" "eof-object?" "not" "if" "read-char" "c" "iterate" "let" "output" "input")}
      {Lisp-Entry "*console-port-getter*" #f 5526 12 5526 33 ()}
      {Lisp-Entry "set-console-port-getter" #f 5530 13 5530 36 ("*console-port-getter*" "set!" "getter")}
      {Lisp-Entry "get-console-port" #f 5534 13 5534 29 ("terminal-port" "*console-port-getter*" "not" "if")}
      {Lisp-Entry "console-input-port" #f 5540 20 5540 38 ("get-console-port")}
      {Lisp-Entry "console-output-port" #f 5543 20 5543 39 ("get-console-port")}
      {Lisp-Entry "force-console" #f 5547 20 5547 33 ("get-console-port" "force-output")}
      {Lisp-Entry "console" #f 5556 20 5556 27 ("format" "console-string" "rest")}
      {Lisp-Entry "console-string" #f 5560 20 5560 34 ("force-output" "format" "terminal-string" "not" "if" "console-output-port" "output" "let" "color" "color:" "string")}
      {Lisp-Entry "debug" #f 5573 19 5573 24 ("console")}
      {Lisp-Entry "debug-string" #f 5577 19 5577 31 ("console-string")}
      {Lisp-Entry "continuation-stack" #f 5586 20 5586 38 ("get-continuation-dynamic-environment" "append" "else" "get-continuation-lexical-environment" "cons" "not" "and" "cond" "get-continuation-name" "name" "function" "map" "get-continuation-stack" "stack" "let" "depth" "depth:" "lexical-environment?" "lexical-environment?:" "dynamic-environment?" "dynamic-environment?:" "cont")}
      {Lisp-Entry "execution-stack" #f 5600 20 5600 35 ("continuation-stack" "cont" "function" "continuation-capture" "depth" "depth:" "lexical-environment?" "lexical-environment?:" "dynamic-environment?" "dynamic-environment?:")}
      {Lisp-Entry "with-printer" #f 5611 20 5611 32 ("else" "get-console-port" ":console" "terminal-port" ":terminal" "get-output-string" "open-output-string" "let" ":string" "case" "proc" "printer")}
      {Lisp-Entry "textual" #f 5625 13 5625 20 (":text" "print" "write" "current-output-port" "printer" "expr")}
      {Lisp-Entry "describe" #f 5631 13 5631 21 (":describe" "print" "current-output-port" "printer" "expr")}
      {Lisp-Entry "print-expr" #f 5635 13 5635 23 ("print" "current-output-port" "printer" "detail" "expr")}
      {Lisp-Entry "print-unsigned" #f 5639 13 5639 27 ("print-unsigned" "'print-unsigned" "unimplemented" "current-output-port" "printer" "n")}
      {Lisp-Entry "print-binary" #f 5643 13 5643 25 ("2" "number->string" "display" "current-output-port" "printer" "n")}
      {Lisp-Entry "print-hexadecimal" #f 5647 13 5647 30 ("16" "number->string" "display" "current-output-port" "printer" "n")}
      {Lisp-Entry "print-real" #f 5651 13 5651 23 ("new-frac" ">" "and" "carry?" "dot-pos" "or" "if" "len" "string->number" "round" "temp-str" "last-part" "first-part" "else" "-" "make-string" "string-append" "<" "display" "=" "cond" "frac-len" "string-length" "1" "+" "frac-str" "0" "substring" "pre-str" "find" "dot-index" "exact->inexact" "number->string" "str" "let*" "current-output-port" "printer" "precision" "r")}
      {Lisp-Entry "print-list" #f 5690 13 5690 23 ("null?" "pair?" "if" "cdr" "next" "print" "car" "expr" "scan" "iter" "let" "display" "not-null?" "when" "current-output-port" "printer" "detail" "after" "before" "last-separator" "separator" "list")}
      {Lisp-Entry "fresh-line" #f 5708 13 5708 23 ("newline" "at-fresh-line?" "unless" "current-output-port" "printer")}
      {Lisp-Entry "at-fresh-line?" #f 5713 13 5713 27 ("current-output-port" "printer")}
      {Lisp-Entry "pp" #f 5723 19 5723 21 ("pretty-print")}
      {Lisp-Entry "print-unreadable" #f 5727 20 5727 36 ("format" "object->serial" "serial" "empty-string?" "if" "spacer" "get-output-string" "open-output-string" "let" "string" "class-of" "get-name" "identifier-name" "class-name" "let*" "proc" "output" "object")}
      {Lisp-Entry "present-identifier" #f 5737 20 5737 38 ("0" "1" "element" "format" "reverse!" "reversed" "car" "cdr" "null?" "if" "symbol->string" "split" "names" "let" "identifier")}
      {Lisp-Entry "write-line" #f 5745 20 5745 30 ("newline" "display" "car" "null?" "if" "port" "let" "rest" "line")}
      {Lisp-Entry "write-lines" #f 5751 20 5751 31 ("newline" "null?" "unless" "display" "do" "remain" "remainder" "in" "line" "for" "loop" "lines" "printer")}
      {Lisp-Entry "Format-Processor" #f 5776 7 5776 23 ("Object")
        {Lisp-Entry "out" #f 5779 8 5779 11 ()}
        {Lisp-Entry "control-string" #f 5780 8 5780 22 ()}
        {Lisp-Entry "control-reader" #f 5781 8 5781 22 ()}
        {Lisp-Entry "arguments" #f 5782 8 5782 17 ()}
        {Lisp-Entry "arguments-iterator" #f 5783 8 5783 26 ()}
        {Lisp-Entry "formatter" #f 5784 8 5784 17 ()}
        {Lisp-Entry "initialize" #f 5787 11 5787 21 ("formatter~self" "List-Iterator" "new" "arguments-iterator~self" "arguments~self" "open-input-string" "control-reader~self" "control-string~self" "set!" "nextmethod" "arguments" "control-string")}
        {Lisp-Entry "process-format" #f 5801 11 5801 25 ("control-reader" "process" "out" "set!" "printer" "function" "with-printer" "destination")}
        {Lisp-Entry "process" #f 5813 11 5813 18 ("arguments-empty?" "toplevel?" "and" "localize-directive" "z" "force-directive" "!" "freshline-directive" "$" "newline-directive" "%" "tab-directive" "&" "column-directive" "_" "properties-directive" "k" "list-directive" "l" "real-directive" "r" "hexadecimal-directive" "x" "binary-directive" "b" "unsigned-directive" "u" "char-directive" "print-directive" "p" "text-directive" "t" "sexpr-directive" "s" "ascii-directive" "a" "read-parameters" "parameters" "read" "directive" "else" "conditional-directive" "error" "peek-char" "out" "write-char" "when" "require-char" "case" "set!" "eof-object?" "if" "read-char" "c" "not" "while" "done?" "let" "output?" "reader")}
        {Lisp-Entry "read-parameters" #f 5861 11 5861 26 ("read-delimited" "reader")}
        {Lisp-Entry "toplevel?" #f 5865 11 5865 20 ("control-reader" "eq?" "reader")}
        {Lisp-Entry "arguments-empty?" #f 5869 11 5869 27 ("arguments-iterator" "done?")}
        {Lisp-Entry "conditional-directive" #f 5878 11 5878 32 ("else" "process-conditional" "read-char" "peek-char" "eqv?" "cond" "reader")}
        {Lisp-Entry "read-control-string" #f 5886 11 5886 30 ("get-output-string" "write-char" "set!" "read-char" "begin" "peek-char" "eqv?" "and" "if" "require-char" "c" "not" "while" "done?" "open-output-string" "printer" "let" "reader")}
        {Lisp-Entry "process-conditional" #f 5899 11 5899 30 ("process" "peek-argument" "not" "next-argument" "and" "or" "output?" "read-control-string" "open-input-string" "subreader" "let" "explicit?" "reader")}
        {Lisp-Entry "ascii-directive" #f 5910 11 5910 26 ("display" "printer" "function" "with-justification" "when" "next-argument" "argument" "let" "output?" "parameters")}
        {Lisp-Entry "sexpr-directive" #f 5918 11 5918 26 ("write" "printer" "function" "with-justification" "when" "next-argument" "argument" "let" "output?" "parameters")}
        {Lisp-Entry "text-directive" #f 5926 11 5926 25 ("textual" "printer" "function" "with-justification" "when" "next-argument" "argument" "let" "output?" "parameters")}
        {Lisp-Entry "print-directive" #f 5934 11 5934 26 ("print-expr" "printer" "function" "with-justification" "when" "detail" "next-argument" "argument" "let" "output?" "parameters")}
        {Lisp-Entry "char-directive" #f 5943 11 5943 25 ("write-char" "printer" "function" "with-justification" "when" "next-argument" "argument" "let" "output?" "parameters")}
        {Lisp-Entry "unsigned-directive" #f 5951 11 5951 29 ("print-unsigned" "printer" "function" "with-justification" "when" "next-argument" "argument" "let" "output?" "parameters")}
        {Lisp-Entry "binary-directive" #f 5959 11 5959 27 ("print-binary" "printer" "function" "with-justification" "when" "next-argument" "argument" "let" "output?" "parameters")}
        {Lisp-Entry "hexadecimal-directive" #f 5967 11 5967 32 ("print-hexadecimal" "printer" "function" "with-justification" "when" "next-argument" "argument" "let" "output?" "parameters")}
        {Lisp-Entry "real-directive" #f 5975 11 5975 25 ("print-real" "printer" "function" "with-justification" "when" "get-precision" "precision" "next-argument" "argument" "let" "output?" "parameters")}
        {Lisp-Entry "list-directive" #f 5984 11 5984 25 ("print-list" "printer" "function" "with-justification" "when" "get-detail" "detail" "get-after" "after" "get-before" "before" "get-last-separator" "last-separator" "get-separator" "separator" "next-argument" "argument" "let*" "output?" "parameters")}
        {Lisp-Entry "properties-directive" #f 5997 11 5997 31 ("cddr" "set!" "print-expr" "write-char" "neq?" "not" "memq?" "null?" "or" "and" "cadr" "value" "car" "key" "not-null?" "while" "scan" "printer" "function" "with-justification" "when" "get-detail" "detail" "get-empty-value" "empty-value" "get-properties" "properties" "next-argument" "argument" "let" "output?" "parameters")}
        {Lisp-Entry "column-directive" #f 6018 11 6018 27 ("out" "write-char" "do" "repeat" "loop" "1" "optional-parameter" "count" "let" "when" "output?" "parameters")}
        {Lisp-Entry "tab-directive" #f 6025 11 6025 24 ("out" "write-char" "do" "repeat" "loop" "1" "optional-parameter" "count" "let" "when" "output?" "parameters")}
        {Lisp-Entry "newline-directive" #f 6032 11 6032 28 ("out" "newline" "do" "repeat" "loop" "1" "optional-parameter" "count" "let" "when" "output?" "parameters")}
        {Lisp-Entry "freshline-directive" #f 6039 11 6039 30 ("newline" "do" "-" "repeat" "loop" "out" "fresh-line" "1" "optional-parameter" "count" "let" "when" "output?" "parameters")}
        {Lisp-Entry "force-directive" #f 6047 11 6047 26 ("out" "force-output" "when" "output?" "parameters")}
        {Lisp-Entry "localize-directive" #f 6052 11 6052 29 ("display" "printer" "function" "with-justification" "when" "next-argument" "localize" "argument" "let" "localize-directive" "'localize-directive" "unimplemented" "output?" "parameters")}
        {Lisp-Entry "with-justification" #f 6067 11 6067 29 ("justify" "get-output-string" "buffer" "open-output-string" "printer" "get-padding" "padding" "get-justify" "justification" "out" "not" "if" "get-width" "width" "let" "proc" "parameters")}
        {Lisp-Entry "justify" #f 6079 11 6079 18 (":right" "write-char" "do" "repeat" "loop" ":left" "case" "-" "n" "out" "display" ">=" "if" "cardinality" "size" "let" "padding" "justification" "width" "buffer")}
        {Lisp-Entry "optional-parameter" #f 6100 11 6100 29 ("next-argument" ":v" "eq?" "car" "param" "let" "null?" "if" "default" "parameters")}
        {Lisp-Entry "keyword-parameter" #f 6109 11 6109 28 ("next-argument" ":v" "eq?" "if" "not-found:" "getf" "param" "let" "default" "keyword" "parameters")}
        {Lisp-Entry "get-list?" #f 6116 11 6116 20 ("list?:" "keyword-parameter" "parameters")}
        {Lisp-Entry "get-width" #f 6120 11 6120 20 ("width:" "keyword-parameter" "parameters")}
        {Lisp-Entry "get-justify" #f 6124 11 6124 22 ("error" ":right" "memq?" "not" "if" ":left" "justify:" "keyword-parameter" "param" "let" "parameters")}
        {Lisp-Entry "get-padding" #f 6131 11 6131 22 ("padding:" "keyword-parameter" "parameters")}
        {Lisp-Entry "get-separator" #f 6135 11 6135 24 ("separator:" "keyword-parameter" "parameters")}
        {Lisp-Entry "get-last-separator" #f 6139 11 6139 29 ("last-separator:" "keyword-parameter" "separator" "parameters")}
        {Lisp-Entry "get-before" #f 6143 11 6143 21 ("before:" "keyword-parameter" "parameters")}
        {Lisp-Entry "get-after" #f 6147 11 6147 20 ("after:" "keyword-parameter" "parameters")}
        {Lisp-Entry "get-precision" #f 6151 11 6151 24 ("3" "precision:" "keyword-parameter" "parameters")}
        {Lisp-Entry "get-properties" #f 6155 11 6155 25 ("properties:" "keyword-parameter" "parameters")}
        {Lisp-Entry "get-empty-value" #f 6159 11 6159 26 ("empty-value:" "keyword-parameter" "parameters")}
        {Lisp-Entry "get-detail" #f 6163 11 6163 21 (":reader" "detail:" "keyword-parameter" "parameters")}
        {Lisp-Entry "peek-argument" #f 6172 11 6172 24 ("peek" "control-string" "error" "arguments-iterator" "done?" "if")}
        {Lisp-Entry "next-argument" #f 6178 11 6178 24 ("get-next" "control-string" "error" "arguments-iterator" "done?" "if")}}
      {Lisp-Entry "Formatting" #f 6190 7 6190 17 ("Reader")
        {Lisp-Entry "read-string" #f 6193 18 6193 29 ("self" "formatting-read-string")}
        {Lisp-Entry "read-parameters" #f 6197 18 6197 33 ("self" "formatting-read-parameters")}}
      {Lisp-Entry "parse-format" #f 6206 13 6206 25 ("cddr" "cadr" "cdr" ":string" "':string" "car" "string?" "if" "proc" "rest")}
      {Lisp-Entry "format" #f 6212 20 6212 26 ("process-format" "Format-Processor" "new" "processor" "let" "arguments" "control-string" "destination" "function" "jazz.parse-format" "rest")}
      {Lisp-Entry "format-cardinality" #f 6224 20 6224 38 ("->string" "0" "=" "if" "n")}
      {Lisp-Entry "format-plural" #f 6230 20 6230 33 ("1" "=" "if" "plural" "n")}
      {Lisp-Entry "format-gender" #f 6236 20 6236 33 ("first" "vowel?" "if" "word")}
      {Lisp-Entry "format-is/are" #f 6242 20 6242 33 ("1" "=" "if" "n")}
      {Lisp-Entry "format-was/were" #f 6248 20 6248 35 ("1" "=" "if" "n")}
      {Lisp-Entry "format-y/ies" #f 6254 20 6254 32 ("1" "=" "if" "n")}
      {Lisp-Entry "format-following" #f 6260 20 6260 36 ("format" "1" "=" "if" "n" "name")}
      {Lisp-Entry "identity" #f 6271 27 6271 35 ("x")}
      {Lisp-Entry "compose" #f 6275 27 6275 34 ("x" "function" "g" "f")}
      {Lisp-Entry "profile" #f 6286 15 6286 22 (",condition" ",name" "%profile" ",@body" "begin" "not" "if" ":condition" "condition" "name:" "name" "not-found:" "unwrap-syntax" "key:" ":on?" "getf" "on?" "cdr" "body" "car" "control" "let" "expressions")}
      {Lisp-Entry "build-search-automata" #f 6303 13 6303 34 ("build-search-automata" "'build-search-automata" "unimplemented" "constituent-test" "object" "ignore-case?" "whole-words?" "targets")}
      {Lisp-Entry "automata-statistics" #f 6307 13 6307 32 ("automata-statistics" "'automata-statistics" "unimplemented" "automata")}
      {Lisp-Entry "automata-search" #f 6311 13 6311 28 ("automata-search" "'automata-search" "unimplemented" "col" "row" "limit" "paragraphs" "automata")}
      {Lisp-Entry "Subseq-Class" #f 6320 7 6320 19 ("Sequence-Class")}
      {Lisp-Entry "Subseq" #f 6323 7 6323 13 ("Sequence" "Subseq-Class")
        {Lisp-Entry "sequence" #f 6326 8 6326 16 ("generate")}
        {Lisp-Entry "start" #f 6327 8 6327 13 ("generate")}
        {Lisp-Entry "size" #f 6328 8 6328 12 ("generate")}
        {Lisp-Entry "initialize" #f 6331 11 6331 21 ("size~self" "start~self" "sequence~self" "set!" "nextmethod" "size" "start" "sequence")}
        {Lisp-Entry "print" #f 6338 11 6338 16 ("format" "function" "self" "print-unreadable" "string-ref" "write-char" "do" "size" "+" "below" "start" "from" "n" "for" "loop" "sequence" "string?" "if" "detail" "output")}
        {Lisp-Entry "coerce-string" #f 6348 11 6348 24 ("error" "size" "+" "start" "substring" "sequence" "string?" "if")}
        {Lisp-Entry "sequence-element" #f 6354 11 6354 27 ("start" "+" "sequence" "element" "n")}
        {Lisp-Entry "sequence-set-element!" #f 6358 11 6358 32 ("start" "+" "sequence" "set-element!" "obj" "n")}
        {Lisp-Entry "sequence-cardinality" #f 6362 11 6362 31 ("size")}
        {Lisp-Entry "sequence-subseq!" #f 6366 11 6366 27 ("cardinality" "-" "start" "+" "sequence" "Subseq" "new" "self" "-1" "0" "=" "or" "if" "e" "s")}}
      {Lisp-Entry "offset-subseq!" #f 6372 13 6372 27 ("get-start" "+" "set-start" "offset" "subseq")}
      {Lisp-Entry "grow-subseq!" #f 6376 13 6376 25 ("get-size" "+" "set-size" "n" "subseq")}
      {Lisp-Entry "subseq-ref" #f 6380 22 6380 32 ()}
      {Lisp-Entry "element" #f 6380 34 6380 41 ("get-start" "+" "get-sequence" "element" "n" "subseq")}
      {Lisp-Entry "subseq-set!" #f 6384 22 6384 33 ()}
      {Lisp-Entry "set-element!" #f 6384 35 6384 47 ("get-start" "+" "get-sequence" "set-element!" "obj" "n" "subseq")}
      {Lisp-Entry "subseq-cardinality" #f 6388 22 6388 40 ()}
      {Lisp-Entry "cardinality" #f 6388 42 6388 53 ("get-size" "subseq")}
      {Lisp-Entry "Subseq$string$-Class" #f 6397 7 6397 27 ("Sequence-Class")}
      {Lisp-Entry "Subseq$string$" #f 6400 7 6400 21 ("Sequence" "Subseq$string$-Class")
        {Lisp-Entry "sequence" #f 6403 8 6403 16 ("generate")}
        {Lisp-Entry "start" #f 6404 8 6404 13 ("generate")}
        {Lisp-Entry "size" #f 6405 8 6405 12 ("generate")}
        {Lisp-Entry "initialize" #f 6408 11 6408 21 ("size~self" "start~self" "sequence~self" "set!" "nextmethod" "size" "start" "sequence")}
        {Lisp-Entry "print" #f 6415 11 6415 16 ("size" "+" "start" "sequence" "substring" "display" "detail" "output")}
        {Lisp-Entry "sequence-element" #f 6420 11 6420 27 ("start" "+" "sequence" "element" "n")}
        {Lisp-Entry "sequence-set-element!" #f 6424 11 6424 32 ("start" "+" "sequence" "set-element!" "obj" "n")}
        {Lisp-Entry "sequence-cardinality" #f 6428 11 6428 31 ("size")}
        {Lisp-Entry "sequence-subseq!" #f 6432 11 6432 27 ("cardinality" "-" "start" "+" "sequence" "Subseq$string$" "new" "self" "-1" "0" "=" "or" "if" "e" "s")}}
      {Lisp-Entry "new" #f 6438 20 6438 23 ("Subseq$string$" "construct" "size" "start" "sequence" "class")}
      {Lisp-Entry "element" #f 6442 20 6442 27 ("get-start" "+" "get-sequence" "element" "n" "subseq")}
      {Lisp-Entry "set-element!" #f 6446 20 6446 32 ("get-start" "+" "get-sequence" "set-element!" "obj" "n" "subseq")}
      {Lisp-Entry "cardinality" #f 6450 20 6450 31 ("get-size" "subseq")}
      {Lisp-Entry "subseq!" #f 6454 13 6454 20 ("-" "Subseq$string$" "new" "e" "s" "seq")}
      {Lisp-Entry "subseq!" #f 6458 13 6458 20 ("-" "get-start" "+" "get-sequence" "Subseq$string$" "new" "e" "s" "subseq")}
      {Lisp-Entry "offset-subseq!" #f 6462 13 6462 27 ("get-start" "+" "set-start" "offset" "subseq")}
      {Lisp-Entry "grow-subseq!" #f 6466 13 6466 25 ("get-size" "+" "set-size" "n" "subseq")}
      {Lisp-Entry "syntax?" #f 6475 27 6475 34 ("syntax?" "'syntax?" "unimplemented" "expr")}
      {Lisp-Entry "unwrap-syntax" #f 6479 20 6479 33 ("syntax-expression" "syntax?" "if" "unwrap-syntax" "'unwrap-syntax" "unimplemented" "expr")}
      {Lisp-Entry "word-constituent?" #f 6496 20 6496 37 ("memq?" "numeric?" "alphabetic?" "or" "c")}}})
"_literals"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "literals" "_literals.jazz"} 1238328026
    {Lisp-Entry "jazz.literals" #f 37 9 37 22 ("jazz")}})
"_performance"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "test" "performance" "_performance.scm"} 1237033585
    {Lisp-Entry "test.performance" #f 0 8 0 24 ()}})
"_syntax"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "dialect" "syntax" "_syntax.scm"} 1238328026
    {Lisp-Entry "jazz.dialect.syntax" #f 37 19 37 38 ("scheme")}})
"_test"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "test" "_test.jazz"} 1244896780
    {Lisp-Entry "jazz.test" #f 37 9 37 18 ("'a" "5" "set-element!" "10" "axis-grow" "0" "Axis" "new" "axis" "let" "for-each" "3" "2" "Point" "b" "a" "debug" "jazz")
      {Lisp-Entry "Y" #f 286 7 286 8 ("X")
        {Lisp-Entry "f" #f 289 16 289 17 ("2")}}
      {Lisp-Entry "Y~Class207" #f 295 9 295 19 ()
        {Lisp-Entry "f" #f 298 13 298 14 ("2")}}
      {Lisp-Entry "Y" #f 302 9 302 10 ("X" "Y~Class207")}
      {Lisp-Entry "f" #f 399 13 399 14 ("=" "not" "if" "c")}
      {Lisp-Entry "f" #f 461 13 461 14 ("+" "0" "n" "iter" "let")}
      {Lisp-Entry "TC" #f 468 7 468 9 ("Object")
        {Lisp-Entry "row" #f 471 8 471 11 ("1")}
        {Lisp-Entry "col" #f 472 8 472 11 ("3")}
        {Lisp-Entry "f" #f 475 11 475 12 ("col" "0" "subseq!" "row" "when")}
        {Lisp-Entry "g" #f 480 11 480 12 ("col" "0" "subseq!")}}
      {Lisp-Entry "f" #f 485 13 485 14 ("g" "TC" "new" "f" "class-of" "list")}}})
"a"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "test" "a.jazz"} 1237033585
    {Lisp-Entry "jazz.test.a" #f 0 9 0 20 ("jazz")}}
  {Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "test" "performance" "a.scm"} 1237033585
    {Lisp-Entry "test.performance.a" #f 0 8 0 26 ("safe" "not" "standard-bindings" "block" "declare")
      {Lisp-Entry "f-separate" #f 8 9 8 19 ("1" "%%fx-" "g-separate" "0" "%%fx=" "if" "n" "s")}}})
"attributes"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "dialect" "syntax" "attributes.scm"} 1238328026
    {Lisp-Entry "jazz.dialect.syntax.attributes" #f 37 19 37 49 ("scheme")
      {Lisp-Entry "attributes" #f 81 8 81 18 ("set-property" ",setter" ",getter" "public" "setter" "format" "string->symbol" "getter" "let*" "set!" "'set!" ",value" "set-value" "nextmethod" "else" "list" "case" ",property" "get-value" ",init" ",name" "slot" "eq?" "if" "unspecified" "not-found:" "initialize" "'initialize" "getf" "init" "rest" "specifier" "parse-specifier" "name" "lambda" "append" "symbol->keyword" "map" "node-properties" "method" "begin" "value" "generate-symbol" "property" "cdr" "properties" "car" "inherited" "let" "form")
        {Lisp-Entry "unspecified" #f 82 10 82 21 ("cons")}
        {Lisp-Entry "symbol->keyword" #f 85 11 85 26 ("symbol->string" "string->keyword" "symbol")}}}})
"autoload"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "test" "autoload.jazz"} 1237033585
    {Lisp-Entry "jazz.test.autoload" #f 0 9 0 27 ("jazz")}})
"b"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "test" "b.jazz"} 1237033585
    {Lisp-Entry "jazz.test.b" #f 0 9 0 20 ("jazz")
      {Lisp-Entry "Version" #f 6 7 6 14 ("Object")}}}
  {Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "test" "performance" "b.scm"} 1237033585
    {Lisp-Entry "test.performance.b" #f 0 8 0 26 ("safe" "not" "standard-bindings" "block" "declare")
      {Lisp-Entry "g-separate" #f 8 9 8 19 ("1" "%%fx-" "f-separate" "0" "%%fx=" "if" "n" "s")}}})
"bind"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "dialect" "syntax" "bind.scm"} 1238328026
    {Lisp-Entry "jazz.dialect.syntax.bind" #f 38 19 38 43 ("scheme")
      {Lisp-Entry "bind" #f 56 9 56 13 ("expand-bind-car" "begin" "tree-value" "lambda" "with-uniqueness" "sourcify-if" "cdr" "body" "cddr" "car" "tree" "source-code" "cadr" "desourcify" "bindings" "let" "form-src")}
      {Lisp-Entry "expand-bind-car" #f 68 9 68 24 ("expand-bind-car" ",car-symbol" "generate-symbol" "car-symbol" "pair?" "expand-bind-cdr" ",tree" ",specifier" ",car-binding" "if" "binding-specifier" "specifier" "symbol?" "cond" "cdr" "cdr-binding" "car" "car-binding" "let" "body" "tree" "bindings")}
      {Lisp-Entry "expand-bind-cdr" #f 85 9 85 24 ("expand-bind-car" ",cdr-symbol" "generate-symbol" "cdr-symbol" "pair?" ",@body" ",tree" "cdr" ",cdr-binding" "let" "symbol?" "null?" "cond" "body" "tree" "cdr-binding")}}})
"bind-keywords"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "dialect" "syntax" "bind-keywords.scm"} 1238328026
    {Lisp-Entry "jazz.dialect.syntax.bind-keywords" #f 38 19 38 52 ("scheme")
      {Lisp-Entry "bind-keywords" #f 54 9 54 22 ("error" "not-null?" ",@body" "unbox-list" "symbol?" "proper-list" ",default" "symbol->string" "string->keyword" "find-keyword" ",specifier" ",variable" "caddr" "if" "default" "binding-specifier" "specifier" "variable" "binding" "lambda" "map" "let*" ",rest" "box-list" ",box" "sourcify-if" "last-tail" "oth" "new-queue" "bnd" "generate-symbol" "box" "cdr" "body" "cddr" "car" "rest" "cadr" "source-code" "bindings" "let" "form-src")}}})
"bind-optionals"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "dialect" "syntax" "bind-optionals.scm"} 1238328026
    {Lisp-Entry "jazz.dialect.syntax.bind-optionals" #f 38 19 38 53 ("scheme")
      {Lisp-Entry "bind-optionals" #f 61 9 61 23 (",@body" "error" "not-null?" "proper-list" ",value" ",specifier" ",variable" "set!" ",prog" ",default" "null?" "value" "caddr" "if" "default" "binding-specifier" "specifier" "variable" "binding" "lambda" "map" "let*" ",rest" ",scan" "sourcify-if" "prog" "generate-symbol" "scan" "cdr" "body" "cddr" "car" "rest" "cadr" "source-code" "bindings" "let" "form-src")}}})
"boot"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "dialect" "kernel" "boot.scm"} 1238328026
    {Lisp-Entry "jazz.dialect.kernel.boot" #f 38 19 38 43 ("scheme")
      {Lisp-Entry "format" #f 52 8 52 19 ()}
      {Lisp-Entry "last" #f 60 8 60 17 ()}
      {Lisp-Entry "butlast" #f 61 8 61 20 ()}
      {Lisp-Entry "last-tail" #f 62 8 62 22 ()}
      {Lisp-Entry "getprop" #f 63 8 63 20 ()}
      {Lisp-Entry "getf" #f 64 8 64 17 ()}
      {Lisp-Entry "->string" #f 72 8 72 21 ()}}})
"cffi"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "test" "cffi.jazz"} 1237033585
    {Lisp-Entry "jazz.test.cffi" #f 37 9 37 23 ("#<<end-of-c-declare\nstatic int func2(mult* m, int n)\n{\n    return (*m)(n);\n}\nend-of-c-declare\n" "#<<end-of-c-declare\ntypedef int (mult)(int);\n\nstatic int multiply(int n)\n{\n    return n * n;\n}\n\nstatic mult* func1()\n{\n    return &multiply;\n}\nend-of-c-declare\n" "#<<end-of-c-declare\nstruct S1_\n{\n    int x;\n    int y;\n};\n\ntypedef struct S1_ S1;\n\nstatic int struct1a(S1 s1)\n{\n    return s1.x + s1.y;\n}\n\n//static int struct1b(S1& s1)\n//{\n//    return s1.x + s1.y;\n//}\n\nstatic int struct1c(S1* s1)\n{\n    return s1->x + s1->y;\n}\n\nstatic void tst()\n{\n    S1 s;\n    \n    struct1a(s);\n    struct1c(&s);\n}\nend-of-c-declare\n" "#<<end-of-c-declare\nstatic int scalar3(___SCMOBJ obj)\n{\n    return (int) obj;\n}\nend-of-c-declare\n" "#<<end-of-c-declare\nstatic int scalar2(int n)\n{\n    return n + n;\n}\nend-of-c-declare\n" "#<<end-of-c-declare\nstatic void scalar1(int n)\n{\n}\nend-of-c-declare\n" "#<<end-of-c-declare\nN = 2;\nend-of-c-declare\n" "#<<end-of-c-declare\nstatic int N;\nend-of-c-declare\n" "jazz")
      {Lisp-Entry "init1" #f 71 12 71 17 ("int" "c-function")}
      {Lisp-Entry "void" #f 80 8 80 12 ("void" "native")}
      {Lisp-Entry "bool" #f 81 8 81 12 ("bool" "native")}
      {Lisp-Entry "char" #f 82 8 82 12 ("char" "native")}
      {Lisp-Entry "wchar_t" #f 83 8 83 15 ("wchar_t" "native")}
      {Lisp-Entry "int" #f 84 8 84 11 ("int" "native")}
      {Lisp-Entry "double" #f 85 8 85 14 ("double" "native")}
      {Lisp-Entry "scheme-object" #f 86 8 86 21 ("scheme-object" "native")}
      {Lisp-Entry "object" #f 87 8 87 14 ("scheme-object")}
      {Lisp-Entry "scalar1" #f 98 12 98 19 ("void" "int" "c-function")}
      {Lisp-Entry "scalar2" #f 111 12 111 19 ("int" "c-function")}
      {Lisp-Entry "scalar3" #f 124 12 124 19 ("int" "object" "c-function")}
      {Lisp-Entry "ca" #f 186 12 186 14 ("2")}
      {Lisp-Entry "cb" #f 187 12 187 14 ("3")}
      {Lisp-Entry "e" #f 195 15 195 16 ("4" "ec" "2" "eb" "1" "ea")}
      {Lisp-Entry "S1" #f 243 8 243 10 ("struct")}
      {Lisp-Entry "make-S1" #f 246 12 246 19 ("S1" "c-function")}
      {Lisp-Entry "struct1a" #f 251 12 251 20 ("int" "S1" "c-function")}
      {Lisp-Entry "struct1c" #f 257 12 257 20 ("int" "S1" "pointer" "c-function")}
      {Lisp-Entry "cast-S2->S2*" #f 268 12 268 24 ("error" "S2*" "object" "c-function" "S2" "'S2" "foreign-tags" "car" "eq?" "if" "s2" "function")}
      {Lisp-Entry "mult*" #f 305 8 305 13 ("int" "function" "pointer")}
      {Lisp-Entry "func1" #f 324 12 324 17 ("mult*" "c-function")}}})
"classes"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "dialect" "classes.scm"} 1238328026
    {Lisp-Entry "jazz.dialect.classes" #f 37 18 37 38 ()
      {Lisp-Entry "jazz.Definition-Declaration" #f 45 19 45 46 ("%%set-definition-declaration-value" "%%get-definition-declaration-value" "value" "%%get-definition-declaration-signature" "signature" "%%get-definition-declaration-expansion" "expansion" "jazz.allocate-definition-declaration" "jazz.Object-Class" "source" "locator" "parent" "toplevel" "attributes" "compatibility" "access" "type" "name" "jazz.Declaration")}
      {Lisp-Entry "jazz.Specialize" #f 56 19 56 34 ("jazz.allocate-specialize" "jazz.Object-Class" "source" "type" "jazz.Expression")}
      {Lisp-Entry "jazz.Generic-Declaration" #f 65 19 65 43 ("%%set-generic-declaration-body" "%%get-generic-declaration-body" "body" "%%set-generic-declaration-signature" "%%get-generic-declaration-signature" "signature" "%%get-generic-declaration-dispatch-types" "dispatch-types" "jazz.allocate-generic-declaration" "jazz.Object-Class" "source" "locator" "parent" "toplevel" "attributes" "compatibility" "access" "type" "name" "jazz.Declaration")}
      {Lisp-Entry "jazz.Specific-Declaration" #f 76 19 76 44 ("%%get-specific-declaration-root?" "root?" "%%set-specific-declaration-body" "%%get-specific-declaration-body" "body" "%%get-specific-declaration-signature" "signature" "%%get-specific-declaration-generic" "generic" "jazz.allocate-specific-declaration" "jazz.Object-Class" "source" "locator" "parent" "toplevel" "attributes" "compatibility" "access" "type" "name" "jazz.Declaration")}
      {Lisp-Entry "jazz.Category-Declaration" #f 88 19 88 44 ("%%get-category-declaration-metaclass" "metaclass" "%%get-category-declaration-implementor" "implementor" "jazz.Object-Class" "body" "children" "children-lookup" "lookups" "source" "locator" "parent" "toplevel" "attributes" "compatibility" "access" "type" "name" "jazz.Namespace-Declaration")}
      {Lisp-Entry "jazz.Class-Declaration" #f 98 19 98 41 ("%%get-class-declaration-interfaces" "interfaces" "%%get-class-declaration-ascendant-base" "ascendant-base" "%%get-class-declaration-ascendant-relation" "ascendant-relation" "%%get-class-declaration-ascendant" "ascendant" "jazz.allocate-class-declaration" "jazz.Object-Class" "metaclass" "implementor" "body" "children" "children-lookup" "lookups" "source" "locator" "parent" "toplevel" "attributes" "compatibility" "access" "type" "name" "jazz.Category-Declaration")}
      {Lisp-Entry "jazz.Interface-Declaration" #f 110 19 110 45 ("%%get-interface-declaration-ascendants" "ascendants" "jazz.allocate-interface-declaration" "jazz.Object-Class" "metaclass" "implementor" "body" "children" "children-lookup" "lookups" "source" "locator" "parent" "toplevel" "attributes" "compatibility" "access" "type" "name" "jazz.Category-Declaration")}
      {Lisp-Entry "jazz.Field-Declaration" #f 119 19 119 41 ("jazz.Object-Class" "source" "locator" "parent" "toplevel" "attributes" "compatibility" "access" "type" "name" "jazz.Declaration")}
      {Lisp-Entry "jazz.Slot-Declaration" #f 128 19 128 40 ("%%get-slot-declaration-setter-name" "setter-name" "%%get-slot-declaration-getter-name" "getter-name" "%%set-slot-declaration-initialize" "%%get-slot-declaration-initialize" "initialize" "jazz.allocate-slot-declaration" "jazz.Object-Class" "source" "locator" "parent" "toplevel" "attributes" "compatibility" "access" "type" "name" "jazz.Field-Declaration")}
      {Lisp-Entry "jazz.Property-Declaration" #f 139 19 139 44 ("%%set-property-declaration-setter" "%%get-property-declaration-setter" "setter" "%%set-property-declaration-getter" "%%get-property-declaration-getter" "getter" "jazz.allocate-property-declaration" "jazz.Object-Class" "setter-name" "getter-name" "initialize" "source" "locator" "parent" "toplevel" "attributes" "compatibility" "access" "type" "name" "jazz.Slot-Declaration")}
      {Lisp-Entry "jazz.Method-Declaration" #f 149 19 149 42 ("%%set-method-declaration-body" "%%get-method-declaration-body" "body" "%%set-method-declaration-signature" "%%get-method-declaration-signature" "signature" "%%get-method-declaration-synchronized" "synchronized" "%%get-method-declaration-remote" "remote" "%%get-method-declaration-expansion" "expansion" "%%get-method-declaration-abstraction" "abstraction" "%%get-method-declaration-propagation" "propagation" "%%get-method-declaration-root" "root" "jazz.allocate-method-declaration" "jazz.Object-Class" "source" "locator" "parent" "toplevel" "attributes" "compatibility" "access" "type" "name" "jazz.Field-Declaration")}
      {Lisp-Entry "jazz.With-Self" #f 165 19 165 33 ("%%get-with-self-body" "body" "jazz.allocate-with-self" "jazz.Object-Class" "source" "type" "jazz.Expression")}
      {Lisp-Entry "jazz.With-Dynamic-Self" #f 174 19 174 41 ("%%get-with-dynamic-self-body" "body" "%%get-with-dynamic-self-code" "code" "jazz.allocate-with-dynamic-self" "jazz.Object-Class" "source" "type" "jazz.Expression")}
      {Lisp-Entry "jazz.Cast" #f 184 19 184 28 ("%%get-cast-expression" "expression" "jazz.allocate-cast" "jazz.Object-Class" "source" "type" "jazz.Expression")}
      {Lisp-Entry "jazz.Construct" #f 193 19 193 33 ("%%get-construct-values" "values" "%%get-construct-class" "class" "jazz.allocate-construct" "jazz.Object-Class" "source" "type" "jazz.Expression")}
      {Lisp-Entry "jazz.Slot-Reference" #f 203 19 203 38 ("%%get-slot-reference-context" "context" "%%get-slot-reference-name" "name" "%%get-slot-reference-declaration" "declaration" "jazz.allocate-slot-reference" "jazz.Object-Class" "source" "type" "jazz.Expression")}
      {Lisp-Entry "jazz.Slot-Assignment" #f 214 19 214 39 ("%%get-slot-assignment-value" "value" "%%get-slot-assignment-context" "context" "%%get-slot-assignment-name" "name" "%%get-slot-assignment-declaration" "declaration" "jazz.allocate-slot-assignment" "jazz.Object-Class" "source" "type" "jazz.Expression")}
      {Lisp-Entry "jazz.Dispatch" #f 226 19 226 32 ("%%get-dispatch-arguments" "arguments" "%%get-dispatch-name" "name" "jazz.allocate-dispatch" "jazz.Object-Class" "source" "type" "jazz.Expression")}}})
"common"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "test" "performance" "common.scm"} 1237033585
    {Lisp-Entry "test.performance.common" #f 0 8 0 31 ("W" "Z" "X" "jazz.encapsulate-class" "separate" "run-time-bindings" "extended-bindings" "safe" "not" "standard-bindings" "block" "declare")
      {Lisp-Entry "ff" #f 11 9 11 11 ("1" "%%fx-" "ff" "%%pair?" "begin" "0" "%%fx>" "if" "n")}
      {Lisp-Entry "gg" #f 24 9 24 11 ("1" "%%fx-" "gg" "%%pair?" "begin" "0" "%%fx>" "if" "n")}
      {Lisp-Entry "f-module-block/standard/not-safe" #f 42 9 42 41 ("1" "%%fx-" "g-module-block/standard/not-safe" "0" "%%fx=" "if" "n" "s")}
      {Lisp-Entry "g-module-block/standard/not-safe" #f 48 9 48 41 ("1" "%%fx-" "f-module-block/standard/not-safe" "0" "%%fx=" "if" "n" "s")}
      {Lisp-Entry "f-module-block/runtime/safe" #f 66 9 66 36 ("1" "%%fx-" "g-module-block/runtime/safe" "0" "%%fx=" "if" "n" "s")}
      {Lisp-Entry "g-module-block/runtime/safe" #f 72 9 72 36 ("1" "%%fx-" "f-module-block/runtime/safe" "0" "%%fx=" "if" "n" "s")}
      {Lisp-Entry "f-module-separate/runtime/safe" #f 90 9 90 39 ("1" "%%fx-" "g-module-separate/runtime/safe" "0" "%%fx=" "if" "n" "s")}
      {Lisp-Entry "g-module-separate/runtime/safe" #f 96 9 96 39 ("1" "%%fx-" "f-module-separate/runtime/safe" "0" "%%fx=" "if" "n" "s")}
      {Lisp-Entry "f-module-block/runtime/notsafe" #f 114 9 114 39 ("1" "%%fx-" "g-module-block/runtime/notsafe" "0" "%%fx=" "if" "n" "s")}
      {Lisp-Entry "g-module-block/runtime/notsafe" #f 120 9 120 39 ("1" "%%fx-" "f-module-block/runtime/notsafe" "0" "%%fx=" "if" "n" "s")}
      {Lisp-Entry "f-module" #f 137 9 137 17 ("1" "%%fx-" "g-module" "0" "%%fx=" "if" "n" "s")}
      {Lisp-Entry "g-module" #f 143 9 143 17 ("1" "%%fx-" "f-module" "0" "%%fx=" "if" "n" "s")}
      {Lisp-Entry "X" #f 160 19 160 20 ("allocate-x" "jazz.Object-Class" "jazz.Object")}
      {Lisp-Entry "X" #f 163 27 163 28 ()}
      {Lisp-Entry "new-x" #f 168 9 168 14 ("X" "allocate-x")}
      {Lisp-Entry "f-generic" ("X") 172 22 172 31 ("n")}
      {Lisp-Entry "f-generic" ("X") 174 23 174 32 ("1" "%%fx-" "x" "g-generic" "0" "%%fx=" "if" "n")}
      {Lisp-Entry "g-generic" ("X") 180 22 180 31 ("n")}
      {Lisp-Entry "g-generic" ("X") 182 23 182 32 ("1" "%%fx-" "x" "f-generic" "0" "%%fx=" "if" "n")}
      {Lisp-Entry "Z" #f 193 27 193 28 ()}
      {Lisp-Entry "f-vtable" ("Z") 196 30 196 38 ("n")}
      {Lisp-Entry "g-vtable" ("Z") 197 30 197 38 ("n")}
      {Lisp-Entry "new-z" #f 200 9 200 14 ("Z" "allocate-z")}
      {Lisp-Entry "f-vtable" ("Z") 204 21 204 29 ("1" "%%fx-" "z" "g-vtable" "0" "%%fx=" "if" "n")}
      {Lisp-Entry "g-vtable" ("Z") 210 21 210 29 ("1" "%%fx-" "z" "f-vtable" "0" "%%fx=" "if" "n")}
      {Lisp-Entry "W" #f 219 27 219 28 ()}
      {Lisp-Entry "f-vtable" ("W") 222 21 222 29 ("n")}
      {Lisp-Entry "h" ("W") 226 30 226 31 ()}
      {Lisp-Entry "h" ("W") 229 21 229 22 ()}}})
"constructors"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "literals" "constructors.jazz"} 1238328026
    {Lisp-Entry "jazz.literals.constructors" #f 37 9 37 35 ("jazz")
      {Lisp-Entry "construct-point" #f 63 13 63 28 ("Point" "new" "v" "h")}
      {Lisp-Entry "construct-dimension" #f 72 13 72 32 ("Dimension" "new" "height" "width")}
      {Lisp-Entry "construct-cell" #f 81 13 81 27 ("Cell" "new" "col" "row")}
      {Lisp-Entry "construct-rect" #f 90 13 90 27 ("Rect" "new" "bottom" "right" "top" "left")}
      {Lisp-Entry "construct-range" #f 99 13 99 28 ("Range" "new" "end" "start")}
      {Lisp-Entry "construct-action" #f 108 13 108 29 ("Action" "new" "properties" "action-name" "action-context")}
      {Lisp-Entry "construct-exception-detail" #f 117 13 117 39 ("Exception-Detail" "new" "children" "location" "title" "icon")}
      {Lisp-Entry "construct-walk-location" #f 126 13 126 36 ("Walk-Location" "new" "locat" "declaration-locator" "module-locator")}
      {Lisp-Entry "construct-box" #f 135 13 135 26 ("car" "Box" "new" "null?" "if" "rest")}
      {Lisp-Entry "construct-shortcut" #f 146 13 146 31 ("last" "butlast" "Shortcut" "new" "rest")}
      {Lisp-Entry "construct-locales" #f 155 13 155 30 ("Locales" "new" "apply" "rest")}
      {Lisp-Entry "construct-color" #f 164 13 164 28 ("Color" "new" "apply" "alpha:" "getf" "registered-color" "if" "others" "name" "bind-keywords" "rest")}
      {Lisp-Entry "construct-font" #f 176 13 176 27 ("Font" "new" "apply" "registered-font" "if" "others" "name" "bind-keywords" "rest")}
      {Lisp-Entry "construct-file" #f 188 13 188 27 ("File" "new" "rest")}
      {Lisp-Entry "construct-directory" #f 197 13 197 32 ("Directory" "new" "rest")}
      {Lisp-Entry "construct-directory-group" #f 206 13 206 38 ("Directory-Group" "new" "rest")}
      {Lisp-Entry "construct-host" #f 215 13 215 27 ("Host" "new" "apply" "rest")}
      {Lisp-Entry "construct-ior" #f 224 13 224 26 ("IOR" "new" "values" "reference" "remotable" "port" "host")}
      {Lisp-Entry "construct-guid" #f 235 13 235 27 ("GUID" "new" "rest")}
      {Lisp-Entry "construct-format" #f 244 13 244 29 ("Format" "new" "apply" "rest")}
      {Lisp-Entry "construct-text-style" #f 253 13 253 33 ("Text-Style" "new" "apply" "rest")}
      {Lisp-Entry "construct-hyperlink-style" #f 262 13 262 38 ("Hyperlink-Style" "new" "apply" "rest")}
      {Lisp-Entry "construct-text" #f 271 13 271 27 ("Text" "new" "apply" "rest")}
      {Lisp-Entry "construct-formatted-text" #f 280 13 280 37 ("Formatted-Text" "new" "apply" "rest")}
      {Lisp-Entry "construct-bitmap-resource" #f 289 13 289 38 ("Bitmap-Resource" "new" "name")}
      {Lisp-Entry "construct-icon-resource" #f 298 13 298 36 ("Icon-Resource" "new" "name")}
      {Lisp-Entry "construct-cursor-resource" #f 307 13 307 38 ("Cursor-Resource" "new" "name")}
      {Lisp-Entry "construct-event" #f 316 13 316 28 ("Event" "new" "properties" "kind")}
      {Lisp-Entry "construct-event-handler" #f 325 13 325 36 ("properties:" "method-name:" "target-name:" "Event-Handler" "new" "properties" "method-name" "target-name")}
      {Lisp-Entry "construct-selection-handler" #f 334 13 334 40 ("properties:" "force?:" "method-name:" "target-name:" "Selection-Handler" "new" "properties" "force?" "method-name" "target-name")}
      {Lisp-Entry "construct-version" #f 343 13 343 30 ("Version" "new" "stage" "0" "revision" "minor" "major")}
      {Lisp-Entry "construct-c-file-entry" #f 352 13 352 35 ("seconds->time" "C-File-Entry" "new" "definitions" "time" "file")}
      {Lisp-Entry "construct-c-category-entry" #f 356 13 356 39 ("C-Category-Entry" "new" "name")}
      {Lisp-Entry "construct-c-define-entry" #f 360 13 360 37 ("C-Define-Entry" "new" "column" "line" "name")}
      {Lisp-Entry "construct-c-include-entry" #f 364 13 364 38 ("C-Include-Entry" "new" "column" "line" "name")}
      {Lisp-Entry "construct-c-export-entry" #f 368 13 368 37 ("C-Export-Entry" "new" "column" "line" "name")}
      {Lisp-Entry "construct-css-file-entry" #f 377 13 377 37 ("seconds->time" "CSS-File-Entry" "new" "definitions" "time" "file")}
      {Lisp-Entry "construct-css-entry" #f 381 13 381 32 ("CSS-Entry" "new" "column" "line" "name")}
      {Lisp-Entry "construct-java-file-entry" #f 390 13 390 38 ("seconds->time" "Java-File-Entry" "new" "definitions" "time" "file")}
      {Lisp-Entry "construct-javascript-file-entry" #f 399 13 399 44 ("seconds->time" "JavaScript-File-Entry" "new" "definitions" "time" "file")}
      {Lisp-Entry "construct-javascript-variable-entry" #f 403 13 403 48 ("JavaScript-Variable-Entry" "new" "column" "line" "name")}
      {Lisp-Entry "construct-javascript-function-entry" #f 407 13 407 48 ("JavaScript-Function-Entry" "new" "column" "line" "name")}
      {Lisp-Entry "construct-lua-file-entry" #f 416 13 416 37 ("seconds->time" "Lua-File-Entry" "new" "definitions" "time" "file")}
      {Lisp-Entry "construct-lua-function-entry" #f 420 13 420 41 ("Lua-Function-Entry" "new" "column" "line" "name")}
      {Lisp-Entry "construct-properties-file-entry" #f 429 13 429 44 ("seconds->time" "Properties-File-Entry" "new" "definitions" "time" "file")}
      {Lisp-Entry "construct-properties-entry" #f 433 13 433 39 ("Properties-Entry" "new" "column" "line" "name")}
      {Lisp-Entry "construct-python-file-entry" #f 442 13 442 40 ("seconds->time" "Python-File-Entry" "new" "definitions" "time" "file")}
      {Lisp-Entry "construct-python-class-entry" #f 446 13 446 41 ("Python-Class-Entry" "new" "column" "line" "name")}
      {Lisp-Entry "construct-python-def-entry" #f 450 13 450 39 ("Python-Def-Entry" "new" "column" "line" "name")}
      {Lisp-Entry "construct-lisp-file-entry" #f 459 13 459 38 ("seconds->time" "Lisp-File-Entry" "new" "definitions" "time" "file")}
      {Lisp-Entry "construct-lisp-entry" #f 463 13 463 33 ("Lisp-Entry" "new" "definitions" "references" "end-column" "end-line" "column" "line" "signature" "name")}}})
"continuation"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "dialect" "core" "continuation.scm"} 1238328026
    {Lisp-Entry "jazz.dialect.core.continuation" #f 37 18 37 48 ()
      {Lisp-Entry "jazz.continuation?" #f 42 13 42 31 ("%%continuation?" "obj")}
      {Lisp-Entry "jazz.continuation-capture" #f 46 13 46 38 ("%%continuation-capture" "proc")}
      {Lisp-Entry "jazz.continuation-graft" #f 50 13 50 36 ("%%continuation-graft" "proc" "cont")}
      {Lisp-Entry "jazz.continuation-return" #f 54 12 54 36 ("continuation-return")}}})
"debug"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "dialect" "core" "debug.scm"} 1238328026
    {Lisp-Entry "jazz.dialect.core.debug" #f 37 18 37 41 ()
      {Lisp-Entry "inspect" #f 41 9 41 16 ("jazz.serial->object" "integer?" "if" "jazz.inspect-object" "obj")}
      {Lisp-Entry "resume" #f 46 9 46 15 ("jazz.system.process.Process.Process.resume-loop" "'jazz.system.process.Process.Process.resume-loop" "resume-loop" "jazz.dialect.language.get-process" "'jazz.dialect.language.get-process" "jazz.global-value" "get-process" "let")}}})
"declares"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "test" "performance" "declares.scm"} 1237033585
    {Lisp-Entry "f-run-time-bindings/safe" #f 3 9 3 33 ("car" "x")}
    {Lisp-Entry "f-not-run-time-bindings/safe" #f 10 9 10 37 ("car" "x")}
    {Lisp-Entry "f-run-time-bindings/not-safe" #f 17 9 17 37 ("car" "x")}
    {Lisp-Entry "f-not-run-time-bindings/not-safe" #f 24 9 24 41 ("car" "x")}
    {Lisp-Entry "f-standard-bindings/not-run-time-bindings/not-safe" #f 32 9 32 59 ("##pair?" "car" "x")}
    {Lisp-Entry "f-standard-bindings/run-time-bindings/not-safe" #f 41 9 41 55 ("##pair?" "car" "x")}
    {Lisp-Entry "f-standard-bindings/extended-bindings/not-safe" #f 50 9 50 55 ("##pair?" "car" "x")}
    {Lisp-Entry "f-block" #f 57 9 57 16 ("g-block")}
    {Lisp-Entry "g-block" #f 60 9 60 16 ("f-block")}
    {Lisp-Entry "f-separate" #f 66 9 66 19 ("g-separate")}
    {Lisp-Entry "g-separate" #f 69 9 69 19 ("f-separate")}})
"development"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "dialect" "core" "development.scm"} 1238328026
    {Lisp-Entry "jazz.dialect.core.development" #f 37 18 37 47 ()
      {Lisp-Entry "jazz.define-global" #f 45 20 45 38 ("set!" ",value" ",setter" ",getter" ",name" "define" "begin" "jazz.generate-symbol" "value" "setter" "symbol->string" "string-append" "string->symbol" "getter" "let" "name")}
      {Lisp-Entry "?" #f 63 20 63 21 ()}
      {Lisp-Entry "%" #f 64 20 64 21 ()}
      {Lisp-Entry "?a" #f 67 20 67 22 ()}
      {Lisp-Entry "?b" #f 68 20 68 22 ()}
      {Lisp-Entry "?c" #f 69 20 69 22 ()}
      {Lisp-Entry "?d" #f 70 20 70 22 ()}
      {Lisp-Entry "?e" #f 71 20 71 22 ()}
      {Lisp-Entry "?f" #f 72 20 72 22 ()}
      {Lisp-Entry "?g" #f 73 20 73 22 ()}
      {Lisp-Entry "?h" #f 74 20 74 22 ()}
      {Lisp-Entry "?i" #f 75 20 75 22 ()}
      {Lisp-Entry "?j" #f 76 20 76 22 ()}
      {Lisp-Entry "?k" #f 77 20 77 22 ()}
      {Lisp-Entry "?l" #f 78 20 78 22 ()}
      {Lisp-Entry "?m" #f 79 20 79 22 ()}
      {Lisp-Entry "?n" #f 80 20 80 22 ()}
      {Lisp-Entry "?o" #f 81 20 81 22 ()}
      {Lisp-Entry "?p" #f 82 20 82 22 ()}
      {Lisp-Entry "?q" #f 83 20 83 22 ()}
      {Lisp-Entry "?r" #f 84 20 84 22 ()}
      {Lisp-Entry "?s" #f 85 20 85 22 ()}
      {Lisp-Entry "?t" #f 86 20 86 22 ()}
      {Lisp-Entry "?u" #f 87 20 87 22 ()}
      {Lisp-Entry "?v" #f 88 20 88 22 ()}
      {Lisp-Entry "?w" #f 89 20 89 22 ()}
      {Lisp-Entry "?x" #f 90 20 90 22 ()}
      {Lisp-Entry "?y" #f 91 20 91 22 ()}
      {Lisp-Entry "?z" #f 92 20 92 22 ()}
      {Lisp-Entry "%a" #f 95 20 95 22 ()}
      {Lisp-Entry "%b" #f 96 20 96 22 ()}
      {Lisp-Entry "%c" #f 97 20 97 22 ()}
      {Lisp-Entry "%d" #f 98 20 98 22 ()}
      {Lisp-Entry "%e" #f 99 20 99 22 ()}
      {Lisp-Entry "%f" #f 100 20 100 22 ()}
      {Lisp-Entry "%g" #f 101 20 101 22 ()}
      {Lisp-Entry "%h" #f 102 20 102 22 ()}
      {Lisp-Entry "%i" #f 103 20 103 22 ()}
      {Lisp-Entry "%j" #f 104 20 104 22 ()}
      {Lisp-Entry "%k" #f 105 20 105 22 ()}
      {Lisp-Entry "%l" #f 106 20 106 22 ()}
      {Lisp-Entry "%m" #f 107 20 107 22 ()}
      {Lisp-Entry "%n" #f 108 20 108 22 ()}
      {Lisp-Entry "%o" #f 109 20 109 22 ()}
      {Lisp-Entry "%p" #f 110 20 110 22 ()}
      {Lisp-Entry "%q" #f 111 20 111 22 ()}
      {Lisp-Entry "%r" #f 112 20 112 22 ()}
      {Lisp-Entry "%s" #f 113 20 113 22 ()}
      {Lisp-Entry "%t" #f 114 20 114 22 ()}
      {Lisp-Entry "%u" #f 115 20 115 22 ()}
      {Lisp-Entry "%v" #f 116 20 116 22 ()}
      {Lisp-Entry "%w" #f 117 20 117 22 ()}
      {Lisp-Entry "%x" #f 118 20 118 22 ()}
      {Lisp-Entry "%y" #f 119 20 119 22 ()}
      {Lisp-Entry "%z" #f 120 20 120 22 ()}}})
"dialect"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "dialect" "dialect.scm"} 1245777538
    {Lisp-Entry "jazz.dialect.dialect" #f 37 18 37 38 ("jazz.dialect" "'jazz.dialect" "jazz" "'jazz" "jazz.register-dialect" "jazz.new-jazz-dialect" "dialect" "jazz.Jazz-Walker" "jazz.Dispatch" "jazz.Construct" "jazz.Cast" "jazz.With-Dynamic-Self" "jazz.With-Self" "jazz.new" "jazz.new2" "2" "jazz.new1" "1" "jazz.codes-forms" "jazz.new0" "0" "%%length" "jazz.new-code" "values-codes" "jazz.Autoload-Declaration" "or" "%%get-reference-binding" "binding" "jazz.Reference" "class-expression" "let" "jazz.dialect.kernel.new" "'jazz.dialect.kernel.new" "%%eq?" "if" "declaration" "arguments-codes" "operator" "jazz.emit-primitive-new-call" "else" "%%car" "jazz.emit-specialized-class-of" "%%cdr" "%%null?" "%%pair?" "%%assert" "jazz.dialect.kernel.class-of" "case" "environment" "arguments" "locator" "jazz.emit-specialized-locator" "jazz.Jazz-Dialect" "jazz.Method-Declaration" "jazz.Property-Declaration" "jazz.Slot-Declaration" "jazz.Field-Declaration" "jazz.Interface-Declaration" "%%get-class-declaration-ascendant" "%%not" "%%class-is?" "and" "type" "lambda" "jazz.object-declaration?" "set!" "jazz.Class-Declaration" "jazz.Category-Declaration" "jazz.Specific-Declaration" "jazz.Generic-Declaration" "jazz.Specialize" "jazz.Definition-Declaration" "jazz.encapsulate-class")
      {Lisp-Entry "jazz.Definition-Declaration" #f 45 27 45 54 ()}
      {Lisp-Entry "jazz.new-definition-declaration" #f 48 9 48 40 ("jazz.setup-declaration" "jazz.Definition-Declaration" "jazz.allocate-definition-declaration" "new-declaration" "let" "signature" "expansion" "parent" "attributes" "compatibility" "access" "type" "name")}
      {Lisp-Entry "jazz.walk-binding-validate-call" ("jazz.Definition-Declaration") 54 21 54 52 ("jazz.validate-arguments" "if" "declaration" "%%get-definition-declaration-signature" "signature" "let" "arguments" "operator" "source-declaration" "resume" "walker")}
      {Lisp-Entry "jazz.emit-inlined-binding-call" ("jazz.Definition-Declaration") 60 21 60 51 ("jazz.error" "jazz.call-return-type" "jazz.sourcified-form" "%%get-signature-positional" "%%get-lexical-binding-type" "jazz.emit-type-cast" "%%get-lexical-binding-name" "argument" "parameter" "map" "jazz.new-code" "jazz.emit-expression" "body-code" "cons" "augmented-environment" "frame" "lambda" "jazz.annotate-inlined-signature" "jazz.with-annotated-frame" "%%length" "%%get-signature-mandatory" "%%fx=" "jazz.only-positional?" "%%get-lambda-body" "body" "%%get-lambda-signature" "signature" "jazz.untyped-inline-definition?" "jazz.inline-definitions?" "or" "inline" "'inline" "%%get-definition-declaration-expansion" "%%eq?" "and" "jazz.Lambda" "%%class-is?" "if" "declaration" "%%get-definition-declaration-value" "value" "let" "environment" "source-declaration" "arguments")}
      {Lisp-Entry "jazz.untyped-inline-definition?" #f 92 9 92 40 ("%%get-lambda-signature" "%%get-signature-positional" "%%get-lexical-binding-type" "%%not" "parameter" "lambda" "jazz.every?" "value")}
      {Lisp-Entry "jazz.emit-declaration" ("jazz.Definition-Declaration") 98 21 98 42 ("%%get-declaration-source" "%%get-lexical-binding-type" "jazz.emit-expression" "jazz.emit-type-cast" ",locator" "define" "jazz.sourcify-if" "%%get-definition-declaration-value" "value" "declaration" "%%get-declaration-locator" "locator" "let" "environment")}
      {Lisp-Entry "jazz.emit-binding-reference" ("jazz.Definition-Declaration") 107 21 107 48 ("jazz.Any" "%%get-lexical-binding-type" "or" "declaration" "%%get-declaration-locator" "jazz.new-code" "environment" "source-declaration")}
      {Lisp-Entry "jazz.walk-binding-validate-assignment" ("jazz.Definition-Declaration") 115 21 115 58 ("%%get-lexical-binding-name" "jazz.walk-error" "%%get-declaration-toplevel" "%%neq?" "%%when" "declaration" "nextmethod" "source-declaration" "resume" "walker")}
      {Lisp-Entry "jazz.walk-binding-assignable?" ("jazz.Definition-Declaration") 121 21 121 50 ()}
      {Lisp-Entry "jazz.emit-binding-assignment" ("jazz.Definition-Declaration") 125 21 125 49 ("jazz.Any" "%%get-lexical-binding-type" "jazz.emit-expression" "jazz.emit-type-cast" ",locator" "set!" "jazz.new-code" "declaration" "%%get-declaration-locator" "locator" "let" "environment" "source-declaration" "value")}
      {Lisp-Entry "jazz.fold-declaration" ("jazz.Definition-Declaration") 133 21 133 42 ("%%get-definition-declaration-value" "jazz.fold-statement" "declaration" "s" "k" "f")}
      {Lisp-Entry "jazz.Specialize" #f 147 27 147 42 ()}
      {Lisp-Entry "jazz.new-specialize" #f 150 9 150 28 ("jazz.Specialize" "jazz.allocate-specialize")}
      {Lisp-Entry "jazz.emit-expression" ("jazz.Specialize") 154 21 154 41 ("jazz.Any" "begin" "jazz.new-code" "environment" "declaration")}
      {Lisp-Entry "jazz.Generic-Declaration" #f 169 27 169 51 ()}
      {Lisp-Entry "jazz.new-generic-declaration" #f 172 9 172 37 ("jazz.setup-declaration" "jazz.Generic-Declaration" "jazz.allocate-generic-declaration" "new-declaration" "let" "signature" "dispatch-types" "parent" "attributes" "compatibility" "access" "type" "name")}
      {Lisp-Entry "jazz.walk-binding-validate-call" ("jazz.Generic-Declaration") 178 21 178 52 ("%%get-generic-declaration-signature" "declaration" "jazz.validate-arguments" "arguments" "operator" "source-declaration" "resume" "walker")}
      {Lisp-Entry "jazz.emit-declaration" ("jazz.Generic-Declaration") 182 21 182 42 ("%%get-declaration-source" "jazz.emit-expression" "jazz.sourcified-form" "jazz.emit-signature" "%%cons" "jazz.define-generic" "jazz.sourcify-if" "cons" "augmented-environment" "frame" "lambda" "jazz.annotate-signature" "jazz.with-annotated-frame" "%%get-generic-declaration-body" "body" "%%get-generic-declaration-signature" "signature" "declaration" "%%get-declaration-locator" "generic-locator" "let" "environment")}
      {Lisp-Entry "jazz.emit-binding-reference" ("jazz.Generic-Declaration") 195 21 195 48 ("jazz.Any" "declaration" "%%get-declaration-locator" "jazz.new-code" "environment" "source-declaration")}
      {Lisp-Entry "jazz.Specific-Declaration" #f 210 27 210 52 ()}
      {Lisp-Entry "jazz.new-specific-declaration" #f 213 9 213 38 ("jazz.setup-declaration" "jazz.Specific-Declaration" "jazz.allocate-specific-declaration" "new-declaration" "let" "root?" "signature" "generic" "parent" "attributes" "compatibility" "access" "type" "name")}
      {Lisp-Entry "jazz.emit-declaration" ("jazz.Specific-Declaration") 219 21 219 42 ("%%get-declaration-source" "jazz.emit-expression" "jazz.sourcified-form" ",modifier" "jazz.emit-signature" "%%cons" "jazz.define-specific" "jazz.sourcify-if" "child" "'child" "root" "'root" "%%get-specific-declaration-root?" "if" "modifier" "cons" "augmented-environment" "let" "frame" "lambda" "jazz.annotate-signature" "jazz.with-annotated-frame" "%%get-specific-declaration-body" "body" "%%get-specific-declaration-signature" "signature" "jazz.generic-object-locator" "generic-object-locator" "%%get-declaration-locator" "generic-locator" "declaration" "%%get-specific-declaration-generic" "generic-declaration" "let*" "environment")}
      {Lisp-Entry "jazz.Category-Declaration" #f 243 27 243 52 ()}
      {Lisp-Entry "jazz.emit-binding-reference" ("jazz.Category-Declaration") 246 21 246 48 ("jazz.Category-Declaration" "declaration" "%%get-declaration-locator" "jazz.new-code" "environment" "source-declaration")}
      {Lisp-Entry "jazz.lookup-declaration" ("jazz.Category-Declaration") 253 21 253 44 ("category-declaration" "%%get-access-lookup" "%%table-ref" "jazz.private-access" "jazz.public-access" "if" "access" "let" "external?" "symbol")}
      {Lisp-Entry "jazz.Class-Declaration" #f 268 27 268 49 ()}
      {Lisp-Entry "jazz.new-class-declaration" #f 271 9 271 35 ("jazz.setup-declaration" "eq?" "test:" "%%make-table" "jazz.protected-access" "jazz.make-access-lookups" "jazz.Class-Declaration" "jazz.allocate-class-declaration" "new-declaration" "let" "interfaces" "ascendant-base" "ascendant-relation" "ascendant" "metaclass" "implementor" "parent" "attributes" "compatibility" "access" "type" "name")}
      {Lisp-Entry "jazz.setup-class-lookups" #f 277 9 277 33 ("jazz.protected-access" "%%get-namespace-declaration-lookups" "%%vector-set!" "interface" "lambda" "for-each" "jazz.public-access" "%%table-merge!" "if" "jazz.private-access" "%%get-access-lookup" "private" "%%get-class-declaration-interfaces" "map" "interfaces" "%%get-class-declaration-ascendant" "resolve-declaration" "ascendant" "let" "class-declaration")
        {Lisp-Entry "resolve-declaration" #f 278 11 278 30 ("jazz.resolve-declaration" "if" "decl")}}
      {Lisp-Entry "jazz.emit-binding-reference" ("jazz.Class-Declaration") 315 21 315 48 ("jazz.Class-Declaration" "%%get-category-declaration-metaclass" "or" "declaration" "%%get-declaration-locator" "jazz.new-code" "environment" "source-declaration")}
      {Lisp-Entry "jazz.of-subtype?" ("jazz.Class-Declaration") 323 21 323 37 ("%%get-class-declaration-ascendant" "%%eq?" "jazz.resolve-declaration" "target-declaration" "%%not" "target" "iter" "let" "jazz.Class-Declaration" "%%class-is?" "and" "declaration" "jazz.object-declaration?" "if" "subtype")}
      {Lisp-Entry "jazz.emit-declaration" ("jazz.Class-Declaration") 336 21 336 42 ("%%get-declaration-source" "jazz.emit-namespace-statements" ",@interface-accesses" ",metaclass-access" "jazz.new-class" "jazz.global-value" "',locator" "jazz.global-variable?" "lambda" "map" "interface-accesses" ",ascendant-access" "%%get-object-class" "jazz.Object-Class" "'jazz.Object-Class" "metaclass-access" "jazz.emit-ascendant-access" "%%get-category-declaration-metaclass" "metaclass-declaration" "jazz.remove-slots" "%%list" "%%get-class-level" ",level-locator" "%%get-category-name" ",locator" "define" "jazz.emit-binding-reference" "jazz.sourcified-form" "%%not" "ascendant-access" "jazz.validate-core-class/class" "jazz.get-core-class" "core-class" "jazz.core-class?" "if" "begin" "jazz.sourcify-if" "level" "'level" "jazz.compose-helper" "level-locator" "%%get-namespace-declaration-body" "body" "%%get-class-declaration-interfaces" "interface-declarations" "%%get-class-declaration-ascendant" "ascendant-declaration" "%%get-declaration-locator" "locator" "declaration" "%%get-lexical-binding-name" "name" "let" "environment")}
      {Lisp-Entry "jazz.emit-ascendant-access" #f 368 9 368 35 ("%%get-object-class" "else" "jazz.emit-binding-reference" "jazz.sourcified-form" "%%not" "cond" "%%get-class-declaration-ascendant-base" "ascendant-base" "%%get-class-declaration-ascendant-relation" "ascendant-relation" "%%get-class-declaration-ascendant" "ascendant" "let" "environment" "declaration")}
      {Lisp-Entry "jazz.find-class-declaration" #f 383 9 383 36 ("%%get-declaration-parent" "else" "jazz.Class-Declaration" "%%class-is?" "jazz.error" "%%not" "cond" "decl" "iter" "let" "declaration")}
      {Lisp-Entry "jazz.validate-core-class/class" #f 404 9 404 39 ("jazz.validate-core-class/slots" "jazz.validate-core-class/category" "declaration" "core-class")}
      {Lisp-Entry "jazz.validate-core-class/slots" #f 409 9 409 39 ("jazz.error" "%%equal?" "%%not" "%%when" "%%get-namespace-declaration-children" "jazz.Slot-Declaration" "jazz.collect-type" "%%get-lexical-binding-name" "decl" "declaration-slot-names" "%%get-class-slots" "%%get-field-name" "%%symbol?" "if" "name/slot" "lambda" "map" "core-class-slot-names" "let" "declaration" "core-class")}
      {Lisp-Entry "jazz.validate-core-class/category" #f 416 9 416 42 ("jazz.validate-core-class/interfaces" "jazz.validate-core-class/ascendant" "declaration" "core-class")}
      {Lisp-Entry "jazz.validate-core-class/ascendant" #f 421 9 421 43 ("%%get-lexical-binding-name" "jazz.error" "%%eq?" "%%when" "%%get-declaration-locator" "declaration-ascendant-name" "%%get-class-declaration-ascendant" "declaration-ascendant" "%%get-category-name" "jazz.identifier-name" "%%not" "if" "core-class-ascendant-name" "%%get-class-ascendant" "core-class-ascendant" "let*" "declaration" "core-class")}
      {Lisp-Entry "jazz.validate-core-class/interfaces" #f 430 9 430 44 ("%%get-lexical-binding-name" "jazz.error" "%%null?" "%%not" "%%when" "%%get-class-declaration-interfaces" "declaration-interfaces" "let" "declaration" "core-class")}
      {Lisp-Entry "jazz.Interface-Declaration" #f 441 27 441 53 ()}
      {Lisp-Entry "jazz.new-interface-declaration" #f 444 9 444 39 ("jazz.setup-declaration" "eq?" "test:" "%%make-table" "jazz.protected-access" "jazz.make-access-lookups" "jazz.Interface-Declaration" "jazz.allocate-interface-declaration" "new-declaration" "let" "ascendants" "metaclass" "implementor" "parent" "attributes" "compatibility" "access" "type" "name")}
      {Lisp-Entry "jazz.setup-interface-lookups" #f 450 9 450 37 ("jazz.protected-access" "%%get-namespace-declaration-lookups" "%%vector-set!" "jazz.public-access" "%%table-merge!" "interface" "lambda" "for-each" "jazz.private-access" "%%get-access-lookup" "private" "%%get-interface-declaration-ascendants" "resolve-declaration" "map" "ascendants" "let" "interface-declaration")
        {Lisp-Entry "resolve-declaration" #f 451 11 451 30 ("jazz.resolve-declaration" "if" "decl")}}
      {Lisp-Entry "jazz.of-subtype?" ("jazz.Interface-Declaration") 481 21 481 37 ("subtype")}
      {Lisp-Entry "jazz.emit-declaration" ("jazz.Interface-Declaration") 486 21 486 42 ("%%get-declaration-source" "jazz.emit-namespace-statements" "%%get-interface-rank" ",rank-locator" ",@ascendant-accesses" "%%list" "',locator" ",metaclass-access" "jazz.new-interface" ",locator" "define" "begin" "jazz.sourcify-if" "%%get-namespace-declaration-body" "body" "lambda" "map" "ascendant-accesses" "jazz.emit-binding-reference" "jazz.sourcified-form" "jazz.Interface" "'jazz.Interface" "%%not" "if" "metaclass-access" "%%get-category-declaration-metaclass" "metaclass-declaration" "%%get-interface-declaration-ascendants" "ascendant-declarations" "rank" "'rank" "jazz.compose-helper" "rank-locator" "%%get-declaration-locator" "locator" "declaration" "%%get-lexical-binding-name" "name" "let*" "environment")}
      {Lisp-Entry "jazz.Field-Declaration" #f 513 27 513 49 ()}
      {Lisp-Entry "jazz.Slot-Declaration" #f 524 27 524 48 ()}
      {Lisp-Entry "jazz.new-slot-declaration" #f 527 9 527 34 ("jazz.setup-declaration" "jazz.Slot-Declaration" "jazz.allocate-slot-declaration" "new-declaration" "let" "setter-name" "getter-name" "initialize" "parent" "attributes" "compatibility" "access" "type" "name")}
      {Lisp-Entry "jazz.walk-binding-validate-call" ("jazz.Slot-Declaration") 533 21 533 52 ("arguments" "operator" "source-declaration" "resume" "walker")}
      {Lisp-Entry "jazz.emit-declaration" ("jazz.Slot-Declaration") 537 21 537 42 ("%%get-declaration-source" "jazz.declaration-result" "%%get-slot-offset" ",offset-locator" ",allocate?" ",name" "',name" ",class-locator" "jazz.add-slot" ",slot-locator" "jazz.emit-expression" "jazz.sourcified-form" "self" ",initialize-locator" "define" "if" "begin" "jazz.sourcify-if" "offset" "'offset" "offset-locator" "slot" "'slot" "slot-locator" "'initialize" "jazz.compose-helper" "and" "initialize-locator" "%%get-slot-declaration-initialize" "initialize" "jazz.Void" "%%get-lexical-binding-type" "%%neq?" "allocate?" "class-locator" "%%get-declaration-parent" "class-declaration" "%%get-declaration-locator" "locator" "declaration" "%%get-lexical-binding-name" "name" "let*" "environment")}
      {Lisp-Entry "jazz.emit-binding-reference" ("jazz.Slot-Declaration") 561 21 561 48 ("jazz.error" "jazz.find-annotated-type" ",offset-locator" "jazz.sourcified-form" "%%object-ref" "jazz.new-code" "offset" "'offset" "declaration" "%%get-declaration-locator" "jazz.compose-helper" "offset-locator" "if" "jazz.*self*" "self" "let" "environment" "source-declaration")}
      {Lisp-Entry "jazz.walk-binding-assignable?" ("jazz.Slot-Declaration") 572 21 572 50 ()}
      {Lisp-Entry "jazz.emit-binding-assignment" ("jazz.Slot-Declaration") 576 21 576 49 ("jazz.error" "jazz.Any" "jazz.emit-expression" ",offset-locator" "jazz.sourcified-form" "%%object-set!" "jazz.new-code" "offset" "'offset" "declaration" "%%get-declaration-locator" "jazz.compose-helper" "offset-locator" "if" "jazz.*self*" "self" "let" "environment" "source-declaration" "value")}
      {Lisp-Entry "jazz.Property-Declaration" #f 595 27 595 52 ()}
      {Lisp-Entry "jazz.new-property-declaration" #f 598 9 598 38 ("jazz.setup-declaration" "jazz.Property-Declaration" "jazz.allocate-property-declaration" "new-declaration" "let" "setter-name" "getter-name" "initialize" "parent" "attributes" "compatibility" "access" "type" "name")}
      {Lisp-Entry "jazz.emit-declaration" ("jazz.Property-Declaration") 604 21 604 42 ("%%get-declaration-source" "jazz.declaration-result" "%%get-slot-offset" ",offset-locator" ",allocate?" ",name" "',name" ",class-locator" "jazz.add-property" ",slot-locator" "jazz.emit-expression" "jazz.sourcified-form" "self" ",initialize-locator" "define" "if" "begin" "jazz.sourcify-if" "%%get-property-declaration-setter" "setter" "%%get-property-declaration-getter" "getter" "offset" "'offset" "offset-locator" "slot" "'slot" "slot-locator" "'initialize" "jazz.compose-helper" "and" "initialize-locator" "%%get-slot-declaration-initialize" "initialize" "jazz.Void" "%%get-lexical-binding-type" "%%neq?" "allocate?" "class-locator" "%%get-declaration-parent" "class-declaration" "%%get-declaration-locator" "locator" "declaration" "%%get-lexical-binding-name" "name" "let*" "environment")}
      {Lisp-Entry "jazz.Method-Declaration" #f 640 27 640 50 ()}
      {Lisp-Entry "jazz.new-method-declaration" #f 643 9 643 36 ("jazz.setup-declaration" "jazz.Method-Declaration" "jazz.allocate-method-declaration" "new-declaration" "let" "signature" "synchronized" "remote" "expansion" "abstraction" "propagation" "root" "parent" "attributes" "compatibility" "access" "type" "name")}
      {Lisp-Entry "jazz.method-dispatch-info" #f 649 9 649 34 ("error" "else" "interface" "'interface" "jazz.Interface-Declaration" "class" "'class" "jazz.Class-Declaration" "%%class-is?" "cond" "%%get-declaration-parent" "category-declaration" "method-declaration" "root-method-declaration" "values" "inherited" "'inherited" "final" "'final" "%%eq?" "or" "%%not" "and" "if" "%%get-method-declaration-propagation" "propagation" "%%get-method-declaration-root" "root" "let" "declaration")}
      {Lisp-Entry "jazz.native-category?" #f 665 9 665 30 ("primitive" "'primitive" "%%get-category-declaration-implementor" "%%neq?" "category-declaration")}
      {Lisp-Entry "jazz.emit-method-dispatch" #f 669 9 669 34 ("%%get-lexical-binding-type" "jazz.call-return-type" "%%interface-dispatch" ",interface-rank-locator" "%%interface-native-dispatch" "interface-rank-locator" "interface" "%%class-dispatch" ",method-rank-locator" ",class-level-locator" "%%class-native-dispatch" "jazz.native-category?" "if" "rank" "'rank" "method-rank-locator" "level" "'level" "jazz.compose-helper" "class-level-locator" "class" ",implementation-locator" "jazz.sourcified-form" "%%final-dispatch" "%%get-declaration-locator" "implementation-locator" "final" "case" "jazz.new-code" "%%get-declaration-parent" "category-declaration" "jazz.method-dispatch-info" "method-declaration" "dispatch-type" "receive" "%%get-lexical-binding-name" "name" "let" "declaration" "object")}
      {Lisp-Entry "jazz.emit-binding-reference" ("jazz.Method-Declaration") 694 21 694 48 ("%%get-declaration-locator" "%%get-lexical-binding-name" "jazz.error" "%%get-code-type" "jazz.sourcified-form" "apply" "rest" "lambda" "jazz.new-code" "declaration" "jazz.emit-method-dispatch" "dispatch-code" "if" "jazz.*self*" "self" "let" "environment" "source-declaration")}
      {Lisp-Entry "jazz.walk-binding-validate-call" ("jazz.Method-Declaration") 706 21 706 52 ("jazz.validate-arguments" "if" "declaration" "%%get-method-declaration-signature" "signature" "let" "arguments" "operator" "source-declaration" "resume" "walker")}
      {Lisp-Entry "jazz.emit-inlined-binding-call" ("jazz.Method-Declaration") 712 21 712 51 ("else" "jazz.error" "jazz.call-return-type" "jazz.sourcified-form" "%%get-signature-positional" "%%get-lexical-binding-type" "jazz.emit-type-cast" "%%get-lexical-binding-name" "argument" "parameter" "map" "jazz.new-code" "jazz.emit-expression" "body-code" "cons" "augmented-environment" "frame" "lambda" "jazz.annotate-signature" "jazz.with-annotated-frame" "%%length" "%%get-signature-mandatory" "%%fx=" "jazz.only-positional?" "%%get-method-declaration-body" "body" "%%get-method-declaration-signature" "signature" "let" "final" "case" "jazz.method-dispatch-info" "method-declaration" "dispatch-type" "receive" "inline" "'inline" "declaration" "%%get-method-declaration-expansion" "%%eq?" "if" "environment" "source-declaration" "arguments")}
      {Lisp-Entry "jazz.emit-binding-call" ("jazz.Method-Declaration") 742 21 742 43 ("%%get-declaration-locator" "%%get-lexical-binding-name" "jazz.error" "%%get-code-type" ",@arguments" "jazz.sourcified-form" "jazz.new-code" "jazz.emit-method-dispatch" "dispatch-code" "jazz.codes-forms" "declaration" "%%get-lexical-binding-type" "type" "if" "jazz.*self*" "self" "let" "environment" "source-declaration" "arguments")}
      {Lisp-Entry "jazz.emit-declaration" ("jazz.Method-Declaration") 757 21 757 42 ("%%get-declaration-source" "',class-locator" "jazz.call-into-abstract" "rest" ",method-rank-locator" "abstract" "'abstract" "%%eq?" "if" "jazz.declaration-result" ",name" "',name" ",class-locator" ",method-call" "jazz.emit-expression" "jazz.sourcified-form" ",method-node-locator" "%%get-method-node-next-implementation" "nextmethod" "jazz.emit-signature-casts" "jazz.emit-signature" "self" ",method-locator" "define" "begin" "jazz.generate-symbol" "jazz.sourcify-if" "cons" "augmented-environment" "frame" "lambda" "jazz.annotate-signature" "jazz.with-annotated-frame" "jazz.Interface-Declaration" "jazz.add-virtual-method" "'jazz.add-virtual-method" "chained" "virtual" "jazz.add-final-method" "'jazz.add-final-method" "inherited" "final" "case" "jazz.Class-Declaration" "%%class-is?" "jazz.add-method-node" "'jazz.add-method-node" "cond" "method-call" "node" "'node" "method-node-locator" "rank" "'rank" "jazz.compose-helper" "method-rank-locator" "method-locator" "%%get-declaration-locator" "class-locator" "and" "root-category-declaration" "%%get-method-declaration-root" "root-method-declaration" "%%get-declaration-parent" "category-declaration" "let*" "%%get-method-declaration-body" "body" "%%get-method-declaration-signature" "signature" "%%get-method-declaration-abstraction" "abstraction" "%%get-method-declaration-propagation" "propagation" "declaration" "%%get-lexical-binding-name" "name" "let" "environment")}
      {Lisp-Entry "jazz.Jazz-Dialect" #f 821 19 821 36 ("jazz.allocate-jazz-dialect" "jazz.Object-Class" "jazz.Dialect")}
      {Lisp-Entry "jazz.Jazz-Dialect" #f 825 27 825 44 ()}
      {Lisp-Entry "jazz.new-jazz-dialect" #f 828 9 828 30 ("jazz.Jazz-Dialect" "jazz.allocate-jazz-dialect")}
      {Lisp-Entry "jazz.dialect-name" ("jazz.Jazz-Dialect") 832 21 832 38 ("'jazz")}
      {Lisp-Entry "jazz.dialect-walker" ("jazz.Jazz-Dialect") 836 21 836 40 ("jazz.new-jazz-walker")}
      {Lisp-Entry "jazz.Jazz-Walker" #f 848 19 848 35 ("jazz.allocate-jazz-walker" "jazz.Object-Class" "errors" "warnings" "jazz.Scheme-Walker")}
      {Lisp-Entry "jazz.Jazz-Walker" #f 852 27 852 43 ()}
      {Lisp-Entry "jazz.new-jazz-walker" #f 855 9 855 29 ("jazz.Jazz-Walker" "jazz.allocate-jazz-walker")}
      {Lisp-Entry "jazz.jazz-bindings" #f 864 9 864 27 ("jazz.expand-form" "form" "'form" "jazz.expand-com-external" "com-external" "'com-external" "jazz.expand-c-external-so" "c-external-so" "'c-external-so" "jazz.expand-c-external" "c-external" "'c-external" "jazz.expand-c-union" "c-union" "'c-union" "jazz.expand-c-structure" "c-structure" "'c-structure" "jazz.expand-assertion" "assertion" "'assertion" "jazz.expand-assert" "assert" "'assert" "jazz.expand-remotable-stub" "remotable-stub" "'remotable-stub" "jazz.walk-time" "time" "'time" "jazz.walk-construct" "construct" "'construct" "jazz.walk-cast" "cast" "'cast" "jazz.walk-with-dynamic-self" "with-dynamic-self" "'with-dynamic-self" "jazz.walk-with-self" "with-self" "'with-self" "jazz.walk-with-slots" "with-slots" "'with-slots" "jazz.walk-parameterize" "parameterize" "'parameterize" "jazz.walk-specialize" "%specialize" "'%specialize" "jazz.expand-specialize" "specialize" "'specialize" "jazz.walk-function" "function" "'function" "jazz.walk-c-definition" "c-definition" "'c-definition" "jazz.walk-c-type" "c-type" "'c-type" "jazz.walk-c-function" "c-function" "'c-function" "jazz.walk-c-initialize" "c-initialize" "'c-initialize" "jazz.walk-c-named-declare" "c-named-declare" "'c-named-declare" "jazz.walk-c-declare" "c-declare" "'c-declare" "jazz.walk-c-include" "c-include" "'c-include" "jazz.walk-declare" "declare" "'declare" "jazz.walk-method" "method" "'method" "%property" "'%property" "jazz.walk-%slot" "%slot" "'%slot" "jazz.expand-property" "property" "'property" "jazz.expand-slot" "slot" "'slot" "jazz.new-macro-form" "jazz.walk-interface" "interface" "'interface" "jazz.walk-%class" "%class" "'%class" "jazz.expand-class" "class" "'class" "jazz.new-syntax-form" "jazz.walk-specific" "specific" "'specific" "jazz.walk-generic" "generic" "'generic" "jazz.walk-definition" "definition" "'definition" "jazz.new-special-form" "%%list")}
      {Lisp-Entry "jazz.jazz-environment" #f 908 8 908 29 ()}
      {Lisp-Entry "jazz.walker-environment" ("jazz.Jazz-Walker") 912 21 912 44 ("jazz.jazz-bindings" "jazz.scheme-bindings" "jazz.core-bindings" "append" "jazz.new-walk-frame" "%%list" "set!" "begin" "jazz.jazz-environment" "or")}
      {Lisp-Entry "jazz.walk-declaration" ("jazz.Jazz-Walker") 924 21 924 42 ("nextmethod" "else" "jazz.walk-c-definition-declaration" "c-definition" "jazz.walk-c-type-declaration" "c-type" "jazz.walk-c-named-declare-declaration" "c-named-declare" "c-include" "jazz.walk-with-dynamic-self-declaration" "with-dynamic-self" "jazz.walk-method-declaration" "method" "jazz.walk-%slot-declaration" "%property" "%slot" "jazz.walk-interface-declaration" "interface" "jazz.walk-%class-declaration" "%class" "specific" "jazz.walk-generic-declaration" "generic" "jazz.walk-specialize-declaration" "%specialize" "walker" "jazz.walk-definition-declaration" "definition" "case" "%%car" "first" "let" "%%pair?" "if" "form" "environment" "declaration" "resume")}
      {Lisp-Entry "jazz.parse-keywords" #f 950 9 950 28 ("%%list" "jazz.unspecified" "%%table-ref" "keyword" "lambda" "map" "%%append" "values" "%%apply" "%%cddr" "%%cadr" "%%table-set!" "begin" "set!" "%%car" "jazz.source-code" "%%memq" "%%null?" "or" "if" "%%not" "%%while" "done?" "eq?" "test:" "%%make-table" "table" "let" "rest" "keywords")}
      {Lisp-Entry "jazz.emit-specialized-class-of" #f 980 9 980 39 ("%%get-category-declaration-metaclass" "jazz.Class-Declaration" "%%class-is?" "%%get-code-type" "type" "let" "%%class-of" "jazz.sourcified-form" "jazz.class-of" "jazz.debug-user?" "if" "jazz.new-code" "environment" "object")}
      {Lisp-Entry "jazz.walk-symbol" ("jazz.Jazz-Walker") 1025 21 1025 37 ("walker" "nextmethod" "jazz.new-reference" "jazz.Slot-Declaration" "%%class-is?" "%%assert" "jazz.find-class-declaration" "jazz.lookup-declaration" "slot-declaration" "if" "jazz.self-access" "slot-name" "jazz.source-code" "symbol" "let" "symbol-src" "environment" "declaration" "resume")}
      {Lisp-Entry "jazz.self-access" #f 1035 9 1035 25 ("%%string->symbol" "%%substring" "%%equal?" "0" "%%fx>" "and" "5" "%%fx-" "size" "%%string-length" "len" "%%symbol->string" "name" "let*" "symbol")}
      {Lisp-Entry "jazz.walk-symbol-assignment" ("jazz.Jazz-Walker") 1049 21 1049 48 ("nextmethod" "walker" "jazz.walk" "jazz.new-assignment" "jazz.Slot-Declaration" "%%class-is?" "%%assert" "jazz.find-class-declaration" "jazz.lookup-declaration" "slot-declaration" "if" "jazz.self-access" "slot-name" "let" "value" "symbol" "environment" "declaration" "resume")}
      {Lisp-Entry "jazz.walk-form" ("jazz.Jazz-Walker") 1063 21 1063 35 ("nextmethod" "walker" "jazz.walk-dispatch" "jazz.dispatch?" "if" "%%car" "jazz.source-code" "procedure-expr" "let" "form-src" "environment" "declaration" "resume")}
      {Lisp-Entry "jazz.With-Self" #f 1075 27 1075 41 ()}
      {Lisp-Entry "jazz.new-with-self" #f 1078 9 1078 27 ("jazz.With-Self" "jazz.allocate-with-self" "body")}
      {Lisp-Entry "jazz.emit-expression" ("jazz.With-Self") 1082 21 1082 41 ("jazz.Any" "jazz.emit-expression" "jazz.sourcified-form" "self" "'self" "jazz.*self*" "parameterize" "begin" "jazz.simplify-begin" "jazz.new-code" "expression" "%%get-with-self-body" "body" "let" "environment" "declaration")}
      {Lisp-Entry "jazz.fold-expression" ("jazz.With-Self") 1093 21 1093 41 ("%%get-with-self-body" "jazz.fold-expressions" "expression" "s" "k" "f")}
      {Lisp-Entry "jazz.With-Dynamic-Self" #f 1106 27 1106 49 ()}
      {Lisp-Entry "jazz.new-with-dynamic-self" #f 1109 9 1109 35 ("jazz.With-Dynamic-Self" "jazz.allocate-with-dynamic-self" "body" "code")}
      {Lisp-Entry "jazz.emit-expression" ("jazz.With-Dynamic-Self") 1113 21 1113 41 ("jazz.Any" "jazz.emit-statements-code" "jazz.sourcified-form" "jazz.*self*" "parameterize" "begin" "jazz.simplify-begin" "jazz.new-code" "%%get-with-dynamic-self-body" "body" "expression" "%%get-with-dynamic-self-code" "code" "let" "environment" "declaration")}
      {Lisp-Entry "jazz.fold-expression" ("jazz.With-Dynamic-Self") 1125 21 1125 41 ("%%get-with-dynamic-self-body" "jazz.fold-expressions" "expression" "s" "k" "f")}
      {Lisp-Entry "jazz.Cast" #f 1138 27 1138 36 ()}
      {Lisp-Entry "jazz.new-cast" #f 1141 9 1141 22 ("jazz.Cast" "jazz.allocate-cast" "expression" "type")}
      {Lisp-Entry "jazz.emit-expression" ("jazz.Cast") 1145 21 1145 41 ("jazz.emit-expression" "jazz.emit-type-cast" "jazz.new-code" "%%get-cast-expression" "expression" "%%get-expression-type" "type" "let" "environment" "declaration")}
      {Lisp-Entry "jazz.Construct" #f 1166 27 1166 41 ()}
      {Lisp-Entry "jazz.new-construct" #f 1169 9 1169 27 ("jazz.Construct" "jazz.allocate-construct" "values" "class")}
      {Lisp-Entry "jazz.emit-expression" ("jazz.Construct") 1173 21 1173 41 ("jazz.Any" "jazz.emit-expressions" "jazz.codes-forms" "jazz.emit-expression" "jazz.sourcified-form" "%%object" "jazz.new-code" "%%get-construct-values" "values" "expression" "%%get-construct-class" "class" "let" "environment" "declaration")}
      {Lisp-Entry "jazz.cache-dispatch" #f 1191 9 1191 28 ("jazz.interface-dispatch" "interface" "jazz.class-dispatch" "jazz.final-dispatch" "final" "%%get-method-dispatch-type" "case" "proc" "%%get-category-field" "field" "jazz.error" "%%assertion" "jazz.locate-method-owner" "category" "%%class-of" "class" "let" "object" "lambda" "setter" "name")}
      {Lisp-Entry "jazz.final-dispatch" #f 1209 9 1209 28 ("%%get-method-implementation" "%%final-dispatch" "jazz.dispatch-error" "%%category-is?" "%%debug-assertion" "object" "lambda" "type" "field")}
      {Lisp-Entry "jazz.class-dispatch" #f 1215 9 1215 28 ("%%class-dispatch" "jazz.dispatch-error" "%%category-is?" "%%debug-assertion" "object" "lambda" "%%get-method-implementation-rank" "implementation-rank" "%%get-method-category-rank" "class-level" "let" "type" "field")}
      {Lisp-Entry "jazz.interface-dispatch" #f 1223 9 1223 32 ("%%interface-dispatch" "jazz.dispatch-error" "%%category-is?" "%%debug-assertion" "object" "lambda" "%%get-method-implementation-rank" "implementation-rank" "%%get-method-category-rank" "interface-rank" "let" "type" "field")}
      {Lisp-Entry "jazz.dispatch" #f 1231 9 1231 22 ("jazz.error" "jazz.find-dispatch" "or" "name" "object")}
      {Lisp-Entry "jazz.find-dispatch" #f 1236 9 1236 27 ("%%interface-dispatch" "interface" "%%get-method-implementation-rank" "%%get-method-category-rank" "%%class-dispatch" "%%get-method-implementation" "%%final-dispatch" "final" "%%get-method-dispatch-type" "case" "%%get-category-field" "field" "%%not" "if" "jazz.locate-method-owner" "category" "%%class-of" "class" "let" "name" "object")}
      {Lisp-Entry "jazz.Dispatch" #f 1251 27 1251 40 ()}
      {Lisp-Entry "jazz.new-dispatch" #f 1254 9 1254 26 ("jazz.Dispatch" "jazz.allocate-dispatch" "arguments" "name" "source")}
      {Lisp-Entry "jazz.emit-expression" ("jazz.Dispatch") 1258 21 1258 41 ("expression" "jazz.emit-dispatch" "environment" "declaration")}
      {Lisp-Entry "jazz.emit-dispatch" #f 1262 9 1262 27 ("jazz.Any" ",object" "object" "jazz.with-uniqueness" ",d" "set!" ",name" "',name" "jazz.cache-dispatch" "%%set-cdr!" "d" "%%symbol->string" "%%string-append" "jazz.register-variable" "dv" "%%get-expression-source" "jazz.codes-forms" "jazz.sourcified-form" "jazz.new-code" "jazz.emit-method-dispatch" "dispatch-code" "code" "lambda" "jazz.with-code-value" "jazz.emit-inlined-final-dispatch" "or" "jazz.emit-expressions" "rest-codes" "jazz.emit-expression" "%%cdr" "rest-arguments" "%%car" "object-argument" "method" "'method" "dispatch" "'dispatch" "find" "'find" "to" "'to" "unable" "'unable" "%%get-declaration-locator" "In" "'In" "Warning:" "'Warning:" "jazz.debug" "optimizations" "'optimizations" "%%get-declaration-toplevel" "jazz.get-library-warn?" "jazz.warnings?" "begin" "%%not" "method-declaration" "lookup-method/warn" "jazz.Method-Declaration" "and" "jazz.lookup-declaration" "jazz.Category-Declaration" "lookup-method" "jazz.resolve-declaration" "jazz.Autoload-Declaration" "%%class-is?" "if" "%%get-code-type" "jazz.patch-type-until-unification" "object-type" "object-code" "resolve-type" "define" "%%get-dispatch-arguments" "arguments" "%%get-dispatch-name" "name" "let" "environment" "declaration" "expression")}
      {Lisp-Entry "jazz.with-code-value" #f 1316 9 1316 29 ("%%get-code-source" ",form" ",value" "%%get-code-type" "jazz.new-code" "jazz.generate-symbol" "value" "%%symbol?" "if" "%%get-code-form" "form" "let" "proc" "code")}
      {Lisp-Entry "jazz.emit-inlined-final-dispatch" #f 1329 9 1329 41 ("else" "jazz.error" "jazz.call-return-type" "%%get-signature-positional" "%%get-lexical-binding-type" "jazz.emit-type-cast" "%%get-lexical-binding-name" "argument" "parameter" "map" "jazz.sourcified-form" "self" "jazz.new-code" "jazz.emit-expression" "body-code" "cons" "augmented-environment" "frame" "lambda" "jazz.annotate-signature" "jazz.with-annotated-frame" "%%length" "%%get-signature-mandatory" "%%fx=" "jazz.only-positional?" "%%get-method-declaration-body" "body" "%%get-method-declaration-signature" "signature" "let" "final" "case" "jazz.method-dispatch-info" "method-declaration" "dispatch-type" "receive" "inline" "'inline" "%%get-method-declaration-expansion" "%%eq?" "if" "environment" "source-declaration" "arguments" "object" "declaration" "expression")}
      {Lisp-Entry "jazz.fold-expression" ("jazz.Dispatch") 1360 21 1360 41 ("%%get-dispatch-arguments" "jazz.fold-expressions" "%%get-dispatch-name" "expression" "s" "k" "f")}
      {Lisp-Entry "jazz.walk-dispatch" #f 1369 9 1369 27 ("jazz.walk-list" "jazz.new-dispatch" "%%desourcify" "jazz.error" "%%null?" "%%not" "%%assertion" "%%cdr" "arguments" "%%car" "jazz.source-code" "jazz.dispatch->symbol" "name" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.definition-modifiers" #f 1382 8 1382 33 ()}
      {Lisp-Entry "jazz.parse-definition" #f 1388 9 1388 30 (",@effective-body" ",parameters" "value" "unspecified" "'unspecified" "%%list" "%%null?" "effective-body" "body" "%%desourcify" "parameters" "let*" "values" "specifier" "lambda" "%%cdr" "jazz.parse-specifier" "name" "let" "%%car" "jazz.source-code" "%%symbol?" "if" "jazz.definition-modifiers" "jazz.parse-modifiers" "expansion" "compatibility" "access" "receive" "rest" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.walk-definition-declaration" #f 1406 9 1406 41 ("jazz.walk" "%%set-definition-declaration-value" "%%cons" "new-environment" "inline" "'inline" "%%eq?" "%%when" "jazz.add-declaration-child" "effective-declaration" "jazz.new-definition-declaration" "new-declaration" "jazz.build-function-type" "if" "effective-type" "jazz.walk-parameters" "and" "signature" "jazz.specifier->type" "type" "let" "%%cdr" "jazz.parse-definition" "parameters" "value" "expansion" "compatibility" "access" "specifier" "name" "receive" "form" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.walk-definition" #f 1420 9 1420 29 ("%%set-declaration-source" "jazz.walk" "%%set-definition-declaration-value" "inline" "'inline" "%%eq?" "%%not" "%%when" "%%cons" "new-environment" "jazz.find-form-declaration" "new-declaration" "let*" "jazz.source-code" "%%cdr" "jazz.parse-definition" "parameters" "value" "expansion" "compatibility" "access" "specifier" "name" "receive" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.build-function-type" #f 1433 9 1433 33 ("jazz.Any" "or" "and" "%%get-signature-rest" "rest" "let" "%%get-signature-named" "%%get-signature-optional" "%%get-signature-positional" "parameter-type" "map" "jazz.new-function-type" "result-type" "signature")
        {Lisp-Entry "parameter-type" #f 1434 11 1434 25 ("jazz.Any" "%%get-lexical-binding-type" "or" "parameter")}}
      {Lisp-Entry "jazz.specialize-modifiers" #f 1452 8 1452 33 ()}
      {Lisp-Entry "jazz.parse-specialize" #f 1456 9 1456 30 ("%%cddr" "%%cadr" "values" "as" "'as" "%%car" "%%eq?" "if" "jazz.specialize-modifiers" "jazz.parse-modifiers" "expansion" "receive" "rest" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.expand-specialize" #f 1463 9 1463 31 (",operator" "%specialize" ",@rest" ",@parameters" ",name" ",expansion" "definition" "begin" "jazz.compose-specializer-name" "or" "name" "parameters" "operator" "%%cdr" "%%car" "signature" "let" "jazz.parse-specialize" "as" "expansion" "receive" "rest" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.compose-specializer-name" #f 1475 9 1475 38 ("jazz.specifier->name" "%%list" "jazz.specifier?" "if" "parameter" "lambda" "map" "append" "string-append" "apply" "%%symbol->string" "%%string-append" "%%string->symbol" "parameters" "operator")}
      {Lisp-Entry "jazz.walk-specialize-declaration" #f 1490 9 1490 41 ("jazz.new-specialize" "jazz.add-specializer" "specializer-declaration" "jazz.lookup-reference" "specialized-declaration" "%%cddr" "%%car" "specializer" "%%cadr" "specialized" "let" "form" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.walk-specialize" #f 1500 9 1500 29 ("jazz.new-specialize" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.generic-modifiers" #f 1509 8 1509 30 ()}
      {Lisp-Entry "jazz.parse-generic" #f 1514 9 1514 27 ("values" "body" "specifier" "lambda" "jazz.parse-specifier" "%%cdr" "parameters" "name" "%%car" "signature" "let" "jazz.generic-modifiers" "jazz.parse-modifiers" "compatibility" "access" "receive" "rest" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.walk-generic-declaration" #f 1524 9 1524 38 ("jazz.walk-error" "jazz.add-declaration-child" "effective-declaration" "jazz.new-generic-declaration" "new-declaration" "jazz.walk-parameters" "signature" "jazz.dynamic-parameter-types" "jazz.lookup-reference" "dynamic-parameter-type" "lambda" "map" "dispatch-type-declarations" "jazz.Any" "jazz.walk-specifier" "type" "let" "jazz.Library-Declaration" "%%class-is?" "if" "%%cdr" "jazz.parse-generic" "body" "parameters" "compatibility" "access" "specifier" "name" "receive" "form" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.walk-generic" #f 1538 9 1538 26 ("%%set-declaration-source" "jazz.walk-body" "%%set-generic-declaration-body" "%%set-generic-declaration-signature" "jazz.find-form-declaration" "new-declaration" "jazz.walk-parameters" "augmented-environment" "signature" "%%cdr" "jazz.parse-generic" "body" "parameters" "compatibility" "access" "specifier" "name" "receive" "%%desourcify" "form" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.specific-modifiers" #f 1555 8 1555 31 ()}
      {Lisp-Entry "jazz.parse-specific" #f 1559 9 1559 28 ("values" "parameters" "name" "unspecified" "'unspecified" "%%list" "%%null?" "if" "effective-body" "%%cdr" "body" "%%car" "signature" "let*" "jazz.specific-modifiers" "jazz.parse-modifiers" "receive" "rest" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.walk-specific" #f 1569 9 1569 27 ("cons" "jazz.walk-error" "%%set-declaration-source" "jazz.walk-body" "%%set-specific-declaration-body" "nextmethod" "'nextmethod" "jazz.new-nextmethod-variable" "%%cons" "body-environment" "uptodate" "'uptodate" "public" "'public" "jazz.new-specific-declaration" "new-declaration" "jazz.walk-specific-root-dynamic-parameters?" "root?" "let*" "jazz.walk-parameters" "augmented-environment" "signature" "jazz.Generic-Declaration" "jazz.lookup-declaration" "generic-declaration" "jazz.Library-Declaration" "%%class-is?" "if" "%%cdr" "jazz.parse-specific" "body" "parameters" "name" "receive" "%%desourcify" "form" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.walk-specific-root-dynamic-parameters?" #f 1587 9 1587 52 ("else" "or" "cons" "%%get-declaration-locator" "%%get-lexical-binding-name" "jazz.walk-error" "%%eq?" "cdr" "if" "specific-class" "%%get-dynamic-parameter-class" "%%get-reference-binding" "jazz.resolve-declaration" "generic-class" "cond" "specific-dynamic?" "jazz.Dynamic-Parameter" "%%is?" "generic-dynamic?" "specific-parameter" "car" "%%pair?" "and" "generic-parameter" "root?" "specific-parameters" "%%get-generic-declaration-signature" "%%get-signature-positional" "generic-parameters" "iter" "let" "parameters" "name" "specific-signature" "generic-declaration" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.class-modifiers" #f 1617 8 1617 28 ()}
      {Lisp-Entry "jazz.class-keywords" #f 1623 8 1623 27 ()}
      {Lisp-Entry "jazz.parse-class" #f 1627 9 1627 25 ("values" "jazz.class-keywords" "jazz.parse-keywords" "body" "attributes" "interface-names" "ascendant-name" "metaclass-name" "%%cdr" "jazz.Any" "type" "%%car" "jazz.source-code" "name" "let" "jazz.class-modifiers" "jazz.parse-modifiers" "implementor" "compatibility" "abstraction" "access" "receive" "rest" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.expand-class" #f 1636 9 1636 26 (",@class-body" ",interface-names" "implements" "metaclass" ",name" ",access" ",@metaclass-body" ",ascendant-name" ":class" "extends" ",metaclass-name" "begin" "%%symbol->string" "%%string-append" "%%string->symbol" "let" "else" "jazz.walk-error" "%%specified?" "%class" "%%null?" "cond" "jazz.preprocess-meta" "class-body" "metaclass-body" "jazz.source-code" "%%cdr" "jazz.parse-class" "body" "attributes" "interface-names" "ascendant-name" "metaclass-name" "implementor" "compatibility" "abstraction" "access" "type" "name" "receive" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.preprocess-meta" #f 1652 9 1652 29 ("jazz.queue-list" "values" "%%cddr" "%%car" "%%cons" "jazz.enqueue" "meta" "'meta" "%%cadr" "%%eq?" "%%cdr" "jazz.source-code" "%%pair?" "and" "if" "expr" "lambda" "for-each" "class" "jazz.new-queue" "metaclass" "let" "body")}
      {Lisp-Entry "jazz.walk-%class-declaration" #f 1666 9 1666 37 ("jazz.walk-error" "jazz.walk-declarations" "%%cons" "new-environment" "jazz.setup-class-lookups" "jazz.add-declaration-child" "effective-declaration" "jazz.new-class-declaration" "jazz.Class-Declaration" "jazz.find-actual-declaration" "or" "new-declaration" "jazz.listify" "jazz.lookup-reference" "interface-name" "lambda" "map" "jazz.unspecified?" "interfaces" "jazz.lookup-metaclass" "metaclass" "let" "jazz.lookup-ascendant" "ascendant-base" "ascendant-relation" "ascendant" "jazz.Library-Declaration" "%%class-is?" "if" "%%cdr" "jazz.parse-class" "body" "attributes" "interface-names" "ascendant-name" "metaclass-name" "implementor" "compatibility" "abstraction" "access" "type" "name" "receive" "form" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.walk-%class" #f 1683 9 1683 25 ("%%set-declaration-source" "jazz.walk-namespace" "%%set-namespace-declaration-body" "begin" "jazz.error" "Object" "'Object" "%%neq?" "%%not" "and" "if" "%%get-class-declaration-ascendant" "ascendant-declaration" "%%cons" "new-environment" "jazz.find-form-declaration" "new-declaration" "let*" "%%cdr" "jazz.parse-class" "body" "attributes" "interface-names" "ascendant-name" "metaclass-name" "implementor" "compatibility" "abstraction" "access" "type" "name" "receive" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.lookup-metaclass" #f 1697 9 1697 30 ("jazz.lookup-reference" "Object-Class" "'Object-Class" "%%eq?" "jazz.unspecified?" "or" "if" "metaclass-name" "ascendant" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.lookup-ascendant" #f 1703 9 1703 30 ("else" "Object-Class" "'Object-Class" "jazz.effective-class-declaration-metaclass" "or" "%%cadr" "jazz.lookup-reference" "base" "relation" "let" ":class" "':class" "%%car" "%%eq?" "%%pair?" "and" "values" "jazz.unspecified?" "cond" "ascendant-name" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.effective-class-declaration-metaclass" #f 1723 9 1723 51 ("jazz.effective-class-declaration-metaclass" "%%get-class-declaration-ascendant" "ascendant" "%%get-category-declaration-metaclass" "or" "jazz.resolve-declaration" "let" "%%not" "if" "class-declaration")}
      {Lisp-Entry "jazz.interface-modifiers" #f 1740 8 1740 32 ()}
      {Lisp-Entry "jazz.interface-keywords" #f 1745 8 1745 31 ()}
      {Lisp-Entry "jazz.parse-interface" #f 1749 9 1749 29 ("values" "jazz.interface-keywords" "jazz.parse-keywords" "body" "attributes" "ascendant-names" "metaclass-name" "%%cdr" "jazz.Any" "type" "%%car" "name" "let" "jazz.interface-modifiers" "jazz.parse-modifiers" "implementor" "compatibility" "access" "receive" "rest" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.walk-interface-declaration" #f 1758 9 1758 40 ("jazz.walk-error" "jazz.walk-declarations" "%%cons" "new-environment" "jazz.setup-interface-lookups" "jazz.add-declaration-child" "effective-declaration" "jazz.new-interface-declaration" "new-declaration" "jazz.listify" "ascendant-name" "lambda" "map" "ascendants" "jazz.lookup-reference" "Interface" "'Interface" "%%eq?" "jazz.unspecified?" "or" "metaclass" "let" "jazz.Library-Declaration" "%%class-is?" "if" "%%cdr" "jazz.parse-interface" "body" "attributes" "ascendant-names" "metaclass-name" "implementor" "compatibility" "access" "type" "name" "receive" "form" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.walk-interface" #f 1772 9 1772 28 ("%%set-declaration-source" "jazz.walk-namespace" "%%set-namespace-declaration-body" "%%cons" "new-environment" "jazz.find-form-declaration" "new-declaration" "let*" "%%cdr" "jazz.parse-interface" "body" "attributes" "ascendant-names" "metaclass-name" "implementor" "compatibility" "access" "type" "name" "receive" "%%desourcify" "form" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.slot-modifiers" #f 1788 8 1788 27 ()}
      {Lisp-Entry "jazz.slot-keywords" #f 1792 8 1792 26 ()}
      {Lisp-Entry "jazz.slot-accessors-modifiers" #f 1796 8 1796 37 ()}
      {Lisp-Entry "jazz.slot-accessor-modifiers" #f 1804 8 1804 36 ()}
      {Lisp-Entry "jazz.parse-slot" #f 1812 9 1812 24 ("values" "jazz.walk-error" "%%not-null?" "if" "jazz.slot-keywords" "jazz.parse-keywords" "setter" "getter" "accessors" "initialize" "specifier" "lambda" "%%cdr" "jazz.parse-specifier" "%%car" "name" "let" "jazz.slot-modifiers" "jazz.parse-modifiers" "rest" "compatibility" "access" "receive" "form" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.expand-slot" #f 1823 9 1823 25 ("slot" "'slot" "%%cons" "jazz.expand-slot-form" "rest" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.parse-slot-accessors" #f 1827 9 1827 34 ("values" "jazz.walk-error" "%%not-null?" "if" "jazz.slot-accessors-modifiers" "jazz.parse-modifiers" "rest" "generation" "expansion" "abstraction" "propagation" "access" "receive" "form" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.parse-slot-accessor" #f 1834 9 1834 33 ("values" "jazz.walk-error" "else" "%%car" "%%cdr" "%%symbol->string" "%%string-append" "%%string->symbol" "generate" "'generate" "%%eq?" "and" "%%null?" "cond" "name" "or" "let" "jazz.slot-accessor-modifiers" "jazz.parse-modifiers" "rest" "generation" "expansion" "abstraction" "propagation" "access" "receive" "prefix" "form" "default-generation" "default-expansion" "default-abstraction" "default-propagation" "default-access" "slot-name" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.expand-slot-form" #f 1852 9 1852 30 ("set!" ",value" ",setter-expansion" ",setter-abstraction" ",setter-propagation" ",setter-access" ",@specifier-list" ",getter-expansion" ",getter-abstraction" ",getter-propagation" ",getter-access" "method" ",setter-name" ",getter-name" ",initialize" "with-self" "%%unspecified?" ",compatibility" ",access" ",specifier" ",name" "%slot" "'%slot" "%property" "'%property" "property" "'property" "%%car" "begin" "if" "specifier-list" "generate-setter?" "generate" "'generate" "%%eq?" "generate-getter?" "jazz.generate-symbol" "value" "let*" "setter-name" "setter-generation" "setter-expansion" "setter-abstraction" "setter-propagation" "setter-access" "jazz.parse-slot-accessor" "getter-name" "getter-generation" "getter-expansion" "getter-abstraction" "getter-propagation" "getter-access" "jazz.parse-slot-accessors" "default-generation" "default-expansion" "default-abstraction" "default-propagation" "default-access" "else" "%%list" "%%symbol?" "jazz.unspecified?" "cond" "info" "lambda" "standardize" "let" "%%cdr" "jazz.parse-slot" "setter" "getter" "accessors" "initialize" "compatibility" "access" "specifier" "name" "receive" "form" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.walk-%slot-declaration" #f 1884 9 1884 36 ("jazz.add-declaration-child" "effective-declaration" "new-declaration" "jazz.new-slot-declaration" "jazz.new-property-declaration" "%property" "'%property" "%%car" "%%eq?" "new" "jazz.Any" "jazz.walk-specifier" "if" "type" "let" "%%cdr" "setter-name" "getter-name" "initialize" "compatibility" "access" "specifier" "name" "jazz.bind" "form" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.walk-%slot" #f 1893 9 1893 24 ("%%set-declaration-source" ",name" "set!" ",setter-name" ",value" "jazz.generate-symbol" "value" "%%set-property-declaration-setter" ",getter-name" "with-self" "self" "lambda" "%%set-property-declaration-getter" "jazz.Property-Declaration" "%%class-is?" "%%when" "jazz.walk" "%%set-slot-declaration-initialize" "%%cadr" "jazz.find-form-declaration" "new-declaration" "jazz.unspecified?" "if" "%%cdr" "setter-name" "getter-name" "initialize" "compatibility" "access" "specifier" "name" "jazz.bind" "%%desourcify" "form" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.expand-property" #f 1925 9 1925 29 ("property" "'property" "%%cons" "jazz.expand-slot-form" "rest" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.method-modifiers" #f 1934 8 1934 29 ()}
      {Lisp-Entry "jazz.parse-method" #f 1945 9 1945 26 ("values" "unspecified" "'unspecified" "%%list" "%%null?" "if" "effective-body" "body" "specifier" "lambda" "jazz.parse-specifier" "%%desourcify" "%%cdr" "jazz.wrap-parameters" "parameters" "name" "let" "jazz.desourcify-list" "method" "'method" "%%cons" "%%get-declaration-toplevel" "%%get-lexical-binding-name" "jazz.error" "%%car" "jazz.source-code" "%%pair?" "and" "%%assertion" "jazz.method-modifiers" "jazz.parse-modifiers" "synchronized" "remote" "expansion" "abstraction" "propagation" "compatibility" "access" "receive" "rest" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.walk-method-declaration" #f 1956 9 1956 37 (",@body" "with-self" "jazz.walk" "%%set-method-declaration-body" "%%set-method-declaration-signature" "%%when" "jazz.add-declaration-child" "effective-declaration" "jazz.new-method-declaration" "new-declaration" "find-root-declaration" "root-declaration" "let*" "jazz.unspecified" "values" "jazz.walk-parameters" "augmented-environment" "signature" "concrete" "'concrete" "inline" "'inline" "%%eq?" "and" "inline?" "jazz.Procedure" "jazz.walk-specifier" "jazz.new-function-type" "if" "type" "let" "jazz.walk-error" "jazz.Category-Declaration" "%%class-is?" "%%assertion" "%%cdr" "jazz.parse-method" "body" "parameters" "synchronized" "remote" "expansion" "abstraction" "propagation" "compatibility" "access" "specifier" "name" "receive" "form" "environment" "declaration" "resume" "walker")
        {Lisp-Entry "find-root-declaration" #f 1957 11 1957 32 ("%%get-declaration-parent" "%%eq?" "if" "%%get-method-declaration-root" "or" "and" "root-declaration" "declaration" "jazz.lookup-declaration" "next-declaration" "let*" "name")}}
      {Lisp-Entry "jazz.walk-method" #f 1986 9 1986 25 ("%%set-declaration-source" "%%set-method-declaration-body" "%%set-method-declaration-signature" "inline" "'inline" "%%when" "concrete" "'concrete" ",@body" "with-self" "%%get-lexical-binding-type" "nextmethod" "'nextmethod" "jazz.new-nextmethod-variable" "%%cons" "jazz.walk" "body-expression" "let" "jazz.walk-parameters" "augmented-environment" "signature" "else" "'virtual" "jazz.Interface-Declaration" "%%not" "case" "'inherited" "%%neq?" "chained" "virtual" "inherited" "final" "%%memq" "%%eq?" "cond" "root-category-declaration" "%%get-method-declaration-propagation" "and" "root-method-propagation" "%%get-method-declaration-root" "root-method-declaration" "%%get-declaration-parent" "category-declaration" "jazz.lookup-declaration" "new-declaration" "let*" "jazz.walk-error" "jazz.Category-Declaration" "%%class-is?" "%%assertion" "jazz.source-code" "%%cdr" "jazz.parse-method" "body" "parameters" "synchronized" "remote" "expansion" "abstraction" "propagation" "compatibility" "access" "specifier" "name" "receive" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.wrap-parameters" #f 2023 9 2023 29 ("jazz.queue-list" "%%cdr" "with-self" ",@specifier-list" "%%cadr" "%%list" "specifier-list" "rest" "specifier" "lambda" "%%cddr" "jazz.parse-specifier" "%%keyword?" "jazz.enqueue" "jazz.specifier?" "%%pair?" "if" "%%car" "parameter" "else" "jazz.enqueue-list" "%%symbol?" "%%null?" "cond" "scan" "iter" "jazz.new-queue" "queue" "let" "parameters")}
      {Lisp-Entry "jazz.walk-cast" #f 2053 9 2053 23 ("jazz.walk" "jazz.walk-specifier" "jazz.new-cast" "%%cddr" "%%car" "expression" "%%cadr" "specifier" "%%desourcify" "form" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.walk-construct" #f 2066 9 2066 28 ("jazz.walk-list" "jazz.walk" "jazz.new-construct" "%%cddr" "values" "%%cadr" "class" "%%desourcify" "form" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.walk-with-self" #f 2079 9 2079 28 ("jazz.walk-body" "%%cdr" "body" "jazz.new-with-self" "jazz.new-self-binding" "%%cons" "new-environment" "%%desourcify" "form" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.parse-with-dynamic-self" #f 2092 9 2092 37 ("values" "%%cdr" "body" "%%car" "code" "let" "form")}
      {Lisp-Entry "jazz.walk-with-dynamic-self-declaration" #f 2098 9 2098 48 ("jazz.walk-declarations" "%%cdr" "jazz.parse-with-dynamic-self" "body" "code" "receive" "form" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.walk-with-dynamic-self" #f 2103 9 2103 36 ("jazz.walk-list" "jazz.new-with-dynamic-self" "jazz.new-dynamic-self-binding" "%%cons" "new-environment" "let" "%%desourcify" "%%cdr" "jazz.parse-with-dynamic-self" "body" "code" "receive" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.validate-proclaim" ("jazz.Jazz-Walker") 2116 21 2116 43 ("walker" "jazz.walk-error" "jazz.Category-Declaration" "jazz.Library-Declaration" "%%class-is?" "%%not" "and" "if" "form-src" "environment" "declaration" "resume")}
      {Lisp-Entry "jazz.validate-arguments" ("jazz.Jazz-Walker") 2128 21 2128 44 ("jazz.unspecified" "arguments" "signature" "declaration" "source-declaration" "resume")}
      {Lisp-Entry "jazz.remotable-stub-modifiers" #f 2137 8 2137 37 ()}
      {Lisp-Entry "jazz.remotable-stub-keywords" #f 2140 8 2140 36 ()}
      {Lisp-Entry "jazz.parse-remotable-stub" #f 2144 9 2144 34 ("values" "jazz.remotable-stub-keywords" "jazz.parse-keywords" "body" "ascendant-name" "%%cdr" "%%car" "name" "let" "jazz.remotable-stub-modifiers" "jazz.parse-modifiers" "access" "receive" "rest" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.method-stub-modifiers" #f 2152 8 2152 34 ()}
      {Lisp-Entry "jazz.parse-method-stub" #f 2158 9 2158 31 ("jazz.Any" "values" "body" "%%cdr" "parameters" "name" "%%car" "signature" "let*" "jazz.method-stub-modifiers" "jazz.parse-modifiers" "passage" "invocation" "access" "receive" "rest" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.expand-remotable-stub" #f 2167 9 2167 35 ("Remote-Proxy" "'Remote-Proxy" ",@values-method" "implements" "Local-Proxy" "'Local-Proxy" "metaclass" "Remotable-Stub" "'Remotable-Stub" ",stub-interface" "interface" ",remote-class" ",local-class" "Stub-Interface" "'Stub-Interface" "jazz.specified?" "extends" ",interface-class" "private" "class" "begin" "nextmethod" ",@values-list" "list" "append" "proxy-values" "values-method" "values-list" ",call" "function" ",value-keyword" "proxy-value" "self" "',name" ",invoker" "if" ",dispatch" ",@local-result" ",rest" ",@positional" "object" "" "apply" "%%not-null?" "%%when" ",@parameters" ",name" "abstract" "virtual" ",access" "value-keyword" "unspecified" "local-result" "dispatch" "call-remote" "'call-remote" "call" "exec-remote" "'exec-remote" "exec" "post-remote" "'post-remote" "post" "invoker" "jazz.parse-method-stub" "invocation" "method" "'method" "%%eq?" "method-form" "lambda" "for-each" "remotes" "locals" "proxies" "remote-class" "local-class" "stub-interface" "interface-class" "jazz.string->keyword" "0" "%%substring" "%%string=?" "4" "%%fx>" "and" "%%assert" "%%string-length" "len" "str" "let*" "value" "reference" "case" "passage" "parse-value-keyword" "%%cdr" "jazz.enqueue" "%%car" "else" "jazz.enqueue-list" "symbol?" "jazz.queue-list" "values" "%%null?" "cond" "scan" "iter" "parameter" "encode" "positional" "jazz.new-queue" "parameters" "let" "params" "parse-parameters" "%%symbol->string" "%%string-append" "%%string->symbol" "suffix" "add" "define" "jazz.parse-remotable-stub" "body" "ascendant-name" "access" "type" "name" "receive" "rest" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.expand-com-external" #f 2310 9 2310 33 ("jazz.emit-com-external" ",name" "jazz.emit-com-function" ",lowlevel-name" "definition" "begin" "cons" "jazz.C-Type-Declaration" "%%class-is?" "resolved" "jazz.every?" "jazz.platform.windows.com.HRESULT" "'jazz.platform.windows.com.HRESULT" "%%get-declaration-locator" "eq?" "hresult?" "%%symbol->string" "%%string-append" "%%string->symbol" "lowlevel-name" "resolved-directions" "cdr" "cadr" "map" "resolved-params" "resolved-result" "let" "jazz.walk-error" "jazz.resolve-c-type-reference" "symbol?" "type" "lambda" "resolve-declaration" "%%car" "%%null?" "if" "refiid" "car" "name" "let*" "rest" "signature" "result-type" "offset" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.emit-com-function" #f 2327 9 2327 31 ("resolved-params" "resolved-result" "offset")
        {Lisp-Entry "fix-locator" #f 2328 11 2328 22 ("%%get-declaration-locator" "symbol->string" "string-append" "string->symbol" "type" "'type" "%%get-c-type-declaration-kind" "eq?" "if" "declaration")}}
      {Lisp-Entry "jazz.emit-com-external" #f 2357 9 2357 31 ("'result" "=" ",@out-list" "values" "else" "car" "1" "unspecified" "0" "length" "case" "generate-free" "generate-ref" "begin" "validate-hresult" ",refiid" "validate-hresult2" "if" "generate-low" ",lowlevel-name" "result" "generate-encode/enref" "generate-in" "coptr" "function" "generate-out" "generate-cotype-transform" "out-list" "let" "refiid" "resolved-directions" "resolved-params" "lowlevel-name" "hresult?")
        {Lisp-Entry "generate-in" #f 2358 11 2358 22 ("%%number->string" "%%string-append" "%%string->symbol" "out" "'out" "eq?" "if" "order" "resolved-direction" "resolved-param")}
        {Lisp-Entry "generate-low" #f 2362 11 2362 23 ("%%number->string" "%%string-append" "%%string->symbol" "order" "resolved-direction" "resolved-param")}
        {Lisp-Entry "generate-out" #f 2364 11 2364 23 ("%%number->string" "%%string-append" "%%string->symbol" "in" "'in" "eq?" "if" "order" "resolved-direction" "resolved-param")}
        {Lisp-Entry "generate-encode/enref" #f 2368 11 2368 32 (",value" ",encode/enref" ",binding" "generate-in" "get-cotype-default-value" "out" "'out" "eq?" "if" "value" "get-cotype-encode/enref" "encode/enref" "generate-low" "binding" "let" "order" "resolved-direction" "resolved-param")}
        {Lisp-Entry "generate-ref" #f 2377 11 2377 23 (",value" ",ref" ",binding" "generate-low" "value" "get-cotype-ref" "ref" "generate-out" "binding" "let" "in" "'in" "eq?" "if" "order" "resolved-direction" "resolved-param")}
        {Lisp-Entry "generate-free" #f 2386 11 2386 24 (",value" ",free" "if" "generate-low" "value" "get-cotype-free" "free" "let" "order" "resolved-direction" "resolved-param")}
        {Lisp-Entry "generate-cotype-transform" #f 2392 11 2392 36 ("+" "cdr" "cons" "car" "generated" "pair?" "if" "1" "order" "resolved-directions" "resolved-params" "iter" "let" "generator")}}
      {Lisp-Entry "get-cotype-default-value" #f 2427 9 2427 33 ("else" "jazz.platform.windows.com.LONG*" "0" "jazz.platform.windows.com.INT*" "jazz.platform.windows.com.IUnknown**" "jazz.platform.windows.com.IUnknown*" "jazz.platform.windows.com.VARIANT*" "jazz.platform.windows.com.VARIANT" "jazz.platform.windows.com.VARIANT_BOOL*" "jazz.platform.windows.com.VARIANT_BOOL" "jazz.platform.windows.com.GUID*" "jazz.platform.windows.com.GUID" "jazz.platform.windows.com.BSTR*" "error" "jazz.platform.windows.com.BSTR" "%%get-declaration-locator" "case" "cotype")}
      {Lisp-Entry "get-cotype-encode/enref" #f 2444 9 2444 32 ("else" "LONG-enref" "'LONG-enref" "jazz.platform.windows.com.LONG*" "INT-enref" "'INT-enref" "jazz.platform.windows.com.INT*" "IUnknown*-enref" "'IUnknown*-enref" "jazz.platform.windows.com.IUnknown**" "jazz.platform.windows.com.IUnknown*" "jazz.platform.windows.com.VARIANT*" "VARIANT-encode" "'VARIANT-encode" "jazz.platform.windows.com.VARIANT" "VARIANT_BOOL-enref" "'VARIANT_BOOL-enref" "jazz.platform.windows.com.VARIANT_BOOL*" "VARIANT_BOOL-encode" "'VARIANT_BOOL-encode" "jazz.platform.windows.com.VARIANT_BOOL" "jazz.platform.windows.com.GUID*" "GUID-encode" "'GUID-encode" "jazz.platform.windows.com.GUID" "BSTR*-enref" "'BSTR*-enref" "jazz.platform.windows.com.BSTR*" "BSTR-encode" "'BSTR-encode" "jazz.platform.windows.com.BSTR" "%%get-declaration-locator" "case" "cotype")}
      {Lisp-Entry "get-cotype-ref" #f 2461 9 2461 23 ("else" "LONG*-ref" "'LONG*-ref" "jazz.platform.windows.com.LONG*" "INT*-ref" "'INT*-ref" "jazz.platform.windows.com.INT*" "IUnknown**-ref" "'IUnknown**-ref" "jazz.platform.windows.com.IUnknown**" "jazz.platform.windows.com.IUnknown*" "jazz.platform.windows.com.VARIANT*" "VARIANT-ref" "'VARIANT-ref" "jazz.platform.windows.com.VARIANT" "VARIANT_BOOL*-ref" "'VARIANT_BOOL*-ref" "jazz.platform.windows.com.VARIANT_BOOL*" "VARIANT_BOOL-decode" "'VARIANT_BOOL-decode" "jazz.platform.windows.com.VARIANT_BOOL" "jazz.platform.windows.com.GUID*" "GUID-ref" "'GUID-ref" "jazz.platform.windows.com.GUID" "BSTR*-ref" "'BSTR*-ref" "jazz.platform.windows.com.BSTR*" "BSTR-ref" "'BSTR-ref" "jazz.platform.windows.com.BSTR" "%%get-declaration-locator" "case" "cotype")}
      {Lisp-Entry "get-cotype-free" #f 2478 9 2478 24 ("else" "LONG*-free" "'LONG*-free" "jazz.platform.windows.com.LONG*" "INT*-free" "'INT*-free" "jazz.platform.windows.com.INT*" "IUnknown**-free" "'IUnknown**-free" "jazz.platform.windows.com.IUnknown**" "jazz.platform.windows.com.IUnknown*" "jazz.platform.windows.com.VARIANT*" "VARIANT-decode" "'VARIANT-decode" "jazz.platform.windows.com.VARIANT" "VARIANT_BOOL*-free" "'VARIANT_BOOL*-free" "jazz.platform.windows.com.VARIANT_BOOL*" "jazz.platform.windows.com.VARIANT_BOOL" "jazz.platform.windows.com.GUID*" "GUID-free" "'GUID-free" "jazz.platform.windows.com.GUID" "BSTR*-free" "'BSTR*-free" "jazz.platform.windows.com.BSTR*" "BSTR-free" "'BSTR-free" "jazz.platform.windows.com.BSTR" "%%get-declaration-locator" "case" "cotype")}
      {Lisp-Entry "jazz.validate-access" ("jazz.Jazz-Walker") 2500 21 2500 41 ("referenced-declaration" "declaration" "resume")}
      {Lisp-Entry "jazz.validate-private-access" #f 2510 9 2510 37 ("jazz.illegal-access" "%%get-declaration-toplevel" "%%neq?" "if" "referenced-declaration" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.validate-protected-access" #f 2516 9 2516 39 ("jazz.unspecified" "referenced-declaration" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.illegal-access" #f 2521 9 2521 28 ("jazz.walk-error" "%%get-declaration-locator" "referenced-locator" "%%get-declaration-access" "referenced-access" "let" "referenced-declaration" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.expand-assert" #f 2532 9 2532 27 ("jazz.debug-user?" "jazz.expand-assert-test" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.expand-assertion" #f 2536 9 2536 30 ("jazz.debug-user?" "jazz.expand-assertion-test" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.expand-assert-test" #f 2540 9 2540 32 ("error" "'error" "list" "jazz.expand-assertion-body" "get-output-string" "%%desourcify" "write" "display" "open-output-string" "port" "message" "%%cddr" "body" "jazz.source-code" "%%cadr" "assertion" "let" "src" "test?")}
      {Lisp-Entry "jazz.expand-assertion-test" #f 2551 9 2551 35 ("jazz.expand-assertion-body" "%%cdr" "body" "%%cddr" "%%car" "action" "jazz.source-code" "%%cadr" "assertion" "let" "src" "test?")}
      {Lisp-Entry "jazz.expand-assertion-body" #f 2558 9 2558 35 (",@body" "begin" "jazz.simplify-begin" ",action" ",assertion" "not" "unspecified" "%%not-null?" "if" "let" "body" "action" "assertion" "test?")}
      {Lisp-Entry "jazz.walk-declare" #f 2574 9 2574 26 ("jazz.new-declare" "%%cdr" "declarations" "%%desourcify" "form" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.walk-c-include" #f 2585 9 2585 28 ("jazz.new-c-include" "%%cdr" "name" "jazz.bind" "%%desourcify" "form" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.walk-c-declare" #f 2596 9 2596 28 ("jazz.new-c-declare" "%%cdr" "code" "jazz.bind" "%%desourcify" "form" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.c-named-declare-modifiers" #f 2607 8 2607 38 ()}
      {Lisp-Entry "jazz.parse-c-named-declare" #f 2612 9 2612 35 ("values" "jazz.Any" "type" "let" "code" "name" "jazz.bind" "jazz.c-named-declare-modifiers" "jazz.parse-modifiers" "compatibility" "access" "receive" "rest" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.walk-c-named-declare-declaration" #f 2619 9 2619 46 ("jazz.add-declaration-child" "effective-declaration" "jazz.new-c-named-declare-declaration" "new-declaration" "let" "%%cdr" "jazz.parse-c-named-declare" "code" "compatibility" "access" "type" "name" "receive" "form" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.resolve-c-named-declare-reference" #f 2626 9 2626 47 ("%%get-declaration-locator" "jazz.walk-error" "jazz.C-Named-Declare-Declaration" "%%class-is?" "if" "jazz.lookup-reference" "c-named-declare-declaration" "let" "symbol" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.walk-c-named-declare" #f 2633 9 2633 34 ("jazz.find-form-declaration" "new-declaration" "%%cdr" "jazz.parse-c-named-declare" "code" "compatibility" "access" "type" "name" "receive" "%%desourcify" "form" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.walk-c-initialize" #f 2645 9 2645 31 ("jazz.new-c-initialize" "%%cdr" "code" "jazz.bind" "%%desourcify" "form" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.c-type-modifiers" #f 2656 8 2656 29 ()}
      {Lisp-Entry "jazz.parse-c-type" #f 2661 9 2661 26 ("declare" "scheme-to-c" "c-to-scheme" "values" "%%null?" "if" "jazz.Any" "type" "let" "conversions" "c-type" "name" "jazz.bind" "jazz.c-type-modifiers" "jazz.parse-modifiers" "compatibility" "access" "receive" "rest" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.walk-c-type-declaration" #f 2671 9 2671 37 ("jazz.add-declaration-child" "effective-declaration" "%%get-c-type-declaration-pointer-types" "cons" "%%set-c-type-declaration-pointer-types" "%%when" "jazz.new-c-type-declaration" "new-declaration" "jazz.walk-error" "jazz.resolve-c-named-declare-reference" "%%cons" "%%string?" "let" "jazz.resolve-c-type" "inclusions" "base-type-declaration" "expansion" "kind" "jazz.Library-Declaration" "%%class-is?" "if" "%%cdr" "jazz.parse-c-type" "declare" "scheme-to-c" "c-to-scheme" "c-type" "compatibility" "access" "type" "name" "receive" "form" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.walk-c-type" #f 2688 9 2688 25 ("jazz.find-form-declaration" "%%cdr" "jazz.parse-c-type" "declare" "scheme-to-c" "c-to-scheme" "c-type" "compatibility" "access" "type" "name" "receive" "%%desourcify" "form" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.resolve-c-type" #f 2694 9 2694 28 ("jazz.queue-list" "base-type-declaration" "expansion" "kind" "receive" "jazz.error" "else" "'union" "union" "'struct" "struct" "map" "'function" "result-type" "parameter-types" "function" "and" "resolve-expansion" "'pointer" "base-type" "pointer" ",@tag-rest" ",c-string" "%%cdr" "tag-rest" "c-string" "jazz.bind" "%%cadr" "'native" "native" "%%car" "case" "%%pair?" "'type" "%%string?" "%%get-declaration-locator" "alias" "'alias" "values" "jazz.enqueue" "jazz.resolve-c-type-reference" "c-type-declaration" "%%symbol?" "cond" "resolve" "define" "jazz.new-queue" "queue" "let" "type" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.resolve-c-type-reference" #f 2734 9 2734 38 ("%%get-declaration-locator" "jazz.walk-error" "jazz.C-Type-Declaration" "%%class-is?" "if" "jazz.lookup-reference" "c-type-declaration" "let" "symbol" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.expand-c-type-reference" #f 2741 9 2741 37 ("%%get-library-declaration-inclusions" "%%append" "%%set-library-declaration-inclusions" "%%get-declaration-toplevel" "library-declaration" "let" "jazz.resolve-c-type" "inclusions" "base-type-declaration" "expansion" "kind" "receive" "type" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.walk-c-function" #f 2753 9 2753 29 (",c-name-or-code" "map" "c-lambda" "jazz.new-c-function" "jazz.expand-c-type-reference" "type" "lambda" "resolve-access" "%%cdr" "c-name-or-code" "result-type" "types" "jazz.bind" "jazz.error" "%%length" "4" "=" "list?" "and" "%%assertion" "%%desourcify" "form" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.c-definition-modifiers" #f 2767 8 2767 35 ()}
      {Lisp-Entry "jazz.parse-c-definition" #f 2772 9 2772 32 ("values" "%%cdr" "parameters" "jazz.Any" "type" "%%car" "name" "let" "body" "scope" "c-name" "result-type" "parameter-types" "signature" "jazz.bind" "jazz.c-definition-modifiers" "jazz.parse-modifiers" "compatibility" "access" "receive" "rest" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.walk-c-definition-declaration" #f 2781 9 2781 43 ("jazz.add-declaration-child" "effective-declaration" "map" "jazz.new-c-definition-declaration" "new-declaration" "jazz.walk-parameters" "signature" "jazz.expand-c-type-reference" "lambda" "resolve-access" "let" "%%cdr" "jazz.parse-c-definition" "body" "scope" "c-name" "result-type" "parameter-types" "parameters" "compatibility" "access" "type" "name" "receive" "form" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.walk-c-definition" #f 2790 9 2790 31 ("%%set-declaration-source" "jazz.walk-body" "%%set-c-definition-declaration-body" "%%set-c-definition-declaration-signature" "jazz.walk-parameters" "augmented-environment" "signature" "jazz.find-form-declaration" "new-declaration" "let*" "%%cdr" "jazz.parse-c-definition" "body" "scope" "c-name" "result-type" "parameter-types" "parameters" "compatibility" "access" "type" "name" "receive" "%%desourcify" "form" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.build-pointer-symbol" #f 2807 9 2807 34 ("%%symbol->string" "%%string-append" "%%string->symbol" "type")}
      {Lisp-Entry "jazz.pointer?" #f 2811 9 2811 22 ("1" "%%fx-" "%%string-ref" "%%eq?" "%%string-length" "lgt" "%%symbol->string" "str" "let*" "type")}
      {Lisp-Entry "jazz.build-method-symbol" #f 2817 9 2817 33 ("map" "symbol->string" "string-append" "apply" "%%string->symbol" "rest" "struct")}
      {Lisp-Entry "jazz.parse-structure-name" #f 2821 9 2821 34 ("%%cddr" "%%cadr" "%%car" "%%symbol->string" "values" "%%symbol?" "if" "name")}
      {Lisp-Entry "jazz.kind+type" #f 2827 9 2827 23 ("values" "car" "alias" "'alias" "eq?" "if" "%%get-c-type-declaration-inclusions" "inclusions" "%%get-c-type-declaration-expansion" "expansion" "%%get-c-type-declaration-kind" "kind" "jazz.resolve-c-type-reference" "loop" "let" "type" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.expand-accessor" #f 2837 9 2837 29 ("values" ",setter-string" "void" "-set!" "'-set!" "setter" ",getter-string" ",type" ",struct*" "c-function" "-ref" "'-ref" "jazz.build-method-symbol" "definition" "getter" "%%memq" "wchar_t-string" "char-string" "type*" "jazz.build-pointer-symbol" "struct*" "let*" "'type" "'union" "'struct" "else" "number->string" "size-string" "cond" "setter-string" "union" "function" "pointer" "native" "case" "%%string-append" "wchar_t" "'wchar_t" "char" "'char" "%%eq?" "or" "if" "getter-string" "%%symbol->string" "id-string" "jazz.kind+type" "expansion" "kind" "receive" "jazz.walk-error" "%%symbol?" "%%integer?" "%%when" "%%null?" "%%not" "and" "%%cddr" "clause-rest" "size" "%%cadr" "id" "%%car" "type" "let" "struct" "clause" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.expand-structure/union" #f 2893 9 2893 36 ("map" "append" "apply" "unsigned-int" "'sizeof" "void" "native" "free" "'free" "c-function" "make" "'make" "jazz.build-method-symbol" "definition" ",@tag*-rest" "pointer" ",struct*" ",@tag-rest" ",c-struct-string" "type" ",struct" "c-type" "begin" "%%list" "jazz.expand-accessor" "setter" "getter" "clause" "expand-accessor" "define" "cdr" "car" "cons" "null?" "if" "tag*-rest" "%%string-append" "sizeof" "jazz.build-pointer-symbol" "struct*" "let" "jazz.parse-structure-name" "tag-rest" "c-struct-string" "struct" "receive" "clauses" "name" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.expand-c-structure" #f 2915 9 2915 32 ("jazz.expand-structure/union" "clauses" "name" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.expand-c-structure-array" #f 2919 9 2919 38 ("array-element" "'array-element" "%%string-append" ",struct*" "int" "c-function" "array-make" "'array-make" "jazz.build-method-symbol" "definition" "begin" "%%symbol->string" "%%car" "%%null?" "%%not" "if" "c-struct-string" "jazz.build-pointer-symbol" "struct*" "struct" "let*" "rest" "name" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.expand-c-union" #f 2930 9 2930 28 ("jazz.expand-structure/union" "clauses" "name" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.expand-c-external" #f 2939 9 2939 31 (",c-name" ",type" ",params" "c-function" ",s-name" "definition" "%%symbol->string" "%%null?" "if" "c-name" "%%cdr" "params" "%%car" "s-name" "let*" "rest" "signature" "type" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.expand-c-external-so" #f 2948 9 2948 34 ("WCHAR-string" "values" ",ext-s-name" "result" "WCHAR-copy" "1" ",string-param" "string-length" "+" "WCHAR-array-make" "pt" "let" ",@new-params" ",s-name" "definition" ",c-name" "%%cons" ",type" "c-external" "begin" "%%null?" "if" "c-name" "list-ref" "string-param" "jazz.generate-symbol" "param" "lambda" "map" "new-params" "%%cdr" "params" "%%symbol->string" "%%string-append" "%%string->symbol" "ext-s-name" "%%car" "s-name" "let*" "rest" "signature" "arg" "type" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.parse-function" #f 2970 9 2970 28 ("values" "unspecified" "'unspecified" "%%list" "%%null?" "if" "effective-body" "body" "%%car" "%%desourcify" "parameters" "jazz.source-code" "%%cdr" "rest" "let*" "form-src" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.walk-function" #f 2978 9 2978 27 (",@body" ",parameters" "lambda" "jazz.walk-lambda" "jazz.parse-function" "body" "parameters" "receive" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.walk-parameterize" #f 2991 9 2991 31 ("jazz.walk-body" "jazz.queue-list" "jazz.new-parameterize" "jazz.walk" "%%cons" "jazz.enqueue" "%%cdr" "value" "%%car" "variable" "continuation-capture" "binding-form" "lambda" "for-each" "jazz.new-queue" "expanded-bindings" "unspecified" "'unspecified" "%%list" "%%null?" "if" "effective-body" "%%cddr" "body" "%%cadr" "jazz.source-code" "bindings" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.walk-with-slots" #f 3018 9 3018 29 (",@body" ",setter-name" "',setter-name" "value" "',object-symbol" ",getter-name" "',getter-name" "%%list" "%%get-slot-declaration-setter-name" "setter-name" "%%get-slot-declaration-getter-name" "getter-name" "jazz.lookup-reference" "slot-declaration" "let*" "slot-name" "lambda" "map" "let-symbol" ",object" ",object-symbol" "jazz.walk" "jazz.generate-symbol" "object-symbol" "%%cdr" "body" "object" "slot-names" "jazz.bind" "%%desourcify" "form" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.walk-time" #f 3038 9 3038 23 ("jazz.walk" "jazz.new-time-special" "%%cadr" "%%desourcify" "form" "let" "form-src" "environment" "declaration" "resume" "walker")}
      {Lisp-Entry "jazz.expand-form" #f 3049 9 3049 25 ("nextmethod" "cons" "get-class-forms" "get-class-form" "method" "',class-locator" "register-form" ",class-locator" ",form" "',form" "jml->form>>" "class-form" "definition" "begin" "%%get-declaration-locator" "class-locator" "class-declaration" "let*" "form" "environment" "declaration" "resume" "walker")}}})
"ecase"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "dialect" "syntax" "ecase.scm"} 1238328026
    {Lisp-Entry "jazz.dialect.syntax.ecase" #f 37 19 37 44 ("scheme")
      {Lisp-Entry "ecase" #f 50 9 50 14 ("=" "'=" "integer?" "eqv?" "'eqv?" "list" "or" "'or" "pair?" "cons" "else" "'else" "eq?" "cdr" "body" "car" "desourcify" "value" "clause" "map" "cond" "symbol" "lambda" "with-uniqueness" "sourcify-if" "cddr" "clauses" "source-code" "cadr" "target" "let" "form-src")}}})
"either"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "dialect" "syntax" "either.scm"} 1238328026
    {Lisp-Entry "jazz.dialect.syntax.either" #f 37 19 37 45 ("scheme")
      {Lisp-Entry "either" #f 48 9 48 15 ("'let" "generate-symbol" "symbol" "'if" "list" "rest" "expr" "bind" "pair" "lambda" "proc" "letrec" "set!" "car" "symbol?" "when" "not" "while" "complex?" "scan" "sourcify-if" "error" "null?" "if" "source-code" "cdr" "expressions" "let" "form-src")}}})
"enumeration"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "dialect" "syntax" "enumeration.scm"} 1238328026
    {Lisp-Entry "jazz.dialect.syntax.enumeration" #f 37 19 37 50 ("scheme")}})
"essay"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "dialect" "syntax" "essay.scm"} 1238328026
    {Lisp-Entry "jazz.dialect.syntax.essay" #f 37 19 37 44 ("scheme")
      {Lisp-Entry "essay" #f 46 9 46 14 (",expr" ",@tests" "and" "when" "last" "expr" "butlast" "tests" "sourcify-if" "error" "null?" "if" "source-code" "cdr" "expressions" "let" "form-src")}}})
"exception"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "dialect" "core" "exception.scm"} 1238328026
    {Lisp-Entry "jazz.dialect.core.exception" #f 39 18 39 45 ()
      {Lisp-Entry "jazz.get-exception-hook" #f 47 9 47 32 ("##primordial-exception-handler-hook")}
      {Lisp-Entry "jazz.set-exception-hook" #f 50 9 50 32 ("##primordial-exception-handler-hook" "set!" "hook")}
      {Lisp-Entry "jazz.invoke-exception-hook" #f 54 9 54 35 ("##thread-end-with-uncaught-exception!" "exc" "hook")}
      {Lisp-Entry "jazz.system-exception-hook" #f 63 9 63 35 ("##repl-exception-handler-hook" "jazz.setup-terminal" "other" "exc")}
      {Lisp-Entry "jazz.setup-terminal" #f 73 9 73 28 ("jazz.bring-terminal-to-front" "jazz.set-terminal-title" "begin" "repl-output-port" "tty?" "if")}
      {Lisp-Entry "jazz.set-terminal-title" #f 80 9 80 32 ("repl-output-port" "display")}
      {Lisp-Entry "jazz.bring-terminal-to-front" #f 83 9 83 37 ("repl-output-port" "display")}
      {Lisp-Entry "jazz.clear-terminal" #f 86 9 86 28 ("repl-output-port" "display")}
      {Lisp-Entry "jazz.with-exception-filter" #f 95 9 95 35 ("%%continuation-graft" "filter-exc" "if" "exc" "with-exception-handler" "catcher-cont" "lambda" "%%continuation-capture" "current-exception-handler" "previous-handler" "let" "thunk" "catcher" "filter")}
      {Lisp-Entry "jazz.with-exception-propagater" #f 120 9 120 39 ("current-exception-handler" "let" "%%continuation-graft" "raise-cont" "exc" "with-exception-handler" "catcher-cont" "lambda" "%%continuation-capture" "thunk" "handler")}}})
"foreign"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "dialect" "core" "foreign.scm"} 1238328026
    {Lisp-Entry "jazz.dialect.core.foreign" #f 37 18 37 43 ()
      {Lisp-Entry "jazz.foreign?" #f 42 12 42 25 ("foreign?")}
      {Lisp-Entry "jazz.foreign-address" #f 43 12 43 32 ("foreign-address")}
      {Lisp-Entry "jazz.foreign-release!" #f 44 12 44 33 ("foreign-release!")}
      {Lisp-Entry "jazz.foreign-released?" #f 45 12 45 34 ("foreign-released?")}
      {Lisp-Entry "jazz.foreign-tags" #f 46 12 46 29 ("foreign-tags")}
      {Lisp-Entry "jazz.still-obj-refcount-dec!" #f 51 13 51 41 ("%%still-obj-refcount-dec!" "foreign")}
      {Lisp-Entry "jazz.still-obj-refcount-inc!" #f 54 13 54 41 ("%%still-obj-refcount-inc!" "foreign")}}})
"increase"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "dialect" "syntax" "increase.scm"} 1238328026
    {Lisp-Entry "jazz.dialect.syntax.increase" #f 37 19 37 47 ("scheme")
      {Lisp-Entry "increase!" #f 43 8 43 17 (",increment" "+" ",location" "set!" "car" "1" "null?" "if" "increment" "let" "rest" "location")}
      {Lisp-Entry "decrease!" #f 51 8 51 17 (",increment" "-" ",location" "set!" "car" "1" "null?" "if" "increment" "let" "rest" "location")}}})
"install"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "install.scm"} 1238328026
    {Lisp-Entry "jazz.install" #f 37 8 37 20 ("jazz.install-jazz-literals" "jazz.register-reader-extension" "construct-lisp-entry" "'construct-lisp-entry" "Lisp-Entry" "'Lisp-Entry" "construct-lisp-file-entry" "'construct-lisp-file-entry" "Lisp-File-Entry" "'Lisp-File-Entry" "construct-c-export-entry" "'construct-c-export-entry" "C-Export-Entry" "'C-Export-Entry" "construct-c-include-entry" "'construct-c-include-entry" "C-Include-Entry" "'C-Include-Entry" "construct-c-define-entry" "'construct-c-define-entry" "C-Define-Entry" "'C-Define-Entry" "construct-c-category-entry" "'construct-c-category-entry" "C-Category-Entry" "'C-Category-Entry" "construct-c-file-entry" "'construct-c-file-entry" "C-File-Entry" "'C-File-Entry" "construct-version" "'construct-version" "Version" "'Version" "construct-selection-handler" "'construct-selection-handler" "Selection-Handler" "'Selection-Handler" "construct-event-handler" "'construct-event-handler" "Event-Handler" "'Event-Handler" "construct-event" "'construct-event" "Event" "'Event" "construct-cursor-resource" "'construct-cursor-resource" "Cursor-Resource" "'Cursor-Resource" "construct-icon-resource" "'construct-icon-resource" "Icon-Resource" "'Icon-Resource" "construct-bitmap-resource" "'construct-bitmap-resource" "Bitmap-Resource" "'Bitmap-Resource" "construct-formatted-text" "'construct-formatted-text" "Formatted-Text" "'Formatted-Text" "construct-text" "'construct-text" "Text" "'Text" "construct-hyperlink-style" "'construct-hyperlink-style" "Hyperlink-Style" "'Hyperlink-Style" "construct-text-style" "'construct-text-style" "Text-Style" "'Text-Style" "construct-format" "'construct-format" "Format" "'Format" "construct-ior" "'construct-ior" "IOR" "'IOR" "construct-host" "'construct-host" "Host" "'Host" "construct-directory-group" "'construct-directory-group" "Directory-Group" "'Directory-Group" "construct-directory" "'construct-directory" "Directory" "'Directory" "construct-file" "'construct-file" "File" "'File" "construct-font" "'construct-font" "Font" "'Font" "construct-color" "'construct-color" "Color" "'Color" "construct-locales" "'construct-locales" "Locales" "'Locales" "construct-shortcut" "'construct-shortcut" "Shortcut" "'Shortcut" "construct-action" "'construct-action" "Action" "'Action" "construct-box" "'construct-box" "Box" "'Box" "construct-walk-location" "'construct-walk-location" "Walk-Location" "'Walk-Location" "construct-exception-detail" "'construct-exception-detail" "Exception-Detail" "'Exception-Detail" "construct-range" "'construct-range" "Range" "'Range" "construct-rect" "'construct-rect" "Rect" "'Rect" "construct-cell" "'construct-cell" "Cell" "'Cell" "construct-dimension" "'construct-dimension" "Dimension" "'Dimension" "construct-point" "'construct-point" "jazz.literals" "'jazz.literals" "Point" "'Point" "jazz.register-jazz-literal")
      {Lisp-Entry "jazz.registered-jazz-literals" #f 45 8 45 37 ()}
      {Lisp-Entry "jazz.jazz-literals-installed?" #f 48 8 48 37 ()}
      {Lisp-Entry "jazz.register-jazz-literal" #f 52 9 52 35 ("cons" "jazz.registered-jazz-literals" "set!" "register" "jazz.jazz-literals-installed?" "if" "constructor-name" "module" "name")
        {Lisp-Entry "register" #f 53 11 53 19 ()}}
      {Lisp-Entry "jazz.install-jazz-literals" #f 67 8 67 34 ("set!" "jazz.registered-jazz-literals" "literal" "for-each" "jazz.dialect" "'jazz.dialect" "core.library" "'core.library" "jazz.load-module" "begin" "jazz.jazz-readtable" "'jazz.jazz-readtable" "jazz.global-value" "jazz.jazz-literals-installed?" "if" "lambda")}}})
"list"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "dialect" "core" "list.scm"} 1238328026
    {Lisp-Entry "jazz.dialect.core.list" #f 37 18 37 40 ()
      {Lisp-Entry "jazz.proper-list" #f 40 9 40 25 ("jazz.queue-list" "%%cdr" "set!" "%%car" "jazz.enqueue" "%%pair?" "%%while" "jazz.new-queue" "proper" "let" "lst")}}})
"loop"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "dialect" "syntax" "loop.scm"} 1238328026
    {Lisp-Entry "jazz.dialect.syntax.loop" #f 37 19 37 43 ("scheme")
      {Lisp-Entry "loop" #f 131 9 131 13 ("expand-loop" "sourcify-if" "source-code" "cdr" "clauses" "let" "form-src")}
      {Lisp-Entry "noobject" #f 138 8 138 16 ("noobject" "'noobject" "list")}
      {Lisp-Entry "expand-loop" #f 142 9 142 20 ("set-cdr!" "'set-cdr!" "'begin" "jazz.null?" "'jazz.null?" "'cons" "'<list+>" "'<list>" "cns" "ptr" ",@unless-actions" "unless-actions" ",@when-actions" ",test" "when-actions" "body" "'when" "res" "what" ">" "'>" "rpt" "count" "specifier?" "then" "then-key" "first" "symbol?" "end" "decrease!" "'decrease!" ">=" "'>=" "downto" "below" "cddr" "<=" "'<=" "cadr" "scan" "by" "'increase!" "update" "to" "from" "in-properties" "1" "+" "'+" "element" "'element" "<" "'<" "length" "'length" "'<fx>" "'<vector>" "len" "vec" "vector" "in-vector" "get-next" "'get-next" "done?" "'done?" "iterate-sequence" "'iterate-sequence" "Iterator" "'Iterator" "is?" "'is?" "'if" "'<Iterator>" "itr" "val" "iterator" "in-sequence" "error" "remainder" "keyword" "'cdr" "'car" "'set!" "'null?" "either" "'<Object>" "in" "parse-for" "receive" "lst" "set-finally" "expr" "add-epilogue" "after" "add-after" "enqueue-list" "action-list" "add-actions" "action" "before" "add-before" "test" "add-test" "exit-safe" "values" "'not" "add-initial-test" "'<bool>" "'<Object+>" "ext" "ret" "get-return/exit" "add-with" "append" "list" "binding" "null?" "value" "type" "variable" "add-binding" "cons" "Unbound" "increase!" "->string" "string-append" "string->symbol" "symbol" "prefix" "unique" ",@finally" "begin" ",return" ",exit" "eq?" ",@epilogue" ",@afters" ",@actions" ",withs" ",@befores" ",@tests" "and" ",bindings" "let*" "queue-list" "cdr" "else" "process-finally" "process-return" "process-collect" "collect" "process-sum" "sum" "process-do" "do" "process-unless" "unless" "process-when" "when" "process-every" "every" "process-some" "some" "process-repeat" "repeat" "process-for" "for" "process-with" "with" "case" "rest" "key" "bind" "add-action" "source-code" "pair?" "not" "if" "car" "clause" "not-null?" "while" "new-queue" "expand-loop" "process-clauses" "set!" "expand" "define" "0" "unique-rank" "finally" "epilogue" "afters" "actions" "befores" "withs" "tests" "exit" "noobject" "return" "bindings" "let" "clauses")}}})
"macros"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "dialect" "syntax" "macros.scm"} 1238328026
    {Lisp-Entry "jazz.dialect.syntax.macros" #f 37 19 37 45 ("scheme")
      {Lisp-Entry "constant" #f 43 9 43 17 (",value" ",name" "definition" "sourcify-if" "caddr" "value" "source-code" "cadr" "name" "let" "form-src")}
      {Lisp-Entry "enumeration" #f 51 9 51 20 (",@definitions" "begin" "definition" "declaration" "lambda" "map" "definitions" "sourcify-if" "cddr" "declarations" "source-code" "cadr" "name" "let" "form-src")}
      {Lisp-Entry "when" #f 60 9 60 13 ("unspecified" "'unspecified" "list" "null?" "begin" ",test" "if" "sourcify-if" "cddr" "body" "source-code" "cadr" "test" "let" "form-src")}
      {Lisp-Entry "unless" #f 73 9 73 15 (",@body" "begin" ",test" "not" "if" "sourcify-if" "cddr" "body" "source-code" "cadr" "test" "let" "form-src")}
      {Lisp-Entry "prog1" #f 83 9 83 14 (",@body" "begin" ",returned" ",value" "sourcify-if" "generate-symbol" "value" "cddr" "body" "source-code" "cadr" "returned" "let" "form-src")}
      {Lisp-Entry "while" #f 94 9 94 14 (",@body" "begin" ",test" "if" ",iter" "sourcify-if" "generate-symbol" "iter" "cddr" "body" "source-code" "cadr" "test" "let" "form-src")}
      {Lisp-Entry "unwind-protect" #f 107 9 107 23 (",@protection" ",body" "function" "dynamic-wind" "sourcify-if" "cddr" "protection" "source-code" "cadr" "body" "let" "form-src")}
      {Lisp-Entry "catch" #f 120 9 120 14 ("desourcify" "error" "else" "car" "pair?" ",@body" "exc" "lambda" ",type" "call-with-catch" "symbol?" "cond" "sourcify-if" "cddr" "body" "source-code" "cadr" "type" "let" "form-src")}
      {Lisp-Entry "~" #f 137 9 137 10 (",name" "',name" ",obj" "dispatch" "apply" "rest" "obj" "lambda" "with-uniqueness" "sourcify-if" "cddr" "car" "object" "cadr" "source-code" "name" "let" "form-src")}
      {Lisp-Entry "form>>" #f 148 8 148 14 ("form")}
      {Lisp-Entry "expand-push!" #f 154 9 154 21 ("cons" "'cons" "set!" "'set!" "list" "value" "location")}
      {Lisp-Entry "expand-pop!" #f 160 9 160 20 ("cdr" "'cdr" "set!" "'set!" "list" "location")}
      {Lisp-Entry "expand-assert" #f 164 9 164 22 ("proc" "car" "error" "'error" "unless" "'unless" "list" ":text" "->string" "string-append" "message" "expr" "let*" "null?" "if" "rest" "first")}
      {Lisp-Entry "expand-assert-type" #f 175 9 175 27 ("type-name" "'type-name" "error" "'error" "is-not?" "'is-not?" "when" "'when" "list" "let*" "'let*" "cons" "generate-symbol" "value" "let" "type" "expr")}
      {Lisp-Entry "expand-error?" #f 183 9 183 22 ("begin" "'begin" "cons" "Error" "'Error" "catch" "'catch" "list" "generate-symbol" "err" "let" "body")}
      {Lisp-Entry "c-constant" #f 196 9 196 19 (",value" ",name" "definition" "sourcify-if" "caddr" "value" "source-code" "cadr" "name" "let" "form-src")}
      {Lisp-Entry "c-enumeration" #f 204 9 204 22 (",@definitions" "begin" "definition" "declaration" "lambda" "map" "definitions" "sourcify-if" "cddr" "declarations" "source-code" "cadr" "name" "let" "form-src")}}})
"memory"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "dialect" "core" "memory.scm"} 1245777538
    {Lisp-Entry "jazz.dialect.core.memory" #f 37 18 37 42 ()
      {Lisp-Entry "jazz.gc" #f 40 9 40 16 ("%%gc")}
      {Lisp-Entry "jazz.process-memory" #f 49 9 49 28 ("inexact->exact" "values" "19" "nonmovable" "18" "movable" "17" "live" "16" "alloc" "15" "f64vector-ref" "heap" "##process-statistics" "vec" "let")}
      {Lisp-Entry "jazz.symbols-memory" #f 62 9 62 28 ("values" "##symbol-table" "vector->list" "reverse" "cons" "2" "##vector-ref" "symbol?" "if" "loop" "map" "symbol->string" "string-length" "s" "length" "+" "set!" "lst" "lambda" "for-each" "chars" "0" "count" "let")}
      {Lisp-Entry "jazz.classes-statistics" #f 84 9 84 32 ("values" "jazz.Object" "method" "slot" "for-each" "process-method" "jazz.Method" "process-slot" "jazz.Slot" "jazz.is?" "cond" "field" "name" "lambda" "%%iterate-table" "%%get-class-interface-table" "%%get-class-class-table" "jazz.vector-vector-size" "%%get-class-core-vtable" "%%get-class-slots" "%%get-class-interfaces" "%%get-category-descendants" "jazz.list-size" "%%get-category-ancestors" "%%get-category-fields" "jazz.table-size" "jazz.vector-size" "1" "+" "set!" "class" "process-class" "define" "sz-methods" "nb-methods" "sz-slots" "nb-slots" "sz-interfaces" "nb-interfaces" "sz-classes" "0" "nb-classes" "let")}
      {Lisp-Entry "jazz.class-instances-count" #f 128 9 128 35 ("%%get-category-descendants" "for-each" "%%get-category-name" "jazz.instances-statistics" "%%table-ref" "%%fx+" "set!" "iter" "0" "count" "let" "class")}
      {Lisp-Entry "jazz.class-instances-size" #f 136 9 136 34 ("%%get-category-descendants" "for-each" "%%get-class-instance-size" "%%get-category-name" "jazz.instances-statistics" "%%table-ref" "%%fx*" "%%fx+" "set!" "iter" "0" "size" "let" "class")}
      {Lisp-Entry "jazz.word-bytes" #f 150 8 150 23 ("4")}
      {Lisp-Entry "jazz.f64-bytes" #f 151 8 151 22 ("8")}
      {Lisp-Entry "jazz.pair-bytes" #f 152 8 152 23 ("12")}
      {Lisp-Entry "jazz.table-bytes" #f 153 8 153 24 ("32")}
      {Lisp-Entry "jazz.vector-size" #f 156 9 156 25 ("##vector-length" "*" "jazz.word-bytes" "+" "v")}
      {Lisp-Entry "jazz.safe-vector-size" #f 159 9 159 30 ("0" "jazz.vector-size" "vector?" "if" "v")}
      {Lisp-Entry "jazz.f64vector-size" #f 164 9 164 28 ("f64vector-length" "jazz.f64-bytes" "*" "jazz.word-bytes" "+" "v")}
      {Lisp-Entry "jazz.vector-vector-size" #f 167 9 167 32 ("1" "vector-ref" "vector-length" "<" "size" "n" "iter" "let" "jazz.vector-size" "+" "0" "not" "if" "v")}
      {Lisp-Entry "jazz.list-size" #f 177 9 177 23 ("length" "jazz.pair-bytes" "*" "l")}
      {Lisp-Entry "jazz.table-size" #f 180 9 180 24 ("0" "##gc-hash-table?" "if" "##vector-length" "1" "+" "jazz.word-bytes" "*" "4" "floats" "5" "gcht2" "3" "##vector-ref" "gcht1" "let" "t")}}})
"network"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "dialect" "core" "network.scm"} 1238328026
    {Lisp-Entry "jazz.dialect.core.network" #f 37 18 37 43 ()
      {Lisp-Entry "jazz.open-tcp-client" #f 42 12 42 32 ("open-tcp-client")}
      {Lisp-Entry "jazz.open-tcp-server" #f 43 12 43 32 ("open-tcp-server")}
      {Lisp-Entry "jazz.tcp-server-socket-info" #f 44 12 44 39 ("tcp-server-socket-info")}
      {Lisp-Entry "jazz.call-with-tcp-client" #f 46 13 46 38 ("close-port" "if" "open-tcp-client" "set!" "lambda" "dynamic-wind" "port" "let" "proc" "settings")}
      {Lisp-Entry "jazz.socket-info-address" #f 57 12 57 36 ("socket-info-address")}
      {Lisp-Entry "jazz.socket-info-port-number" #f 58 12 58 40 ("socket-info-port-number")}}})
"number"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "dialect" "core" "number.scm"} 1238328026
    {Lisp-Entry "jazz.dialect.core.number" #f 37 18 37 42 ()
      {Lisp-Entry "jazz.fixnum->flonum" #f 47 9 47 28 ("jazz.Fixnum" "jazz.type-error" "##fixnum->flonum" "%%fixnum?" "if" "n")}
      {Lisp-Entry "jazz.flonum->fixnum" #f 52 9 52 28 ("jazz.Flonum" "jazz.type-error" "##flonum->fixnum" "%%flonum?" "if" "n")}
      {Lisp-Entry "jazz.+infinity" #f 63 8 63 22 ("+inf.0")}
      {Lisp-Entry "jazz.-infinity" #f 66 8 66 22 ("-inf.0")}
      {Lisp-Entry "jazz.random-integer" #f 77 12 77 31 ("random-integer")}
      {Lisp-Entry "jazz.random-real" #f 78 12 78 28 ("random-real")}
      {Lisp-Entry "jazz.random-source-randomize!" #f 79 12 79 41 ("random-source-randomize!")}
      {Lisp-Entry "jazz.random-source-pseudo-randomize!" #f 80 12 80 48 ("random-source-pseudo-randomize!")}
      {Lisp-Entry "jazz.default-random-source" #f 81 12 81 38 ("default-random-source")}}})
"pathname"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "dialect" "core" "pathname.scm"} 1238328026
    {Lisp-Entry "jazz.dialect.core.pathname" #f 37 18 37 44 ()
      {Lisp-Entry "jazz.pathname-expand" #f 42 12 42 32 ("path-expand")}
      {Lisp-Entry "jazz.file-rename" #f 43 12 43 28 ("rename-file")}
      {Lisp-Entry "jazz.directory-delete" #f 44 12 44 33 ("delete-directory")}
      {Lisp-Entry "jazz.current-directory" #f 46 13 46 35 ("jazz.pathname-exists?" "if" "jazz.pathname-normalize" "current-directory" "dir" "let")}
      {Lisp-Entry "jazz.current-directory-set!" #f 53 13 53 40 ("current-directory" "dir")}
      {Lisp-Entry "jazz.with-current-directory" #f 56 13 56 40 ("current-directory" "parameterize" "thunk" "dir")}}})
"port"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "dialect" "core" "port.scm"} 1238328026
    {Lisp-Entry "jazz.dialect.core.port" #f 37 18 37 40 ("jazz.dialect.language.get-console-port" "set!")
      {Lisp-Entry "jazz.close-port" #f 42 12 42 27 ("close-port")}
      {Lisp-Entry "jazz.input-port-timeout-set!" #f 43 12 43 40 ("input-port-timeout-set!")}
      {Lisp-Entry "jazz.output-port-timeout-set!" #f 44 12 44 41 ("output-port-timeout-set!")}
      {Lisp-Entry "jazz.dialect.language.get-console-port" #f 54 8 54 46 ()}
      {Lisp-Entry "jazz.get-console-port" #f 60 9 60 30 ("jazz.dialect.language.get-console-port" "if")}}})
"profile"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "dialect" "core" "profile.scm"} 1238328026
    {Lisp-Entry "jazz.dialect.core.profile" #f 37 18 37 43 ()
      {Lisp-Entry "active-profile" #f 40 22 40 36 ()}
      {Lisp-Entry "profile-total" #f 41 22 41 35 ()}
      {Lisp-Entry "profile-unknown" #f 42 22 42 37 ()}
      {Lisp-Entry "profile-calls" #f 43 22 43 35 ()}
      {Lisp-Entry "profile-reset!" #f 44 22 44 36 ()}
      {Lisp-Entry "profile-start!" #f 45 22 45 36 ()}
      {Lisp-Entry "profile-stop!" #f 46 22 46 35 ()}
      {Lisp-Entry "profile-running?" #f 47 22 47 38 ()}
      {Lisp-Entry "jazz.statprof-loaded?" #f 55 8 55 29 ()}
      {Lisp-Entry "jazz.load-statprof" #f 59 9 59 27 ("set!" "statprof" "'statprof" "jazz.load-module" "begin" "jazz.statprof-loaded?" "not" "if")}
      {Lisp-Entry "jazz.active-profile" #f 66 9 66 28 ("active-profile" "jazz.load-statprof")}
      {Lisp-Entry "jazz.profile-total" #f 71 9 71 27 ("profile-total" "jazz.load-statprof" "profile")}
      {Lisp-Entry "jazz.profile-unknown" #f 76 9 76 29 ("profile-unknown" "jazz.load-statprof" "profile")}
      {Lisp-Entry "jazz.profile-calls" #f 81 9 81 27 ("profile-calls" "jazz.load-statprof" "profile")}
      {Lisp-Entry "jazz.reset-profile" #f 86 9 86 27 ("profile-reset!" "jazz.load-statprof")}
      {Lisp-Entry "jazz.start-profile" #f 91 9 91 27 ("profile-start!" "jazz.load-statprof")}
      {Lisp-Entry "jazz.stop-profile" #f 96 9 96 26 ("profile-stop!" "jazz.load-statprof")}
      {Lisp-Entry "jazz.profile-running?" #f 101 9 101 30 ("profile-running?" "jazz.load-statprof")}}})
"reader"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "dialect" "core" "reader.scm"} 1238328026
    {Lisp-Entry "jazz.dialect.core.reader" #f 37 18 37 42 ()
      {Lisp-Entry "jazz.make-jazz-readtable" #f 47 13 47 37 ("jazz.jazzify-readtable!" "##main-readtable" "%%readtable-copy" "readtable-max-unescaped-char-set" "readtable" "let")}
      {Lisp-Entry "jazz.jazzify-readtable!" #f 53 13 53 36 ("jazz.read-delimited-string" "%%readtable-char-sharp-handler-set!" "jazz.read-comment" "jazz.read-literal" "%%readtable-char-class-set!" "jazz.named-chars" "jazz.readtable-named-char-table" "append" "jazz.readtable-named-char-table-set!" "readtable")}
      {Lisp-Entry "jazz.named-chars" #f 60 12 60 28 ()}
      {Lisp-Entry "jazz.in-expression-comment?" #f 107 12 107 39 ("make-parameter")}
      {Lisp-Entry "jazz.read-literal" #f 111 13 111 30 ("%%desourcify" "expr" "lambda" "map" "jazz.construct-literal" "jazz.in-expression-comment?" "jazz.parse-read?" "or" "jazz.readenv-wrap" "%%build-list" "lst" "jazz.error" "peek-char" "%%eqv?" "if" "read-char" "%%readenv-current-filepos" "start-pos" "jazz.readenv-port" "port" "let" "c" "re")}
      {Lisp-Entry "jazz.read-comment" #f 124 13 124 30 ("%%read-datum-or-label-or-none-or-dot" "read" "read-char" "jazz.in-expression-comment?" "parameterize" "jazz.readenv-port" "port" "let" "c" "re")}
      {Lisp-Entry "jazz.read-delimited-string" #f 133 13 133 39 ("get-output-string" "jazz.readenv-wrap" "peek-char" "and" "else" "write-char" "case" "escaped" "%%eqv?" "%%eof-object?" "cond" "c" "iter" "open-output-string" "output" "read-char" "jazz.readenv-port" "port" "let" "start-pos" "next" "re")}
      {Lisp-Entry "jazz.jazz-readtable" #f 162 12 162 31 ("jazz.make-jazz-readtable")}
      {Lisp-Entry "jazz.with-jazz-readtable" #f 166 13 166 37 ("jazz.jazz-readtable" "current-readtable" "parameterize" "thunk")}
      {Lisp-Entry "jazz.char-symbol" #f 171 13 171 29 ("%%car" "and" "jazz.rassq" "res" "jazz.jazz-readtable" "jazz.readtable-named-char-table" "table" "let" "char")}
      {Lisp-Entry "jazz.eof-object" #f 187 13 187 28 ("#!eof")}
      {Lisp-Entry "jazz.read-u8" #f 190 12 190 24 ("read-u8")}
      {Lisp-Entry "jazz.write-u8" #f 191 12 191 25 ("write-u8")}
      {Lisp-Entry "jazz.read-subu8vector" #f 192 12 192 33 ("read-subu8vector")}
      {Lisp-Entry "jazz.write-subu8vector" #f 193 12 193 34 ("write-subu8vector")}
      {Lisp-Entry "jazz.read-line" #f 195 12 195 26 ("read-line")}
      {Lisp-Entry "jazz.read-proper-line" #f 198 13 198 34 ("%%string-shrink!" "1" "%%fx-" "%%string-ref" "%%eqv?" "0" "%%fx>" "and" "%%string-length" "len" "values" "eof-object?" "if" "read-line" "line" "let" "port")}
      {Lisp-Entry "jazz.read-all" #f 207 12 207 25 ("read-all")}
      {Lisp-Entry "jazz.with-readtable" #f 210 13 210 32 ("current-readtable" "parameterize" "thunk" "readtable")}
      {Lisp-Entry "jazz.skip-whitespace" #f 217 9 217 29 ("read-char" "peek-char" "char-whitespace?" "%%while" "port")}
      {Lisp-Entry "jazz.read-delimited" #f 222 9 222 28 ("jazz.queue-list" "read-char" "read" "jazz.enqueue" "peek-char" "%%eqv?" "%%not" "%%while" "jazz.skip-whitespace" "jazz.new-queue" "queue" "let" "delimiter" "port")}
      {Lisp-Entry "jazz.read-until" #f 232 9 232 24 ("jazz.queue-list" "jazz.enqueue" "set!" "if" "read" "%%not" "%%while" "done?" "jazz.new-queue" "queue" "expr" "let" "port" "test")}
      {Lisp-Entry "jazz.read-content" #f 244 9 244 26 ("eof-object?" "jazz.read-until" "port")}}})
"repository"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "dialect" "core" "repository.scm"} 1238328026
    {Lisp-Entry "jazz.dialect.core.repository" #f 37 18 37 46 ()
      {Lisp-Entry "jazz.repository-name" #f 45 9 45 29 ("%%repository-name" "repository")}
      {Lisp-Entry "jazz.repository-directory" #f 48 9 48 34 ("%%repository-directory" "repository")}
      {Lisp-Entry "jazz.repository-library-root" #f 51 9 51 37 ("%%repository-library-root" "repository")}
      {Lisp-Entry "jazz.repository-library-directory" #f 54 9 54 42 ("%%repository-library-directory" "repository")}
      {Lisp-Entry "jazz.repository-binary?" #f 57 9 57 32 ("%%repository-binary?" "repository")}
      {Lisp-Entry "jazz.package-repository" #f 66 9 66 32 ("%%package-repository" "package")}
      {Lisp-Entry "jazz.package-name" #f 69 9 69 26 ("%%package-name" "package")}
      {Lisp-Entry "jazz.package-directory" #f 72 9 72 31 ("jazz.package-pathname" "package")}
      {Lisp-Entry "jazz.package-products" #f 75 9 75 30 ("%%package-products" "package")}
      {Lisp-Entry "jazz.package-project" #f 78 9 78 29 ("%%package-project" "package")}}})
"stack"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "dialect" "core" "stack.scm"} 1238328026
    {Lisp-Entry "jazz.dialect.core.stack" #f 37 18 37 41 ()
      {Lisp-Entry "jazz.get-procedure-name" #f 47 13 47 36 ("%%procedure-name" "if" "procedure")}
      {Lisp-Entry "jazz.get-continuation-stack" #f 53 13 53 40 ("jazz.queue-list" "%%continuation-next-frame" "1" "%%fx+" "jazz.enqueue" "begin" "and" "%%fx<" "not" "or" "if" "0" "d" "iter" "jazz.new-queue" "queue" "let" "depth" "cont")}
      {Lisp-Entry "jazz.get-continuation-name" #f 66 13 66 39 ("%%continuation-creator" "jazz.get-procedure-name" "cont")}
      {Lisp-Entry "jazz.collect-var-val" #f 70 13 70 33 ("##cte-parent-cte" "##inverse-eval-in-env" "##cte-top?" "if" "##object->string" "cons" "jazz.enqueue" "queue" "cte" "val" "var")}
      {Lisp-Entry "jazz.get-continuation-dynamic-environment" #f 78 13 78 54 ("jazz.queue-list" "##interaction-cte" "jazz.code-cte" "##interp-continuation-rte" "rte" "##interp-continuation-code" "$code" "%%interp-continuation?" "if" "jazz.continuation-denv" "##dynamic-env->list" "collect-parameters" "and" "jazz.new-queue" "queue" "let" "cont")
        {Lisp-Entry "collect-parameters" #f 80 15 80 33 ("%%list" "jazz.collect-var-val" "##inverse-eval-in-env" "x" "##hidden-parameter?" "%%not" "%%cdr" "val" "param" "%%car" "param-val" "let*" "%%pair?" "if" "iter" "let" "queue" "cte" "lst")}}
      {Lisp-Entry "jazz.get-continuation-lexical-environment" #f 105 13 105 54 ("jazz.queue-list" "##interaction-cte" "%%continuation-locals" "collect-locals" "begin" "jazz.code-cte" "collect-rte" "##interp-continuation-rte" "rte" "##interp-continuation-code" "$code" "%%interp-continuation?" "if" "and" "jazz.new-queue" "queue" "let" "cont")
        {Lisp-Entry "collect-rte" #f 107 15 107 26 ("else" "jazz.rte-up" "##cte-parent-cte" "jazz.collect-var-val" "##hidden-local-var?" "%%not" "%%car" "var" "%%pair?" "if" "%%vector->list" "%%cdr" "vals" "##cte-frame-vars" "vars" "loop2" "##cte-frame?" "##cte-top?" "cond" "r" "c" "loop1" "let" "queue" "rte" "cte")}
        {Lisp-Entry "collect-vars" #f 126 15 126 27 ("jazz.collect-var-val" "%%cdr" "val" "var" "%%car" "var-val" "let*" "%%pair?" "if" "iter" "let" "queue" "cte" "lst")}
        {Lisp-Entry "collect-locals" #f 135 15 135 29 ("collect-vars" "and" "queue" "cte" "lst")}}
      {Lisp-Entry "jazz.get-continuation-location" #f 152 13 152 43 ("%%continuation-locat" "jazz.locat->file/line/col" "cont")}
      {Lisp-Entry "jazz.with-repl-context" #f 156 13 156 35 ("jazz.repl-context-bind" "0" "1" "jazz.repl-context-level" "%%fx+" "jazz.make-repl-context" "context" "%%thread-repl-context-get!" "prev-context" "let" "thunk" "cont")}
      {Lisp-Entry "jazz.repl" #f 172 13 172 22 ("%%repl")}
      {Lisp-Entry "eval-within-no-winding" #f 184 13 184 35 ("##interaction-cte" "##compile-top" "%%make-source" "%%sourcify" "##compile-inner" "run" "##interp-continuation-rte" "rte" "jazz.code-cte" "cte" "##interp-continuation-code" "$code" "let*" "%%interp-continuation?" "if" "receiver" "repl-context" "cont" "src")
        {Lisp-Entry "run" #f 186 15 186 18 ("jazz.code-run" "let" "receiver" "repl-context" "jazz.repl-context-bind" "lambda" "cont" "%%continuation-graft-no-winding" "rte" "c")}}
      {Lisp-Entry "jazz.eval-within-no-winding" #f 209 13 209 40 ("car" "%%continuation-return-no-winding" "call-with-values" "results" "jazz.current-repl-context" "eval-within-no-winding" "return" "lambda" "continuation-capture" "cont" "expr")}
      {Lisp-Entry "jazz.repl-result-history-add" #f 224 13 224 41 ("%%repl-channel-result-history-add" "%%current-thread" "%%thread-repl-channel-get!" "channel" "let" "result")}
      {Lisp-Entry "jazz.inspect-repl-context" #f 234 13 234 38 ("context")}}})
"syntax"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "test" "performance" "syntax.scm"} 1237033585
    {Lisp-Entry "test.performance.syntax" #f 0 8 0 31 ()
      {Lisp-Entry "Z" #f 3 19 3 20 ("allocate-z" "jazz.Object-Class" "jazz.Object")}
      {Lisp-Entry "W" #f 11 19 11 20 ("allocate-w" "jazz.Object-Class" "Z")}}})
"system"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "dialect" "core" "system.scm"} 1238328026
    {Lisp-Entry "jazz.dialect.core.system" #f 37 18 37 42 ()
      {Lisp-Entry "jazz.open-process" #f 42 12 42 29 ("open-process")}
      {Lisp-Entry "jazz.process-status" #f 43 12 43 31 ("process-status")}
      {Lisp-Entry "jazz.exit" #f 44 12 44 21 ("exit")}
      {Lisp-Entry "jazz.switch?" #f 49 9 49 21 ("0" "string-ref" "eqv?" "or" "2" "string-length" ">=" "and" "arg")}
      {Lisp-Entry "jazz.switch-name" #f 55 9 55 25 ("string-length" "1" "substring" "arg")}
      {Lisp-Entry "jazz.command-argument" #f 59 9 59 30 ("cddr" "else" "cadr" "jazz.switch-name" "equal?" "jazz.error" "jazz.switch?" "not" "or" "cond" "car" "arg" "null?" "if" "arguments" "iter" "command-line" "cdr" "all" "let" "name")}}})
"table"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "dialect" "core" "table.scm"} 1238328026
    {Lisp-Entry "jazz.dialect.core.table" #f 37 18 37 41 ()
      {Lisp-Entry "jazz.table-clear" #f 40 9 40 25 ("%%table-clear" "%%table?" "%%debug-assert" "key" "table")}
      {Lisp-Entry "jazz.table-keys" #f 45 9 45 24 ("%%table-keys" "%%table?" "%%debug-assert" "table")}
      {Lisp-Entry "jazz.table-length" #f 50 9 50 26 ("%%table-length" "%%table?" "%%debug-assert" "table")}
      {Lisp-Entry "jazz.iterate-table" #f 55 9 55 27 ("%%iterate-table" "%%table?" "%%debug-assert" "proc" "table")}
      {Lisp-Entry "jazz.map-table" #f 60 9 60 23 ("jazz.queue-list" "jazz.enqueue" "value" "key" "lambda" "%%iterate-table" "jazz.new-queue" "queue" "let" "%%table?" "%%debug-assert" "proc" "table")}
      {Lisp-Entry "jazz.list->table" #f 69 9 69 25 ("%%list->table" "equal?" "test" "#!optional" "alist")}
      {Lisp-Entry "jazz.table->list" #f 73 9 73 25 ("%%table->list" "%%table?" "%%debug-assert" "table")}
      {Lisp-Entry "jazz.table-entries" #f 78 9 78 27 ("%%table-entries" "%%table?" "%%debug-assert" "table")}
      {Lisp-Entry "jazz.eq-hash" #f 85 12 85 24 ("eq?-hash")}
      {Lisp-Entry "jazz.eqv-hash" #f 86 12 86 25 ("eqv?-hash")}
      {Lisp-Entry "jazz.equal-hash" #f 87 12 87 27 ("equal?-hash")}}})
"template"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "dialect" "syntax" "template.scm"} 1238328026
    {Lisp-Entry "jazz.dialect.syntax.template" #f 37 19 37 47 ("scheme")}})
"templates"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "dialect" "syntax" "templates.scm"} 1238328026
    {Lisp-Entry "jazz.dialect.syntax.templates" #f 37 19 37 48 ("scheme")
      {Lisp-Entry "instantiate-for-each" #f 45 8 45 28 ("T" "name")}
      {Lisp-Entry "instantiate-butlast" #f 54 8 54 27 ("T")}
      {Lisp-Entry "instantiate-find" #f 61 8 61 24 ("T" "name")}
      {Lisp-Entry "instantiate-find-in" #f 80 8 80 27 ("T" "name")}
      {Lisp-Entry "instantiate-starts-with?" #f 208 8 208 32 ("T")}
      {Lisp-Entry "instantiate-ends-with?" #f 216 8 216 30 ("T")}}})
"thread"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "dialect" "core" "thread.scm"} 1238328026
    {Lisp-Entry "jazz.dialect.core.thread" #f 37 18 37 42 ()
      {Lisp-Entry "jazz.current-thread" #f 47 12 47 31 ("current-thread")}
      {Lisp-Entry "jazz.thread?" #f 48 12 48 24 ("thread?")}
      {Lisp-Entry "jazz.make-thread" #f 49 12 49 28 ("make-thread")}
      {Lisp-Entry "jazz.make-root-thread" #f 50 12 50 33 ("make-root-thread")}
      {Lisp-Entry "jazz.thread-name" #f 51 12 51 28 ("thread-name")}
      {Lisp-Entry "jazz.thread-specific" #f 52 12 52 32 ("thread-specific")}
      {Lisp-Entry "jazz.thread-specific-set!" #f 53 12 53 37 ("thread-specific-set!")}
      {Lisp-Entry "jazz.thread-base-priority" #f 54 12 54 37 ("thread-base-priority")}
      {Lisp-Entry "jazz.thread-base-priority-set!" #f 55 12 55 42 ("thread-base-priority-set!")}
      {Lisp-Entry "jazz.thread-priority-boost" #f 56 12 56 38 ("thread-priority-boost")}
      {Lisp-Entry "jazz.thread-priority-boost-set!" #f 57 12 57 43 ("thread-priority-boost-set!")}
      {Lisp-Entry "jazz.thread-start!" #f 58 12 58 30 ("thread-start!")}
      {Lisp-Entry "jazz.thread-yield!" #f 59 12 59 30 ("thread-yield!")}
      {Lisp-Entry "jazz.thread-sleep!" #f 60 12 60 30 ("thread-sleep!")}
      {Lisp-Entry "jazz.thread-terminate!" #f 61 12 61 34 ("thread-terminate!")}
      {Lisp-Entry "jazz.thread-join!" #f 62 12 62 29 ("thread-join!")}
      {Lisp-Entry "jazz.thread-send" #f 63 12 63 28 ("thread-send")}
      {Lisp-Entry "jazz.thread-receive" #f 64 12 64 31 ("thread-receive")}
      {Lisp-Entry "jazz.thread-interrupt!" #f 65 12 65 34 ("thread-interrupt!")}
      {Lisp-Entry "jazz.thread-thread-group" #f 66 12 66 36 ("thread-thread-group")}
      {Lisp-Entry "jazz.thread-group->thread-group-list" #f 67 12 67 48 ("thread-group->thread-group-list")}
      {Lisp-Entry "jazz.thread-group->thread-group-vector" #f 68 12 68 50 ("thread-group->thread-group-vector")}
      {Lisp-Entry "jazz.thread-group->thread-list" #f 69 12 69 42 ("thread-group->thread-list")}
      {Lisp-Entry "jazz.thread-group->thread-vector" #f 70 12 70 44 ("thread-group->thread-vector")}
      {Lisp-Entry "jazz.thread-state" #f 71 12 71 29 ("thread-state")}
      {Lisp-Entry "jazz.thread-state-abnormally-terminated-reason" #f 72 12 72 58 ("thread-state-abnormally-terminated-reason")}
      {Lisp-Entry "jazz.thread-state-abnormally-terminated?" #f 73 12 73 52 ("thread-state-abnormally-terminated?")}
      {Lisp-Entry "jazz.thread-state-active-timeout" #f 74 12 74 44 ("thread-state-active-timeout")}
      {Lisp-Entry "jazz.thread-state-active-waiting-for" #f 75 12 75 48 ("thread-state-active-waiting-for")}
      {Lisp-Entry "jazz.thread-state-active?" #f 76 12 76 37 ("thread-state-active?")}
      {Lisp-Entry "jazz.thread-state-initialized?" #f 77 12 77 42 ("thread-state-initialized?")}
      {Lisp-Entry "jazz.thread-state-normally-terminated-result" #f 78 12 78 56 ("thread-state-normally-terminated-result")}
      {Lisp-Entry "jazz.thread-state-normally-terminated?" #f 79 12 79 50 ("thread-state-normally-terminated?")}
      {Lisp-Entry "jazz.thread-state-uninitialized?" #f 80 12 80 44 ("thread-state-uninitialized?")}
      {Lisp-Entry "jazz.mutex?" #f 92 12 92 23 ("mutex?")}
      {Lisp-Entry "jazz.make-mutex" #f 93 12 93 27 ("make-mutex")}
      {Lisp-Entry "jazz.mutex-name" #f 94 12 94 27 ("mutex-name")}
      {Lisp-Entry "jazz.mutex-specific" #f 95 12 95 31 ("mutex-specific")}
      {Lisp-Entry "jazz.mutex-specific-set!" #f 96 12 96 36 ("mutex-specific-set!")}
      {Lisp-Entry "jazz.mutex-state" #f 97 12 97 28 ("mutex-state")}
      {Lisp-Entry "jazz.mutex-lock!" #f 98 12 98 28 ("mutex-lock!")}
      {Lisp-Entry "jazz.mutex-unlock!" #f 99 12 99 30 ("mutex-unlock!")}
      {Lisp-Entry "jazz.mutex-owner" #f 101 13 101 29 ("jazz.btq-owner" "mutex")}
      {Lisp-Entry "jazz.mutex-wait" #f 104 13 104 28 ("mutex-unlock!" "mutex-lock!" "mutex")}
      {Lisp-Entry "jazz.condition?" #f 118 12 118 27 ("condition-variable?")}
      {Lisp-Entry "jazz.make-condition" #f 119 12 119 31 ("make-condition-variable")}
      {Lisp-Entry "jazz.condition-name" #f 120 12 120 31 ("condition-variable-name")}
      {Lisp-Entry "jazz.condition-specific" #f 121 12 121 35 ("condition-variable-specific")}
      {Lisp-Entry "jazz.condition-specific-set!" #f 122 12 122 40 ("condition-variable-specific-set!")}
      {Lisp-Entry "jazz.condition-signal!" #f 123 12 123 34 ("condition-variable-signal!")}
      {Lisp-Entry "jazz.condition-broadcast!" #f 124 12 124 37 ("condition-variable-broadcast!")}}})
"time"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "test" "performance" "time.scm"} 1237033585
    {Lisp-Entry "test.performance.time" #f 0 8 0 29 ("new-z" "f-vtable" "f-generic" "f-separate" "iterations" "new-x" "f-module" "time")
      {Lisp-Entry "iterations" #f 3 8 3 18 ("100000000")}}}
  {Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "dialect" "core" "time.scm"} 1238328026
    {Lisp-Entry "jazz.dialect.core.time" #f 37 18 37 40 ()
      {Lisp-Entry "jazz.current-systime" #f 40 8 40 28 ("current-time")}
      {Lisp-Entry "jazz.systime?" #f 41 8 41 21 ("time?")}
      {Lisp-Entry "jazz.systime->seconds" #f 42 8 42 29 ("time->seconds")}
      {Lisp-Entry "jazz.seconds->systime" #f 43 8 43 29 ("seconds->time")}
      {Lisp-Entry "jazz.process-times" #f 44 8 44 26 ("process-times")}
      {Lisp-Entry "jazz.cpu-time" #f 45 8 45 21 ("cpu-time")}
      {Lisp-Entry "jazz.real-time" #f 46 8 46 22 ("real-time")}}})
"typecase"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "dialect" "syntax" "typecase.scm"} 1238328026
    {Lisp-Entry "jazz.dialect.syntax.typecase" #f 38 19 38 47 ("scheme")
      {Lisp-Entry "typecase" #f 51 9 51 17 (",value" ",variable" "is?" "or" "pair?" ",@body" "else" "'else" "eq?" "cdr" "body" "car" "desourcify" "value" "clause" "map" "cond" "variable" "lambda" "with-uniqueness" "sourcify-if" "cddr" "clauses" "source-code" "cadr" "target" "let" "form-src")}}})
"variables"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "test" "performance" "variables.scm"} 1237033585
    {Lisp-Entry "SEPARATE" #f 4 8 4 16 ("2")}
    {Lisp-Entry "inc-separate" #f 7 9 7 21 ("-" "1" "+" "SEPARATE" "set!" "begin" "0" ">" "if" "n" "iter" "let" "cnt")}
    {Lisp-Entry "BLOCK" #f 19 8 19 13 ("3")}
    {Lisp-Entry "inc-block" #f 22 9 22 18 ("-" "1" "+" "BLOCK" "set!" "begin" "0" ">" "if" "n" "iter" "let" "cnt")}})
"vb"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "test" "performance" "vb.scm"} 1237033585
    {Lisp-Entry "VAR" #f 5 8 5 11 ("2")}
    {Lisp-Entry "inc" #f 8 9 8 12 ("##fixnum.-" "1" "##fixnum.+" "VAR" "set!" "begin" "0" "##fixnum.>" "if" "n" "iter" "let" "cnt")}})
"vector"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "dialect" "core" "vector.scm"} 1238328026
    {Lisp-Entry "jazz.dialect.core.vector" #f 37 18 37 42 ()
      {Lisp-Entry "jazz.vector-copy" #f 45 8 45 24 ("vector-copy")}}})
"vs"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "test" "performance" "vs.scm"} 1237033585
    {Lisp-Entry "VAR" #f 4 8 4 11 ("2")}
    {Lisp-Entry "inc" #f 7 9 7 12 ("##fixnum.-" "1" "##fixnum.+" "VAR" "set!" "begin" "0" "##fixnum.>" "if" "n" "iter" "let" "cnt")}})
"with"
 ({Lisp-File-Entry {File Jazz "lib" "jazz" "src" "jazz" "dialect" "syntax" "with.scm"} 1238328026
    {Lisp-Entry "jazz.dialect.syntax.with" #f 37 19 37 43 ("scheme")
      {Lisp-Entry "with" #f 44 9 44 13 ("reverse" "car" "release" "binding" "lambda" "map" ",@body" "begin" "prog1" ",bindings" "let*" "sourcify-if" "cddr" "body" "cadr" "source-code" "bindings" "let" "form-src")}
      {Lisp-Entry "with-closed" #f 58 9 58 20 ("close" ",@body" "function" "dynamic-wind" "caddr" ",variable" "set!" "if" "variable" ",specifier" "car" "'<Object>" "binding-specifier" "or" "specifier" "binding" "lambda" "map" "sourcify-if" "cddr" "body" "cadr" "source-code" "bindings" "let" "form-src")}}})
