;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Platform-dependant Window Definitions (Windows)
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2008
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;    Assem Hakmeh
;;;    Jeremie Lasalle Ratelle
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(module protected jazz.ui.window.platform.windows jazz


(export (jazz.ui.window.platform.independant))


(import (jazz.geometry)
        (jazz.graphic)
        (jazz.io)
        (jazz.library)
        (jazz.platform)
        (jazz.platform.cairo)
        (jazz.snapshot)
        (jazz.system)
        (jazz.ui)
        (jazz.ui.window.platform.independant)
        (jazz.ui.window.platform.WindowManager))


(class WindowsWindowManager extends WindowManager

  (slot Windows-Table  initialize (make-table test: eqv?))
  ;; So that the window<->hwnd association can be made on the very first windows message
  (slot in-creation    initialize #f                      accessors generate)
  (slot Cursor-Cache   initialize (make-table test: eqv?))
  (slot callback-level initialize 0)
  (slot callback-thread-mutex initialize (make-mutex 'callback-thread-mutex))
  (slot callback-thread-condition initialize (make-condition 'callback-thread-condition))
  (slot CLASS_ATOM initialize #f) ;; some debugging BS
  (slot Symbolic-Keys initialize
        (list->table
         (list
          (cons VK_OEM_MINUS  #\-)
          (cons VK_OEM_PLUS   #\+)
          (cons VK_OEM_COMMA  #\,)
          (cons VK_OEM_PERIOD #\.)
          (cons VK_OEM_1      #\;)
          (cons VK_OEM_2      #\/)
          (cons VK_OEM_3      #\~)
          (cons VK_OEM_4      #\[)
          (cons VK_OEM_5      #\\)
          (cons VK_OEM_6      #\])
          (cons VK_OEM_7      #\')
          (cons VK_F1         'F1)
          (cons VK_F2         'F2)
          (cons VK_F3         'F3)
          (cons VK_F4         'F4)
          (cons VK_F5         'F5)
          (cons VK_F6         'F6)
          (cons VK_F7         'F7)
          (cons VK_F8         'F8)
          (cons VK_F9         'F9)
          (cons VK_F10        'F10)
          (cons VK_F11        'F11)
          (cons VK_F12        'F12)
          (cons VK_ESCAPE     'Escape)
          (cons VK_BACK       'Backspace)
          (cons VK_RETURN     'Return)
          (cons VK_SPACE      'Space)
          (cons VK_TAB        'Tab)
          (cons VK_HOME       'Home)
          (cons VK_END        'End)
          (cons VK_LEFT       'Left)
          (cons VK_UP         'Up)
          (cons VK_RIGHT      'Right)
          (cons VK_DOWN       'Down)
          (cons VK_PRIOR      'Prior)
          (cons VK_NEXT       'Next)
          (cons VK_INSERT     'Insert)
          (cons VK_PAUSE      'Pause)
          (cons VK_DELETE     'Delete)
          (cons VK_ADD        'Add)
          (cons VK_SUBTRACT   'Subtract)
          (cons VK_MULTIPLY   'Multiply)
          (cons VK_DIVIDE     'Divide))
         test: eqv?))
  (slot Cursors initialize
        (list
         (list :arrow               IDC_ARROW)
         (list :wait                IDC_WAIT)
         (list :ibeam               IDC_IBEAM)
         (list :cross               IDC_CROSS)
         (list :finger              IDC_HAND)
         (list :all                 IDC_SIZEALL)
         (list :west-east           IDC_SIZEWE)
         (list :no                  IDC_NO)
         (list :move                {Cursor-Resource "Move"})
         (list :opened-hand         {Cursor-Resource "OpenedHand"})
         (list :closed-hand         {Cursor-Resource "ClosedHand"})
         (list :zoom                {Cursor-Resource "Zoom"})
         (list :zoom-in             {Cursor-Resource "ZoomIn"})
         (list :zoom-out            {Cursor-Resource "ZoomOut"})
         (list :spy                 {Cursor-Resource "Spy"})
         (list :left-arrow          {Cursor-Resource "LeftArrow"})
         (list :vertical-splitter   {Cursor-Resource "VerticalSplitter"})
         (list :horizontal-splitter {Cursor-Resource "HorizontalSplitter"})))


  (method override (initialize . rest)
    (define (load-product-icon cx cy)
      (let ((product (or (jazz-product) 'jazz)))
        (let ((file (string-append kernel-install (format "build/products/{a}/{a}.ico" product product))))
          (if (file-exists? file)
              (LoadImage NULL file IMAGE_ICON cx cy LR_LOADFROMFILE)
              NULL))))
          
    (let ((instance (current-instance))
          (background (GetSysColorBrush COLOR_BTNFACE))
          (wc (WNDCLASSEX-make)))
      (WNDCLASSEX-cbSize-set! wc         (WNDCLASSEX-sizeof))
      (WNDCLASSEX-style-set! wc          (bitwise-ior CS_DBLCLKS))
      (WNDCLASSEX-lpfnWndProc-set! wc    call-process-hwnd-message)
      (WNDCLASSEX-cbClsExtra-set! wc     0)
      (WNDCLASSEX-cbWndExtra-set! wc     0)
      (WNDCLASSEX-hInstance-set! wc      instance)
      (WNDCLASSEX-hIcon-set! wc          (load-product-icon 32 32))
      (WNDCLASSEX-hCursor-set! wc        NULL)
      (WNDCLASSEX-hbrBackground-set! wc  background)
      (WNDCLASSEX-lpszMenuName-set! wc   NULL)
      (WNDCLASSEX-lpszClassName-set! wc  "JWindow")
      (WNDCLASSEX-hIconSm-set! wc        (load-product-icon 16 16))
      (set! CLASS_ATOM (RegisterClassEx wc)))
    (set-process-hwnd-message message-callback)
    (apply nextmethod rest))
  

;;;
;;;; Window
;;;


(method public override (get-window hwnd)
  (let ((hwnd (if (foreign? hwnd) (foreign-address hwnd) hwnd)))
    (table-ref Windows-Table hwnd #f)))


(method public override (register-window hwnd window)
  (if window
      (table-set! Windows-Table (foreign-address hwnd) window)
    (table-clear Windows-Table (foreign-address hwnd))))


(method public override (window-parent window)
  (let ((parent (get-parent~ window)))
    (if parent
        (get-handle~ parent)
      NULL)))


(method public override (window-default-parent window)
  (typecase window
    ((Dialog) (get-toplevel))
    (else #f)))


  (method public override (prepare-handle window rest)
    (define (create-handle window rest)
      (if (instance-of? window Desktop)
          (GetDesktopWindow)
          (CreateWindowEx
           (typecase window
                     ((Popup) WS_EX_TOOLWINDOW)
                     ((Palette) WS_EX_TOOLWINDOW)
                     ((Dialog) WS_EX_DLGMODALFRAME)
                     ((Toplevel) WS_EX_APPWINDOW)
                     ((External-Frame) 0)
                     ((Window) 0))
           CLASS_ATOM
           NULL
           ;;    (window-style window rest)
           (typecase window
                     ((Popup) (bitwise-ior WS_POPUP
                                           WS_CLIPCHILDREN))
                     ((Palette) (bitwise-ior WS_POPUP
                                             WS_OVERLAPPEDWINDOW
                                             WS_CLIPCHILDREN))
                     ((Dialog) (bitwise-ior WS_CLIPCHILDREN
                                            WS_CLIPSIBLINGS
                                            WS_POPUP
                                            WS_BORDER
                                            WS_OVERLAPPED
                                            WS_CAPTION
                                            WS_DLGFRAME
                                            (if (getf rest sizable?: not-found: #t) WS_THICKFRAME 0)
                                            (if (getf rest closable?: not-found: #t) WS_SYSMENU 0)))
                     ((Toplevel) (bitwise-ior WS_CLIPSIBLINGS
                                              WS_CLIPCHILDREN
                                              WS_POPUP
                                              WS_OVERLAPPEDWINDOW
                                              WS_MINIMIZEBOX
                                              WS_SYSMENU))
                     ((External-Frame) (bitwise-ior WS_POPUP
                                                    WS_OVERLAPPEDWINDOW
                                                    WS_SYSMENU
                                                    WS_CLIPCHILDREN
                                                    WS_CLIPSIBLINGS))
                     ((Window) (bitwise-ior WS_CHILD
                                            WS_CLIPCHILDREN
                                            WS_CLIPSIBLINGS)))
           0 0 500 500
           (window-parent window)
           NULL
           (current-instance)
           NULL)))
        
    (bind-keywords ((hwnd #f) . others) rest
      (set-in-creation window)
      (let ((hwnd (create-handle window rest)))
        (if (not hwnd)
            (error "Unable to create window {t} error {t}"
                   (list class: CLASS_ATOM parent: (window-parent window))
                   (GetLastError))
            (DragAcceptFiles hwnd #t)
            hwnd))))


(method public override (window-state handle)
  (let ((placement (WINDOWPLACEMENT-make)))
    (WINDOWPLACEMENT-length-set! placement (WINDOWPLACEMENT-sizeof))
    (GetWindowPlacement handle placement)
    (prog1 (ecase (WINDOWPLACEMENT-showCmd-ref placement)
             ((SW_SHOWMINIMIZED) 'minimized)
             ((SW_SHOWMAXIMIZED) 'maximized)
             (else 'restored))
      (WINDOWPLACEMENT-free placement))))


(method public override (set-window-placement handle position size)
  (let ((placement (WINDOWPLACEMENT-make)))
    (WINDOWPLACEMENT-length-set! placement (WINDOWPLACEMENT-sizeof))
    (WINDOWPLACEMENT-showCmd-set! placement SW_SHOWNORMAL)
    (let ((rect (WINDOWPLACEMENT-rcNormalPosition-ref placement)))
      (RECT-left-set! rect (get-h~ position))
      (RECT-top-set! rect (get-v~ position))
      (RECT-right-set! rect (+ (get-h~ position) (get-width~ size)))
      (RECT-bottom-set! rect (+ (get-v~ position) (get-height~ size))))
    (SetWindowPlacement handle placement)
    (WINDOWPLACEMENT-free placement)))


(method public override (show-window handle)
  (ShowWindow handle SW_SHOWNORMAL))


(method public override (show-maximized handle)
  (ShowWindow handle SW_MAXIMIZE))


(method public override (show-restored handle)
  (ShowWindow handle SW_RESTORE))


(method public override (hide-window handle)
  (ShowWindow handle SW_HIDE))
 
 
(method public override (minimize-window handle)
  (ShowWindow handle SW_MINIMIZE))


(method public override (maximize-window handle)
  (ShowWindow handle SW_MAXIMIZE))

 
(method public override (restore-window handle)
  (ShowWindow handle SW_RESTORE))


(method public override (destroy-window handle)
  (DestroyWindow handle)
  (nextmethod handle))


;;;
;;;; C Stack unwinding
;;;


;; This only works with one restart. Should do a more general mechanism
;; to link an entry and an exit call.
(define c-stack-unwinding-restart #f)


(definition (with-c-stack-unwinding-entry thunk)
  (let ((result (continuation-checkpoint
                  (lambda (restart)
                    (error "Trying to invoke a continuation located beyond protected c code"))
                  thunk
                  (lambda (restart)
                    (error "A continuation has been invoked beyond protected c code without an exit protection")))))
    (if c-stack-unwinding-restart
        (let ((restart c-stack-unwinding-restart))
          (set! c-stack-unwinding-restart #f)
          (restart))
      result)))


(definition (with-c-stack-unwinding-exit thunk cleanup)
  (continuation-capture
    (lambda (exit)
      (continuation-checkpoint
        (lambda (restart)
          (error "A continuation located beyond protected c code has been invoked without an entry protection"))
        thunk
        (lambda (restart)
          (set! c-stack-unwinding-restart restart)
          (continuation-graft exit cleanup))))))


;;;
;;;; Message Pump
;;;


(method public override (process-messages-single-threaded thunk)
  (define (process-message msg)
    (unless (translate-shortcut msg)
      (TranslateMessage msg)
      (with-c-stack-unwinding-entry
        (lambda ()
          (DispatchMessage msg)))))
  
  (declare (proper-tail-calls))

  
  (let ((msg (MSG-make)))
    (let (loop)
      (let ((message (GetMessage msg NULL 0 0)))
        (when message
          (process-message msg)
          (thunk)
          (loop))))
    (MSG-free msg)))


;;;
;;;; Dispatch
;;;


(method (process-window-message window msg <int> wparam <int> lparam <int>)
  (define get-x-lparam signed-loword)
  (define get-y-lparam signed-hiword)
  (define get-wheel-delta-wparam signed-hiword)

  (define (wm-get-update-region handle)
    (let ((region (new Region)))
      (GetUpdateRgn handle (get-handle~ region) #f)
      region))

  (define (convert-state wparam)
    (ecase wparam
      ((SIZE_MINIMIZED) 'minimized)
      ((SIZE_MAXIMIZED) 'maximized)
      (else             'restored)))

  (ecase msg
    ((WM_PAINT)           (with ((region (wm-get-update-region (get-handle~ window))))
                            (paint~ window region)))
    ((WM_SETCURSOR)       (cursor-update~ window (= (loword lparam) HTCLIENT)))
    ((WM_MOUSEMOVE)       (mouse-move~ window (get-x-lparam lparam) (get-y-lparam lparam)))
    ((WM_MOUSEWHEEL)      (mouse-wheel~ window (get-x-lparam lparam) (get-y-lparam lparam) (get-wheel-delta-wparam wparam)))
    ((WM_LBUTTONDOWN)     (mouse-down~ window (get-x-lparam lparam) (get-y-lparam lparam)))
    ((WM_LBUTTONUP)       (mouse-up~ window (get-x-lparam lparam) (get-y-lparam lparam)))
    ((WM_LBUTTONDBLCLK)   (double-click~ window (get-x-lparam lparam) (get-y-lparam lparam)))
    ((WM_MBUTTONDOWN)     (middle-mouse-down~ window (get-x-lparam lparam) (get-y-lparam lparam)))
    ((WM_MBUTTONUP)       (middle-mouse-up~ window (get-x-lparam lparam) (get-y-lparam lparam)))
    ((WM_RBUTTONDOWN)     (right-mouse-down~ window (get-x-lparam lparam) (get-y-lparam lparam)))
    ((WM_RBUTTONUP)       (right-mouse-up~ window (get-x-lparam lparam) (get-y-lparam lparam)))
    ((WM_CONTEXTMENU)     (call-context-menu~ window (get-x-lparam lparam) (get-y-lparam lparam)))
    ((WM_SYSKEYDOWN)      (if (= wparam VK_MENU) (system-key-down~ window) unprocessed))
    ((WM_SYSKEYUP)        (if (= wparam VK_MENU) (system-key-up~ window) unprocessed))
    ((WM_KEYDOWN)         (key-down~ window wparam))
    ((WM_KEYUP)           (key-up~ window wparam))
    ((WM_CHAR)            (call-key-press~ window (integer->char wparam)))
    ((WM_MOVE)            (call-position-change~ window (get-x-lparam lparam) (get-y-lparam lparam)))
    ((WM_SIZE)            (let ((state (convert-state wparam)))
                            (unless (eq? state 'minimized)
                              (let ((width (get-x-lparam lparam))
                                    (height (get-y-lparam lparam)))
                                (if (or (/= width 0) (/= height 0))
                                    (call-size-change~ window state width height)
                                  unprocessed)))))
    ((WM_MOUSELEAVE)      (mouse-leave~ window))
    ((WM_MOUSEACTIVATE)   (if (mouse-activate?~ window)
                              (on-mouse-activate~ window)
                            (list 'processed MA_NOACTIVATE)))
    ((WM_ACTIVATE)        (let ((kind (if (= (loword wparam) WA_INACTIVE) 'inactive 'active)))
                            (on-activate~ window kind)))
    ((WM_ACTIVATEAPP)     (if (/= wparam 0)
                              (activate-application~ window)
                            (deactivate-application~ window)))
    ((WM_CLOSE)           (on-close~ window #f))
    ((WM_SETFOCUS)        (focus-gain~ window))
    ((WM_KILLFOCUS)       (focus-lose~ window))
    ((WM_DROPFILES)       (drop-files~ window wparam))
    (else                 (unprocessed-message~ window))))


(method (message-callback hwnd <foreign> msg <int> wparam <int> lparam <int>)
  (define (process)
    (let ((window (get-window hwnd)))
      (when (and (not window) (get-in-creation))
        (set! window (get-in-creation))
        (set-handle~ window hwnd)
        (register-window hwnd window)
        (set-in-creation #f))
      (if (not window)
          (DefWindowProc hwnd msg wparam lparam)
        (dispatch-message window msg wparam lparam))))
  
  (with-c-stack-unwinding-exit
    (lambda ()
      (if (eq? (current-thread) (primordial-thread))
          (process)
          (snapshot-process reason: "Message callback from non-primordial thread")
          (exit 1)))
    (lambda ()
      (DefWindowProc hwnd msg wparam lparam))))


(method (dispatch-message window msg <int> wparam <int> lparam <int>)
  (let ((return (process-window-message window msg wparam lparam)))
    (if (eq? return unprocessed)
        (DefWindowProc (get-handle~ window) msg wparam lparam)
        (if (and (pair? return) (eq? (car return) 'processed))
            (if (null? (cdr return))
                0
                (cadr return))
            0))))

;;;
;;;; Shortcuts
;;;


;; - standard usage -
;; ()                     : letters
;; (:shift)               : capital letters
;; (:control)             : mostly for focus
;; (:alt)                 : mostly for focus
;; (:control :alt)        : mostly for platform standards and window selection
;; (:control :shift)      : mostly for window selection
;; (:alt :shift)          : workspace management
;; (:control :alt :shift) : favorite files


(method (translate-shortcut msg)
  (define (modifiers)
    (let ((modifiers '()))
      (let ((try
              (lambda (down? modifier)
                (when down?
                  (set! modifiers (cons modifier modifiers))))))
        (try (wm-alt-down?) :alt)
        (try (wm-shift-down?) :shift)
        (try (wm-ctrl-down?) :control)
        modifiers)))
  
  (define (key code)
    (and (/= code VK_SHIFT)
         (/= code VK_CONTROL)
         (/= code VK_MENU)
         (/= code VK_LMENU)
         (or (table-ref Symbolic-Keys code #f)
             (integer->char code))))
  
  (let ((appl (get-application)))
    (if (not appl)
        #f
      (let ((message (MSG-message-ref msg)))
        (if (or (= message WM_KEYDOWN)
                (= message WM_SYSKEYDOWN))
            (let ((key (key (MSG-wParam-ref msg))))
              (if key
                  (dispatch-shortcut~ appl (new Shortcut (modifiers) key))
                #f))
          #f)))))


;;;
;;;; Input
;;;


  (method (key-down? key)
    (/= (hibyte (GetAsyncKeyState key)) 0))


  (method public override (wm-shift-down?)
    (key-down? VK_SHIFT))


  (method public override (wm-ctrl-down?)
    (and (key-down? VK_CONTROL) (not (key-down? VK_RMENU))))


  (method public override (wm-alt-down?)
    (key-down? VK_LMENU))


  (method public override (wm-mouse-clicked?)
    (key-down? VK_LBUTTON))


;;;
;;;; Messages
;;;


(method public override (set-capture handle)
  (SetCapture handle))


(method public override (unset-capture)
  (ReleaseCapture))


(method public override (with-platform-painting window wm-data proc)
  (if (debug-painting?)
      (debugging-with-wm-painting window proc)
    (let ((handle (get-handle~ window)))
      (let ((ps (PAINTSTRUCT-make)))
        (let ((hdc (BeginPaint handle ps)))
          (let ((surface (new Surface (cairo_win32_surface_create hdc))))
            (unwind-protect
                (proc surface)
              (close~ surface)
              (EndPaint handle ps))))
        (PAINTSTRUCT-free ps)))
    processed))


(definition (debugging-with-wm-painting window proc)
  (let ((handle (get-handle~ window)))
    (let ((hdc (GetDC handle)))
      (ValidateRgn handle NULL)
      (let ((surface (new Surface (cairo_win32_surface_create hdc))))
        (unwind-protect
            (proc surface)
          (close~ surface)))))
  processed)


(method public override (get-window-surface window)
  (cairo_win32_surface_create (GetDC (get-handle~ window))))


;;;
;;;; Layers
;;;


(method public override (set-alpha-blending handle n)
  (SetWindowLong handle GWL_EXSTYLE (mask-bit-set (GetWindowLong handle GWL_EXSTYLE) WS_EX_LAYERED #t))
  (SetLayeredWindowAttributes handle 0 n LWA_ALPHA)
  (RedrawWindow handle NULL NULL (bitwise-ior RDW_ERASE RDW_INVALIDATE)))


;;;
;;;; Tracking
;;;


(method (track-mouse-event handle flags (time: time HOVER_DEFAULT))
  (let ((rec (TRACKMOUSEEVENT-make)))
    (TRACKMOUSEEVENT-cbSize-set! rec (TRACKMOUSEEVENT-sizeof))
    (TRACKMOUSEEVENT-dwFlags-set! rec flags)
    (TRACKMOUSEEVENT-hwndTrack-set! rec handle)
    (TRACKMOUSEEVENT-dwHoverTime-set! rec time)
    (TrackMouseEvent rec)
    (TRACKMOUSEEVENT-free rec)))


(method public override (track-mouse-leave handle)
  (track-mouse-event handle TME_LEAVE))


(method public override (cancel-mouse-leave-tracking handle)
  (track-mouse-event handle (bitwise-ior TME_CANCEL TME_LEAVE)))


;;;
;;;; Management
;;;


(method public override (wm-set-parent handle parent)
  (SetParent handle (if parent (get-handle~ parent) NULL)))


(method public override (set-window-title handle title)
  (SetWindowText handle title))

  
(method public override (acquire-point to-handle from-handle shape)
  (when (not to-handle)
    (error "No window handle"))
  (let ((acquired (point->POINT shape)))
    (MapWindowPoints from-handle to-handle acquired 1)
    (prog1 (POINT->point acquired)
      (POINT-free acquired))))


(method public override (acquire-rect to-handle from-handle shape)
  (let ((acquired (rect->RECT shape)))
    (MapWindowPoints from-handle to-handle (RECT->POINTS acquired) 2)
    (prog1 (RECT->rect acquired)
      (RECT-free acquired))))


(method public override (wm-translate-to-root handle pt)
  (let ((pos (point->POINT pt)))
    (MapWindowPoints handle NULL pos 1)
    (prog1 (new Point (POINT-x-ref pos) (POINT-y-ref pos))
      (POINT-free pos))))


(method public override (wm-get-position handle parent-handle) <Point>
  (let ((rect (RECT-make)))
    (GetWindowRect handle rect)
    (when (and parent-handle (mask-bit-set? (GetWindowLong handle GWL_STYLE) WS_CHILD))
      (MapWindowPoints NULL parent-handle (RECT->POINTS rect) 2))
    (prog1 (new Point (RECT-left-ref rect) (RECT-top-ref rect))
      (RECT-free rect))))


(method public override (wm-set-position handle pos)
  (SetWindowPos handle NULL (get-h~ pos) (get-v~ pos) 0 0 (bitwise-ior SWP_NOSIZE SWP_NOZORDER SWP_NOACTIVATE)))


(method public override (wm-get-size handle) <Dimension>
  (let ((rect (RECT-make)))
    (GetClientRect handle rect)
    (prog1 (new Dimension (RECT-right-ref rect) (RECT-bottom-ref rect))
      (RECT-free rect))))


(method public override (wm-get-window-size handle) <Dimension>
  (let ((rect (RECT-make)))
    (GetWindowRect handle rect)
    (prog1 (new Dimension (- (RECT-right-ref rect)  (RECT-left-ref rect))
                          (- (RECT-bottom-ref rect) (RECT-top-ref rect)))
      (RECT-free rect))))


(method public override (wm-set-window-size handle size)
  (SetWindowPos handle NULL 0 0 (get-width~ size) (get-height~ size) (bitwise-ior SWP_NOCOPYBITS SWP_NOMOVE SWP_NOZORDER SWP_NOACTIVATE)))


(method public override (wm-get-rect handle parent-handle) <Rect>
  (let ((rect (RECT-make)))
    (GetWindowRect handle rect)
    (when parent-handle
      (MapWindowPoints NULL parent-handle (RECT->POINTS rect) 2))
    (prog1 (new Rect (RECT-left-ref rect) (RECT-top-ref rect) (RECT-right-ref rect) (RECT-bottom-ref rect))
      (RECT-free rect))))


(method public override (wm-set-rect handle rect)
  (SetWindowPos handle NULL (get-left~ rect) (get-top~ rect) (rect-width rect) (rect-height rect) (bitwise-ior SWP_NOZORDER SWP_NOACTIVATE)))


(method public override (wm-get-bounds handle) <Rect>
  (let ((rect (RECT-make)))
    (GetWindowRect handle rect)
    (MapWindowPoints NULL handle rect 2)
    (prog1 (new Rect (RECT-left-ref rect) (RECT-top-ref rect) (RECT-right-ref rect) (RECT-bottom-ref rect))
      (RECT-free rect))))


(method public override (wm-mouse-position) <Point>
  (let ((point (POINT-make)))
    (GetCursorPos point)
    (prog1 (new Point (POINT-x-ref point) (POINT-y-ref point))
      (POINT-free point))))


(method public override (wm-window-from-point point)
  (let ((pt (POINT-make)))
    (POINT-x-set! pt (get-h~ point))
    (POINT-y-set! pt (get-v~ point))
    (prog1 (WindowFromPoint pt)
      (POINT-free pt))))


(method public override (wm-move-window handle x y cx cy)
  (MoveWindow handle x y cx cy #t))


(method public override (wm-enable-window handle)
  (EnableWindow handle #t))


(method public override (wm-disable-window handle)
  (EnableWindow handle #f))


(method public override (wm-get-client-rect handle)
  (let ((rect (RECT-make)))
    (GetClientRect handle rect)
    (prog1 (RECT->rect rect)
      (RECT-free rect))))


(method public override (wm-scroll-window handle dh dv rect clip-rect)
  (let ((flags SW_INVALIDATE))
    (let ((rect (rect->RECT rect))
          (clip-rect (rect->RECT clip-rect)))
      (prog1 (ScrollWindowEx handle dh dv rect clip-rect NULL NULL flags)
        (RECT-free rect)
        (RECT-free clip-rect)))))


(method public override (wm-invalidate-rect handle rect)
  ;; is this test correct or was it a patch made during the port
  (when handle
    (with-RECT rect
      (lambda (rect)
        (InvalidateRect handle rect #f)))))


(method public override (wm-invalidate-region handle region)
  ;; is this test correct or was it a patch made during the port
  (when handle
    (InvalidateRgn handle (get-handle~ region) #f)))


(method public override (wm-invalidate-window handle)
  ;; is this test correct or was it a patch made during the port
  (when handle
    (InvalidateRect handle NULL #f)))


(method public override (wm-redraw-window handle rect region)
  ;; is this test correct or was it a patch made during the port
  (when handle
    ;; Changed RDW_NOCHILDREN to RDW_ALLCHILDREN so that a redraw-window on the
    ;; toplevel would redraw it's children. Hope it doesn't break any code...
    (let ((flags (bitwise-ior RDW_ERASENOW RDW_UPDATENOW RDW_INVALIDATE RDW_ALLCHILDREN)))
      (let ((rect (if (not rect) NULL (rect->RECT rect))))
        (prog1 (RedrawWindow handle rect (if region (get-handle~ region) NULL) flags)
          (when rect
            (RECT-free rect)))))))


(method public override (wm-update-window handle)
  (UpdateWindow handle))
  
  
(method public override (wm-show-noactivate handle)
  (SetWindowPos handle HWND_TOP 0 0 0 0 (bitwise-ior SWP_SHOWWINDOW SWP_NOACTIVATE SWP_NOMOVE SWP_NOSIZE)))


(method public override (bring-window-to-front handle)
  (BringWindowToTop handle))


(method public override (send-window-to-back handle)
  (SetWindowPos handle HWND_BOTTOM 0 0 0 0 (bitwise-ior SWP_NOMOVE SWP_NOSIZE)))


(method public override (select-foreground-window handle)
  (SetForegroundWindow handle))


(method public override (get-window-handle-title handle)
  (let* ((size (+ (GetWindowTextLength handle) 1))
         (buffer (WCHAR-array-make size)))
    (GetWindowText handle buffer size)
    (let ((str (WCHAR-string buffer)))
      (WCHAR-array-free buffer)
      str)))


;;;
;;;; Focus
;;;


(method public override (wm-set-focus handle)
  ;; Note that setting the focus on an inactive is not correct
  ;; An explicit call to BringWindowToTop must be made beforehand
  (SetFocus handle))


(method public override (wm-get-focus)
  (GetFocus))


;;;
;;;; Cursor
;;;


(method public override (load-cursor cursor)
  (define (cursor-name cursor)
    (if (number? cursor)
        cursor
      (get-name~ cursor)))
  
  (define (load name)
    (if (number? name)
      (LoadCursorInt name)
      (let ((ident (parse~ (get-resource~ (get-application) 'cursor name))))
        (LoadImage NULL ident IMAGE_CURSOR 0 0 LR_LOADFROMFILE))))
  
  (let ((name (cursor-name cursor)))
    (or (table-ref Cursor-Cache name #f)
        (let ((cursor (load name)))
          (table-set! Cursor-Cache name cursor)
          cursor))))


(method public override (wm-set-cursor cursor)
  (define (get-named-cursor name)
    (let ((info (assq name Cursors)))
      (if (not info)
          (error "Unknown cursor: {t}" name)
          (cadr info))))

  (unless #f @to-fix-this-doesnt-work-when-switching-overlapped-windows! (= cursor Current-Cursor)
          (set! Current-Cursor cursor)
          (let ((cursor (if (symbol? cursor) (get-named-cursor cursor) cursor)))
            (SetCursor (load-cursor cursor)))))


;;;
;;;; Redraw View Only
;;;


(method public override (wm-redraw-view-only view hwnd)
  (let ((hrgn (CreateRectRgn 0 0 0 0)))
    ;; preserve the current update region
    (GetUpdateRgn hwnd hrgn #f)
    ;; reset it
    (ValidateRect hwnd NULL)
    ;; redraw the view only
    (redraw-view~ view)
    ;; reinvalidate the preserved update region
    (InvalidateRgn hwnd hrgn #f)
    (DeleteObject hrgn)))


(method public override (wm-get-desktop)
  (GetDesktopWindow))


;;;
;;;; Work Area
;;;


(method public override (get-work-area) <Rect>
  ;; Because Window's SPI_GETWORKAREA doesn't take autohide into account
  (define (adjust-work-area-with-taskbar rect)
    rect
    @convert
    (let ((state (get-taskbar-state))
          (edge (get-taskbar-edge)))
      (if (and (mask-bit-set? state ABS_AUTOHIDE) (mask-bit-set? state ABS_ALWAYSONTOP))
          (ecase edge
            ((ABE_LEFT)   (expand-rect rect  1  0  0  0))
            ((ABE_TOP)    (expand-rect rect  0  1  0  0))
            ((ABE_RIGHT)  (expand-rect rect  0  0 -1  0))
            ((ABE_BOTTOM) (expand-rect rect  0  0  0 -1)))
        rect)))

  (let ((area (RECT-make)))
    (SystemParametersInfo SPI_GETWORKAREA 0 area 0)
    (prog1 (adjust-work-area-with-taskbar (RECT->rect area))
      (RECT-free area))))


;;;
;;;; Drop Files
;;;


(method public override (wm-drop-files window wparam)
  (define (received-files hdrop)
    (let ((count (DragQueryFile hdrop #xFFFFFFFF NULL 0)))
      (map (lambda (n)
             (let* ((size MAX_PATH)
                    (buffer (WCHAR-array-make size)))
               (WCHAR-array-set! buffer 0 #\nul)
               (DragQueryFile hdrop n buffer size)
               (let* ((filename (WCHAR-string buffer))
                      (pathname (new (case (pathname-type filename) ((directory) Directory) (else File)) (tokenise-windows filename))))
                 (prog1 (anchorize~ pathname)
                   (WCHAR-array-free buffer)))))
           (naturals 0 count))))
  
  (let ((hdrop (WPARAM->HDROP wparam)))
    (let ((files (received-files hdrop))
          (pt (POINT-make)))
      (DragQueryPoint hdrop pt)
      (DragFinish hdrop)
      (receive-files~ window (POINT->point pt) files)
      (POINT-free pt))))))
